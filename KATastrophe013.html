<!DOCTYPE HTML>
<html>

<!-- HEADER -->

<!-- Borksy 5.8.0 -->
<!-- bitsy-hacks 19.2.7 -->
<!-- Bitsy 7.11 -->
<head>

<meta charset="UTF-8">

<title>KATastrophe</title>

<script type="text/bitsyGameData" id="exportedGameData">
{rbw}KATastrophe{rbw}

# BITSY VERSION 7.12

! ROOM_FORMAT 1

PAL 0
NAME PinkOrangeBlu
241,70,215
152,245,193
79,53,153

PAL 1
0,255,58
189,255,0
0,216,255

ROOM 1
n,n,n,n,p,d,23,e,l,0,0,0,0,0,0,0
j,0,0,0,0,0,0,0,q,n,n,n,n,n,n,0
s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,q
i,0,0,0,0,0,0,0,0,0,0,0,0,0,0,h
m,m,r,0,0,o,m,m,m,m,m,m,r,0,0,w
0,0,k,0,0,l,0,0,a,a,a,0,k,0,0,g
0,0,k,0,0,l,0,0,a,0,a,0,k,0,0,0
0,0,k,0,0,l,0,0,a,a,a,0,k,0,0,0
n,n,p,0,0,l,0,0,a,0,a,0,k,0,0,0
j,0,0,0,0,l,0,0,a,0,a,0,k,0,0,0
u,0,0,0,0,q,n,n,n,n,n,n,p,0,0,h
i,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1f
m,m,m,r,0,0,0,0,0,0,0,0,0,0,0,g
0,0,0,k,0,0,0,o,m,m,r,0,0,0,o,m
0,0,0,k,0,0,0,l,0,0,k,0,0,0,l,0
0,0,0,k,c,1e,b,l,0,0,k,c,v,b,l,0
NAME a main NEVER DELETE
ITM 2i 9,11
ITM 2i 13,14
ITM 2i 7,1
ITM 2i 3,4
ITM 2h 4,14
ITM 2h 0,3
ITM 2h 5,0
ITM 1d 4,6
ITM 1d 9,3
ITM 1d 3,1
ITM 1d 11,12
ITM 1e 13,2
ITM s 13,5
ITM 2k 13,8
ITM 1c 14,7
ITM 1g 15,8
ITM 1f 15,7
ITM 1f 15,5
ITM 19 15,12
ITM 1a 15,10
ITM 17 15,11
ITM 1h 14,12
ITM z 14,8
ITM z 14,6
ITM t 15,6
ITM 19 13,3
ITM 15 14,2
ITM t 13,9
ITM 15 15,3
ITM 16 14,3
ITM 17 15,4
ITM 13 13,4
ITM n 14,5
ITM n 14,9
ITM n 13,10
ITM t 15,9
ITM 2l 14,4
ITM t 12,2
ITM t 12,3
ITM 1e 11,2
ITM 2h 11,3
ITM 2i 10,2
ITM 2i 14,10
ITM 2i 13,11
ITM 2i 14,11
ITM 2i 13,12
ITM 2b 11,13
ITM 2b 9,2
ITM 2b 7,0
EXT 5,15 2 5,0 FX slide_d DLG u
EXT 6,0 6 6,15 FX slide_u DLG v
EXT 12,15 5 12,0 FX slide_d DLG 12
EXT 0,2 1 15,4 DLG 3b
EXT 15,4 1 0,2 DLG 3c
EXT 15,11 1 9,6 DLG 3d
EXT 0,10 f 15,10 FX slide_l DLG 4p
PAL 0

ROOM 2
0,0,0,p,d,1e,e,l,0,0,0,0,0,0,0,0
0,0,k,j,0,0,0,q,0,0,a,a,a,0,0,0
0,0,k,y,0,0,0,h,l,0,a,0,a,0,0,0
0,0,k,i,0,0,0,z,l,0,a,a,a,0,0,0
0,0,0,r,0,0,0,g,l,0,a,0,a,0,0,0
0,0,0,p,0,0,0,o,0,0,0,n,n,n,0,0
0,0,k,j,0,0,0,q,0,0,p,0,0,0,q,0
0,0,k,10,0,0,0,h,l,k,j,0,0,0,h,l
0,0,k,i,0,0,0,11,l,k,16,0,0,0,17,l
0,0,0,r,0,0,0,g,l,k,i,0,0,0,g,l
0,0,0,p,0,0,0,o,0,0,r,0,0,0,o,0
0,0,k,j,0,0,0,q,n,n,p,0,0,0,q,0
0,0,k,12,0,0,0,0,0,0,0,0,0,0,h,l
0,0,k,i,0,0,0,0,0,0,0,0,0,0,15,l
0,0,0,r,0,0,0,0,0,0,0,0,0,0,g,l
0,0,0,0,m,r,c,13,b,o,r,c,14,b,o,0
NAME a sec
ITM 2b 7,12
ITM 2b 4,5
ITM q 11,15
ITM r 12,15
ITM 18 13,15
ITM 19 13,14
ITM 18 14,14
ITM 15 14,12
ITM 19 14,13
ITM r 6,15
ITM 1a 8,15
ITM 1h 7,15
ITM 1f 8,14
ITM 14 9,14
ITM 1e 10,14
ITM 1b 10,12
ITM 1b 9,13
ITM 1c 11,6
ITM 16 12,6
ITM 1c 4,10
ITM 1c 6,5
ITM 1c 4,1
ITM 1c 6,2
ITM 1c 5,13
ITM 1b 6,0
ITM 1b 4,3
ITM 1b 6,4
ITM 1b 4,6
ITM 1b 6,8
ITM 1b 5,10
ITM 1b 4,14
ITM 2f 5,14
ITM 2l 4,9
ITM 2i 6,13
ITM 2i 12,12
ITM 2i 11,9
ITM 2i 12,7
ITM 2i 13,10
ITM 2h 4,7
ITM 2h 3,8
ITM 2h 3,12
ITM 2h 7,14
ITM 2h 11,13
ITM 2h 11,10
ITM 2h 13,8
ITM 2h 5,6
ITM 2h 6,7
ITM 2h 7,9
ITM 2h 5,12
ITM 2l 13,12
ITM 12 6,14
ITM 1e 4,4
ITM 1e 5,2
ITM 1e 5,8
ITM 1e 4,13
ITM 1e 12,9
ITM 2p 8,13
EXT 10,8 3 15,11 FX fade_b DLG s
EXT 5,0 1 5,15 FX slide_u DLG t
EXT 14,8 9 0,8 FX slide_r DLG 1b
EXT 7,8 c 0,8 FX slide_r DLG 4t
EXT 12,15 d 12,0 FX slide_d DLG 4v
EXT 14,13 2 7,15 DLG 2a
EXT 7,15 2 14,13 DLG 2b
EXT 3,7 2 3,12 DLG 2c
EXT 3,12 2 3,7 DLG 2d
EXT 7,3 2 11,2 DLG 2e
EXT 3,2 e 15,2 FX slide_l DLG 4r
PAL 0

ROOM 3
3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p
3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p
3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p
3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p
3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p,3p
3p,3p,3p,3p,3p,3p,3p,0,n,n,n,n,0,3p,3p,3p
3p,3p,3p,3p,3p,3p,3p,k,25,3q,0,0,l,3p,3p,3p
3p,3p,3p,3p,3p,3p,3p,k,27,28,0,0,l,3p,3p,3p
3p,3p,3p,3p,3p,3p,3p,k,0,0,0,0,q,n,n,0
3o,3o,3o,3o,3o,3o,3o,k,0,0,0,0,0,0,0,l
3o,3o,3o,3o,3o,3o,3o,k,0,0,0,0,0,0,0,q
3o,3o,3o,3o,3o,3o,3o,k,0,0,0,0,0,0,0,1e
3o,3o,3o,3o,3o,3o,3o,k,0,0,0,0,0,0,0,o
3o,3o,3o,3o,3o,3o,3o,k,0,0,0,0,0,0,0,l
3o,3o,3o,3o,3o,3o,3o,0,m,r,29,o,r,0,0,l
3o,3o,3o,3o,3o,3o,3o,3o,3o,0,m,0,0,m,m,0
NAME a13
ITM 2 13,14
ITM a 11,8
ITM l 11,9
ITM m 10,9
ITM q 8,13
ITM r 9,13
ITM s 8,12
ITM u 14,14
ITM z 14,13
ITM z 9,12
ITM 1e 10,13
ITM 1b 8,11
ITM u 10,12
ITM 1l 9,11
ITM 1s 11,6
ITM 2b 11,13
EXT 15,11 2 10,8 FX fade_b DLG r
PAL 0

ROOM 4
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME test_room1
ITM 1e 8,5
EXT 5,3 4 12,8 DLG 6o
EXT 12,8 4 5,3
PAL 0

ROOM 5
0,0,0,0,0,0,0,0,0,0,0,p,1e,q,0,0
0,0,n,n,n,n,n,n,n,n,p,2c,2c,2c,q,0
0,k,2e,2e,2e,2e,2e,2e,2e,2e,2e,2b,2b,2b,2c,l
0,k,2e,o,m,r,2e,o,m,m,r,2b,2e,2b,2c,l
0,k,2e,l,n,p,2e,q,n,0,k,2b,2b,2b,o,0
0,p,2e,2g,2l,2j,2l,2m,2j,l,k,2b,2b,2c,q,0
k,2e,2e,2g,2j,2j,2j,2j,2k,l,k,2b,2f,2c,29,l
k,2e,o,k,2j,2k,2l,2j,2j,l,k,2b,2b,2c,o,0
k,2e,l,k,2j,2j,3a,39,38,l,k,2b,2b,2b,q,0
k,2e,l,n,2i,2i,2i,2i,2i,n,k,2d,2d,2d,2d,l
k,2e,2h,2j,2l,2j,2j,2q,2r,2s,2g,2e,2e,2e,2e,l
k,2e,2e,2j,2j,2j,2j,2n,2o,2p,2g,2f,2e,2f,2e,l
0,m,r,2j,2t,2v,2x,34,2j,2j,2g,2e,2e,2e,2e,l
0,0,k,2l,2w,2y,2z,33,37,36,l,m,m,m,m,0
0,0,k,2j,2u,30,31,32,27,35,l,0,0,0,0,0
0,0,0,m,m,m,m,m,m,m,0,0,0,0,0,0
NAME a3
ITM n 10,2
ITM n 6,2
ITM n 4,2
ITM n 2,2
ITM n 1,7
ITM 5 8,5
ITM o 8,2
ITM o 3,2
ITM o 2,6
ITM p 9,2
ITM p 7,2
ITM p 2,5
ITM p 1,6
ITM q 1,11
ITM r 2,11
ITM s 1,10
ITM t 1,9
ITM t 2,4
ITM v 7,14
ITM w 8,8
ITM h 7,8
ITM g 3,14
ITM c 6,10
ITM n 6,7
ITM n 7,7
ITM n 8,6
ITM n 6,6
ITM n 5,6
ITM n 4,6
ITM n 6,4
ITM n 2,3
ITM n 11,3
ITM n 11,5
ITM n 11,6
ITM n 11,8
ITM n 13,7
ITM n 13,5
ITM n 13,4
ITM o 6,12
ITM o 5,12
ITM o 5,13
ITM o 6,13
ITM p 7,12
ITM p 6,11
ITM p 5,11
ITM p 4,11
ITM p 4,12
ITM p 4,13
ITM p 5,14
ITM r 3,13
ITM t 3,12
ITM t 7,13
ITM s 8,12
ITM r 9,12
ITM r 4,10
ITM r 6,5
ITM r 4,7
ITM s 6,3
ITM r 6,14
ITM r 4,14
ITM t 11,4
ITM t 11,7
ITM t 11,2
ITM u 11,1
ITM u 7,6
ITM u 5,7
ITM t 8,7
ITM 2b 5,2
ITM 2b 3,11
ITM 2b 6,8
ITM 2l 1,8
ITM 2l 13,11
EXT 12,0 1 12,15 FX slide_u DLG 11
PAL 0

ROOM 6
n,n,n,n,p,d,22,e,l,0,0,0,0,0,0,0
j,0,0,0,0,0,0,0,q,n,n,n,n,n,n,0
s,0,0,0,0,0,0,0,0,0,0,0,0,0,0,q
i,0,0,0,0,0,0,0,0,0,0,0,0,0,0,h
m,m,r,0,0,o,m,m,m,m,m,m,r,0,0,w
0,0,k,0,0,l,0,0,a,a,a,0,k,0,0,g
0,0,k,0,0,l,0,0,0,0,a,0,k,0,0,0
0,0,k,0,0,l,0,0,0,a,0,0,k,0,0,0
n,n,p,0,0,l,0,0,a,0,0,0,k,0,0,0
j,0,0,0,0,l,0,0,a,a,a,0,k,0,0,0
u,0,0,0,0,q,n,n,n,n,n,n,p,0,0,h
i,0,0,0,0,0,0,0,0,0,0,0,0,0,0,23
m,m,r,0,0,0,0,0,0,0,0,0,0,0,0,g
0,0,k,0,0,0,0,0,o,m,r,0,0,0,o,m
0,0,0,m,r,0,0,0,l,0,k,0,0,0,l,0
0,0,0,0,k,c,1e,b,l,0,k,c,v,b,l,0
NAME z main
ITM q 3,13
ITM r 4,13
ITM s 3,12
ITM 14 3,4
ITM 14 13,4
ITM 14 13,5
ITM 14 13,6
ITM 14 13,9
ITM 14 13,10
ITM 1a 4,8
ITM 1g 4,9
ITM 1g 4,6
ITM 1g 3,5
ITM 1i 3,1
ITM 1i 1,1
ITM 1i 11,2
ITM 1i 5,11
ITM 1i 7,11
ITM 1i 9,11
ITM 1i 12,11
ITM 1j 8,11
ITM 1j 11,11
ITM 1j 9,2
ITM 1j 8,2
ITM 1j 12,2
ITM 1d 7,2
ITM 1d 14,4
ITM 1d 14,7
ITM 1d 14,8
ITM 1d 14,10
ITM 1d 13,12
ITM 1o 8,12
ITM 1o 10,3
ITM 1o 6,3
ITM 1o 8,3
ITM 1o 12,3
ITM 1o 10,12
ITM 1o 1,3
ITM 1j 1,9
ITM 1i 2,9
ITM 1j 13,2
ITM 1j 10,11
ITM 1j 6,11
ITM 1j 2,1
ITM 1j 4,1
ITM 1p 15,7
ITM 1p 15,9
ITM 1q 15,6
ITM 1q 15,8
ITM 1q 4,4
ITM 1q 7,14
ITM 1b 10,2
ITM 17 7,1
ITM 17 7,0
ITM 14 5,0
ITM 18 13,15
ITM q 11,15
ITM s 11,14
ITM o 11,13
ITM 1a 13,14
ITM 1n 12,15
ITM 1o 12,14
ITM 1o 2,3
ITM 1r 5,3
ITM 1r 7,3
ITM 1r 9,3
ITM 1r 11,3
ITM 1r 9,12
ITM 1r 1,11
ITM 1r 2,11
ITM 1p 15,10
ITM 17 15,12
ITM 14 3,3
ITM 12 0,1
ITM r 0,3
ITM r 0,11
ITM 12 0,9
ITM 1d 3,8
ITM 1d 3,7
ITM 1d 4,7
ITM 1d 3,6
ITM 1d 4,5
ITM 1d 2,2
ITM 1d 1,2
ITM 1d 4,2
ITM 1d 5,1
ITM 1d 6,1
ITM 1d 14,3
ITM 1d 14,6
ITM 1d 14,11
ITM 1d 6,13
ITM 1d 5,14
ITM 1d 6,14
ITM 1d 13,3
ITM 1d 4,3
ITM 1d 6,2
ITM 1d 5,2
ITM 1p 3,10
ITM 1o 2,10
ITM 1c 1,10
ITM 1c 6,12
ITM 1c 13,11
ITM 1c 5,12
ITM 1c 14,5
ITM 1c 14,9
ITM 16 15,3
ITM 12 13,8
ITM r 13,7
ITM 2m 3,2
ITM 2m 14,12
ITM 1b 5,13
ITM 1b 7,13
ITM 1b 7,12
ITM 1b 4,12
ITM 1e 3,11
ITM 1e 3,9
ITM 1d 4,10
ITM 1c 4,11
ITM 1c 11,12
ITM 2m 12,12
ITM 1d 12,13
ITM 1d 13,13
EXT 6,15 1 6,0 FX slide_d DLG w
EXT 15,11 7 0,11 FX slide_r DLG x
EXT 6,0 6 9,7 DLG 3e
EXT 0,10 6 15,4 DLG 3f
EXT 15,4 6 0,10 DLG 3g
EXT 0,2 6 12,15 DLG 4l
EXT 12,15 6 0,2 DLG 4m
PAL 0

ROOM 7
0,0,0,p,d,10,e,l,0,0,0,0,0,0,0,0
0,0,k,j,0,0,0,q,0,0,a,a,a,0,0,0
0,0,k,z,0,0,0,h,l,0,0,0,a,0,0,0
0,0,k,i,0,0,0,11,l,0,0,a,0,0,0,0
0,0,0,r,0,0,0,g,l,0,a,0,0,0,0,0
0,0,0,p,0,0,0,o,0,0,a,a,a,0,0,0
0,0,k,j,0,0,0,q,0,0,n,n,n,n,n,0
0,0,k,y,0,0,0,h,l,k,j,0,0,0,h,l
0,0,k,i,0,0,0,12,l,k,16,0,0,0,17,l
n,n,p,0,0,0,0,g,l,k,i,0,0,0,g,l
j,0,0,0,0,0,o,m,0,0,r,0,0,0,o,0
23,0,0,0,0,0,l,0,0,0,k,0,0,0,q,0
i,0,0,0,0,0,q,n,n,n,p,0,0,0,h,l
m,m,m,r,0,0,0,0,0,0,0,0,0,0,15,l
0,0,0,k,0,0,0,0,0,0,0,0,0,0,g,l
0,0,0,0,m,r,c,13,b,o,r,c,14,b,o,0
NAME z sec
ITM 2m 10,7
ITM 2m 10,9
ITM 15 6,0
ITM 11 4,0
ITM 16 5,0
ITM 17 6,1
ITM 11 3,1
ITM z 11,8
ITM z 12,8
ITM z 12,11
ITM z 12,13
ITM z 8,14
ITM z 4,12
ITM z 5,8
ITM z 4,5
ITM z 6,3
ITM 18 13,15
ITM q 11,15
ITM r 12,15
ITM s 11,14
ITM 19 10,14
ITM 19 13,14
ITM z 14,14
ITM 14 11,12
ITM 14 11,10
ITM u 11,11
ITM o 9,13
ITM o 4,14
ITM 12 3,10
ITM 17 2,10
ITM r 3,9
ITM 17 5,10
ITM 19 5,9
ITM s 6,9
ITM 17 8,15
ITM r 9,14
ITM 14 6,15
ITM t 2,12
ITM 1d 0,12
ITM 1b 0,10
ITM 1e 1,11
ITM 2h 4,6
ITM 2h 5,3
ITM 2h 11,9
ITM 2h 11,7
ITM 2i 12,12
ITM 2i 13,11
ITM 2i 5,13
ITM 2i 6,14
ITM 2i 4,11
ITM 2i 6,6
ITM 2i 4,3
ITM 1p 6,5
ITM 12 3,2
ITM r 3,3
ITM 2v 4,1
EXT 0,11 6 15,11 FX slide_l DLG y
EXT 3,2 b 15,2 FX slide_l DLG 61
EXT 10,8 3 10,7 DLG 3h
EXT 5,0 7 7,8 DLG 3i
EXT 7,8 7 5,0 DLG 3j
EXT 3,7 7 7,15 DLG 3k
EXT 7,15 7 3,7 DLG 3l
EXT 12,15 7 14,8 DLG 5q
EXT 14,8 7 12,15 DLG 5r
EXT 7,3 h 0,3 FX slide_r DLG 5x
EXT 14,13 i 0,13 FX slide_r DLG 4o
PAL 0

ROOM 8
3l,3n,3l,3l,3l,3l,3m,3l,3l,3l,3l,3l,3l,3m,3l,3l
3l,3l,3l,0,n,n,n,n,0,0,n,n,n,n,n,n
3m,3l,3l,k,0,0,0,0,l,k,0,0,3m,0,0,23
3l,3l,3l,k,3i,3e,3h,0,q,p,0,0,3n,0,0,l
3l,3l,3l,k,3g,3c,3f,0,0,3b,0,0,3m,0,0,l
3l,3l,3l,k,3j,3d,3k,0,o,r,0,0,0,3l,0,l
3l,3l,3l,k,0,0,0,0,l,k,3l,0,3l,3m,3n,l
3l,3l,3l,0,m,m,m,m,0,k,0,0,3m,0,0,l
3l,3l,3l,3n,3l,3n,3n,3l,3l,0,m,m,m,m,m,0
3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l
3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l
3m,3l,3l,3n,3l,3l,3l,3l,3l,3l,3l,3l,3l,3m,3l,3l
3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l
3l,3l,3l,3l,3l,3m,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l
3l,3l,3l,3l,3l,3l,3l,3l,3l,3n,3l,3l,3l,3l,3l,3n
3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3n
NAME z6b
ITM z 9,4
ITM z 8,4
ITM q 4,6
ITM r 5,6
ITM s 4,5
ITM 11 4,2
ITM 12 4,3
ITM 13 5,2
ITM 14 4,4
ITM 15 7,2
ITM 16 6,2
ITM 17 7,3
ITM 18 7,6
ITM 19 6,6
ITM 1a 7,5
ITM 1b 7,4
ITM 1c 6,3
ITM 18 14,7
ITM 11 10,2
ITM q 10,7
ITM r 11,7
ITM s 10,6
ITM u 10,5
ITM 12 10,3
ITM 13 11,2
ITM 19 13,7
ITM 1a 14,6
ITM 1d 6,5
ITM 1e 6,4
ITM 1e 11,3
ITM 1e 12,3
ITM 1e 13,3
ITM 1e 13,5
ITM 1e 13,6
ITM 1e 11,5
ITM 1e 11,4
ITM 1e 14,3
ITM 1b 14,2
ITM 1b 12,5
ITM 1d 12,6
ITM 1c 11,6
ITM 1c 13,4
ITM 1f 14,5
ITM 1g 14,4
ITM 1h 12,7
ITM 1i 12,2
ITM 1j 13,2
ITM 1e 12,4
EXT 9,4 b 10,4 FX tunnel DLG 10
PAL 0

ROOM 9
2b,2b,3r,2b,2b,2b,2b,2b,2b,2b,2b,2b,2b,2b,2b,2b
2b,2b,2b,2b,2b,2b,2b,2b,2b,2b,3r,2b,2b,2b,2b,2b
0,n,n,n,n,n,n,0,2b,2b,2b,2b,2b,2b,2b,2b
k,0,0,0,0,0,0,l,2b,2b,2b,2b,2b,2b,2b,3r
k,0,0,0,0,0,0,l,2b,2b,2b,3r,2b,2b,2b,2b
k,0,0,0,0,0,0,l,2b,2b,2b,2b,2b,2b,2b,2b
k,0,0,0,0,0,0,l,2b,2b,2b,2b,2b,2b,2b,2b
p,3s,3t,3u,0,0,0,q,0,2b,2b,2b,2b,3r,2b,2b
1e,0,0,0,0,0,0,29,l,2b,2b,2b,2b,2b,2b,2b
r,41,3z,40,0,0,0,o,0,2b,3r,2b,2b,2b,2b,2b
k,0,0,0,0,0,0,l,2b,2b,2b,2b,2b,2b,2b,2b
k,3v,3x,0,0,0,0,l,2b,2b,2b,2b,2b,3r,2b,2b
k,3w,3y,0,0,0,0,l,2b,3r,2b,2b,2b,2b,2b,2b
0,m,m,m,m,m,m,0,2b,2b,2b,2b,2b,2b,2b,2b
2b,2b,2b,2b,2b,2b,2b,2b,2b,2b,2b,2b,3r,2b,2b,2b
2b,2b,3r,2b,2b,2b,2b,2b,2b,2b,2b,2b,2b,2b,2b,2b
NAME a14
ITM 1k 6,3
ITM 1d 2,8
ITM 1d 3,8
ITM 1d 4,8
ITM 1d 4,9
ITM 1d 4,10
ITM 1d 4,11
ITM 1d 4,12
ITM 1d 5,10
ITM 1d 5,11
ITM 1d 5,9
ITM 1d 6,8
ITM 1d 4,7
ITM 1d 4,6
ITM 1d 5,6
ITM 1d 6,6
ITM 1d 5,5
ITM 1d 5,4
ITM 1d 4,4
ITM 1d 3,4
ITM 1d 2,4
ITM 1d 2,6
ITM 1d 3,6
ITM 19 5,12
ITM 1a 6,11
ITM 1e 3,11
ITM 1e 5,7
ITM 1e 6,9
ITM 28 1,8
ITM 29 6,12
ITM z 5,8
ITM z 3,12
ITM z 1,4
ITM z 1,6
ITM 10 1,5
ITM 1f 6,7
ITM 1g 6,10
ITM 1c 3,9
ITM 1b 1,9
EXT 0,8 2 14,8 FX slide_l DLG 1c
PAL 0

ROOM b
3l,3n,3l,3l,3l,3l,3m,3l,3l,3l,3l,3l,3l,3m,3l,3l
3l,3l,3l,3l,3l,3l,3l,3l,3l,0,n,n,n,n,n,n
3m,3l,3l,3l,3l,3l,3l,3l,3l,k,0,0,0,0,0,23
3l,3l,3l,3l,3l,3l,3l,3l,3l,k,0,0,0,0,0,o
3l,3l,3l,3l,3l,3l,3l,3l,3l,k,0,0,0,0,0,l
3l,3l,3l,3l,3l,3l,3l,3l,3l,k,0,0,0,0,0,l
3l,3l,3l,3l,3l,3l,3l,3l,3l,k,0,0,0,0,0,l
3l,3l,3l,3l,3l,3l,3l,3l,3l,k,0,0,0,0,0,l
3l,3l,3l,3n,3l,3n,3n,3l,3l,0,m,m,m,m,m,0
3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l
3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l
3m,3l,3l,3n,3l,3l,3l,3l,3l,3l,3l,3l,3l,3m,3l,3l
3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l
3l,3l,3l,3l,3l,3m,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l
3l,3l,3l,3l,3l,3l,3l,3l,3l,3n,3l,3l,3l,3l,3l,3n
3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3l,3n
NAME z6a
ITM q 10,7
ITM r 11,7
ITM s 10,6
ITM 11 10,2
ITM 12 10,3
ITM 13 11,2
ITM 18 14,7
ITM 1a 14,6
ITM 1q 14,5
ITM 1p 14,4
ITM 1e 14,3
ITM 1e 12,2
ITM 1e 10,5
ITM 1e 11,5
ITM 1e 12,6
ITM 1e 12,7
ITM 1e 13,6
ITM 1e 13,5
ITM 1e 12,5
ITM 1e 12,3
ITM 1e 11,3
ITM 21 11,6
ITM 2t 13,7
EXT 10,4 8 9,4 FX tunnel DLG z
EXT 15,2 7 3,2 FX slide_r DLG 60
PAL 0

ROOM c
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,n,n,n,n,n,n,0,0,n,n,n,n,n,n,0
k,0,0,0,0,0,0,l,k,25,42,0,46,47,48,l
k,0,0,0,0,0,0,l,k,27,35,0,44,43,45,l
k,0,0,0,0,0,0,l,k,0,0,0,0,0,0,l
p,0,0,0,3s,3u,0,l,k,0,49,4f,4g,4a,0,l
1e,0,0,0,0,0,0,l,k,0,4e,2y,2z,4j,0,l
r,0,0,0,0,0,0,l,k,0,4c,4h,4i,4b,0,l
k,0,0,0,0,0,0,l,k,0,0,0,0,0,0,l
p,0,0,0,0,0,0,l,0,m,m,r,0,o,m,0
0,0,0,0,0,0,0,q,n,n,n,p,0,q,n,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,l
r,0,0,0,0,0,0,0,0,0,0,0,0,0,0,l
0,m,r,29,o,m,m,m,m,m,m,m,m,m,m,0
NAME a8
ITM 1t 1,10
ITM 1u 1,9
ITM 1u 1,11
ITM 1u 0,12
ITM 1u 0,13
ITM 1v 1,12
ITM 6 9,13
ITM 4 10,4
ITM 1b 1,7
ITM 1b 1,8
ITM 1b 2,7
ITM 1b 2,8
ITM 1b 2,10
ITM 1b 2,12
ITM 1b 2,13
ITM 1b 2,14
ITM 1b 3,14
ITM 1b 3,13
ITM 1b 3,11
ITM 1b 3,10
ITM 1b 3,9
ITM 1b 3,8
ITM 1b 3,7
ITM 1b 4,8
ITM 1b 5,8
ITM 1b 6,7
ITM 1b 5,5
ITM 1b 2,5
ITM 1b 4,11
ITM 1b 5,11
ITM 1b 5,12
ITM 1b 4,12
ITM 1b 6,12
ITM 1b 5,13
ITM 1b 4,14
ITM 1b 6,14
ITM 1b 7,14
ITM 1b 7,13
ITM 1b 8,13
ITM 1b 10,14
ITM 1b 10,13
ITM 1b 11,13
ITM 1b 12,14
ITM 1b 13,13
ITM 1b 13,14
ITM 1b 12,12
ITM 1b 12,11
ITM 1b 13,10
ITM 1b 11,10
ITM 1b 10,10
ITM 1b 9,9
ITM 1b 9,7
ITM 1b 11,6
ITM 1b 11,5
ITM 1b 12,6
ITM 1c 3,12
ITM 1c 4,5
ITM 1c 9,8
ITM 1c 14,7
ITM 1c 1,13
ITM 1d 2,9
ITM 1d 4,13
ITM 1d 8,14
ITM 1d 6,6
ITM 1d 12,13
ITM 1c 11,14
ITM 1h 5,14
ITM 1g 14,13
ITM 1f 14,14
ITM 1j 1,5
ITM 1j 6,5
ITM 1p 14,6
ITM 1q 14,8
ITM 2a 12,10
ITM 1p 6,8
ITM 1o 6,9
ITM 1d 4,9
ITM 1e 2,11
ITM 1e 6,13
ITM 1e 3,5
ITM 1e 9,14
ITM 2b 13,6
ITM 14 1,6
ITM 2c 1,14
ITM 2w 14,4
EXT 0,8 2 7,8 FX slide_l DLG 4u
PAL 0

ROOM d
0,0,0,0,0,0,0,0,n,n,n,p,1e,q,n,0
0,0,0,0,0,0,0,k,0,0,0,0,0,0,0,l
0,0,0,0,0,0,0,k,0,0,0,0,0,0,0,q
0,0,0,0,0,0,0,k,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,k,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,k,0,0,0,0,0,0,0,o
0,0,0,0,0,0,0,k,0,0,0,0,0,0,0,l
0,0,0,0,0,0,0,k,0,0,0,0,0,0,0,l
0,0,0,0,0,0,0,k,0,0,0,0,0,0,0,q
0,0,0,0,0,0,0,k,0,0,0,0,0,0,0,29
0,0,0,0,0,0,0,k,0,0,0,0,0,0,0,o
0,0,0,0,0,0,0,k,0,0,0,0,0,0,0,l
0,0,0,0,0,0,0,k,0,0,0,0,0,0,0,l
0,0,0,0,0,0,0,k,0,0,0,0,0,0,0,l
0,0,0,0,0,0,0,0,m,m,m,m,m,m,m,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME a11
ITM 1w 13,9
ITM 1w 10,11
ITM 1y 13,2
ITM 1y 9,11
ITM 1z 11,1
ITM 1z 12,13
ITM 20 12,7
ITM 20 15,4
ITM 1t 13,1
ITM 1t 11,2
ITM 1t 9,1
ITM 1t 8,2
ITM 1t 8,4
ITM 1t 13,6
ITM 1t 11,10
ITM 1t 9,10
ITM 1t 8,12
ITM 1t 13,12
ITM 1t 14,13
ITM 1t 14,8
ITM 1t 8,6
ITM 1t 8,7
ITM 1t 13,4
ITM 1t 15,3
ITM 1u 8,3
ITM 1u 10,2
ITM 1u 11,3
ITM 1u 12,6
ITM 1u 13,7
ITM 1u 14,9
ITM 1u 14,12
ITM 1u 13,13
ITM 1u 11,11
ITM 1u 11,6
ITM 1u 12,3
ITM 1u 12,2
ITM 1u 10,1
ITM 1d 8,1
ITM 1d 9,2
ITM 1d 12,1
ITM 1d 14,1
ITM 1d 14,2
ITM 1d 14,3
ITM 1d 13,3
ITM 1d 14,4
ITM 1d 12,4
ITM 1d 14,5
ITM 1d 14,6
ITM 1e 13,8
ITM 1e 12,8
ITM 1e 11,7
ITM 1e 9,5
ITM 1e 10,4
ITM 1e 10,3
ITM 1e 8,5
ITM 1e 9,6
ITM 1e 10,6
ITM 1e 9,7
ITM 1e 10,7
ITM 1c 9,8
ITM 1c 8,9
ITM 1c 9,9
ITM 1c 10,9
ITM 1c 11,9
ITM 1c 12,9
ITM 1c 12,10
ITM 1c 13,10
ITM 1c 14,10
ITM 1c 14,11
ITM 1c 13,11
ITM 1c 12,11
ITM 1c 12,12
ITM 1c 11,12
ITM 1c 10,12
ITM 1b 8,11
ITM 1b 9,12
ITM 10 9,4
ITM y 11,5
ITM o 11,8
ITM n 10,10
ITM 22 13,5
ITM 1v 8,10
ITM 1v 11,4
ITM 23 8,8
ITM 2e 14,7
ITM 2u 10,5
EXT 12,0 2 12,15 FX slide_u DLG 4w
PAL 0

ROOM e
0,0,0,0,0,0,0,0,0,0,0,0,n,0,0,0
0,0,0,0,0,0,0,0,0,n,n,p,29,q,n,n
0,0,0,0,0,0,0,0,k,4q,3t,3u,0,0,0,1e
0,0,0,0,0,0,0,0,k,0,0,0,0,0,0,o
0,0,0,0,0,0,0,0,k,41,3z,40,0,0,0,q
0,0,0,0,0,0,0,0,k,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,k,0,49,4f,4g,4a,0,0
0,0,0,0,0,0,0,0,k,0,4e,2y,2z,4j,0,o
0,0,0,0,0,0,0,0,p,0,4c,4h,4i,4b,0,l
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,l
0,0,0,0,0,0,0,0,r,0,0,0,0,0,0,l
0,0,0,0,0,0,0,0,0,m,m,m,m,m,m,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME a5
ITM x 9,6
ITM 2f 15,5
ITM 19 15,6
ITM k 9,2
ITM 2w 9,10
ITM 2y 14,2
ITM 2z 8,9
EXT 7,9 e 6,9 DLG 2f
EXT 15,2 2 3,2 FX slide_r DLG 4s
PAL 0

ROOM f
2e,2e,2e,2e,2e,2e,2e,2e,2e,2e,2e,2e,2e,2e,2e,2e
2e,0,n,n,n,n,n,n,n,n,0,2e,2e,2e,2e,2e
2e,k,0,0,0,0,0,0,0,0,l,2e,2e,2e,2e,2e
2e,k,2b,2b,2b,2b,2b,2b,2b,2b,l,2e,2e,2e,2e,2e
2e,k,2b,2b,2b,2b,2b,2b,2b,2b,l,2e,2e,2e,2e,2e
2e,k,2b,0,0,0,0,0,0,0,l,2e,2e,2e,2e,2e
2e,k,0,0,0,0,0,0,0,0,l,2e,2e,2e,2e,2e
2e,k,0,4l,0,4l,0,0,0,0,l,2e,0,0,0,2e
2e,k,0,0,0,0,0,0,2b,2b,q,n,p,0,q,0
2e,k,0,4l,0,4l,0,2c,2b,2c,2b,2c,2b,2c,2b,q
2e,k,0,0,0,0,0,2c,2b,2c,2b,2c,2b,2c,2b,1e
2e,k,0,4l,0,4l,0,2c,2b,2c,2b,2c,2b,2c,2b,o
2e,k,0,0,0,0,0,0,2b,2b,o,m,r,0,o,0
2e,k,0,4l,0,4l,0,4l,0,4l,l,2e,0,0,0,2e
2e,k,0,0,0,0,0,0,0,0,l,2e,2e,2e,2e,2e
2e,0,m,m,m,m,m,m,m,m,0,2e,2e,2e,2e,2e
NAME a2
EXT 13,8 f 13,12 DLG 3m
EXT 13,12 f 13,8 DLG 3n
EXT 15,10 1 0,10 FX slide_r DLG 4q
PAL 0

ROOM h
0,n,n,n,n,n,0,0,0,0,0,0,0,0,0,0
k,0,0,0,0,0,l,0,0,0,0,0,0,0,0,0
p,0,0,0,4m,4n,l,0,0,0,0,0,0,0,0,0
23,0,0,0,4o,4p,l,0,0,0,0,0,0,0,0,0
r,0,0,0,0,0,l,0,0,0,0,0,0,0,0,0
k,0,0,0,0,0,l,0,0,0,0,0,0,0,0,0
0,m,m,m,m,m,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME z8
ITM 24 2,3
ITM 1t 2,5
ITM 1t 3,1
ITM 1t 1,1
ITM r 3,5
ITM s 1,4
ITM t 2,4
ITM 25 2,1
ITM 27 4,4
ITM 14 1,2
ITM z 3,4
ITM 17 5,2
ITM 1c 4,2
ITM 1d 4,3
ITM 1a 5,4
ITM u 2,2
ITM t 3,3
ITM z 3,2
ITM z 1,3
ITM 2g 5,3
ITM 23 1,5
ITM 20 4,5
ITM 2n 4,1
ITM 2o 5,1
ITM 2s 5,5
EXT 0,3 7 7,3 DLG 5y
PAL 0

ROOM i
2b,2b,2b,2b,2b,3r,2b,2b,2b,2b,2b,2b,2b,2b,2b,2b
2b,2b,2b,2b,2b,2b,2b,2b,2b,2c,2b,2b,2b,2b,3r,2b
0,n,n,n,n,n,n,0,2b,2b,2b,2b,2b,2b,2b,2b
k,0,0,0,0,0,0,l,2b,2b,2b,2b,2b,2b,2b,2c
k,0,0,0,0,0,0,l,2b,2b,2b,2c,2b,2b,2b,2b
k,0,0,0,0,0,0,l,2b,2b,2b,2b,2b,2b,2b,2b
k,0,0,0,0,0,0,l,2b,2b,2b,2b,2b,2b,2b,2b
k,3s,3t,3u,0,0,0,q,0,2b,2b,2b,2b,2b,2b,2b
k,0,0,0,0,0,0,29,l,2b,2b,2b,2b,2b,2b,2b
k,0,0,0,0,0,0,o,0,2b,2b,2c,2b,2b,2b,2b
k,0,0,0,0,0,0,q,2b,2b,2b,2b,2b,2b,2b,2c
k,0,0,0,0,0,0,0,2b,3r,2b,2b,2b,2b,2b,2b
p,0,0,0,0,0,0,o,2b,2b,2b,2b,2b,2b,2b,2b
23,0,0,0,0,0,0,l,2b,2b,2b,2b,2c,2b,2b,2b
m,m,m,m,m,m,m,0,2b,2b,2b,2b,2b,2b,2b,2b
2b,2c,2b,2b,2b,2b,2b,2b,2c,2b,2b,2b,2b,2b,3r,2b
NAME z12
ITM 1a 6,12
ITM 19 5,13
ITM 18 6,13
ITM 11 1,4
ITM 12 1,5
ITM 13 2,4
ITM 15 6,4
ITM 16 5,4
ITM 17 6,5
ITM 1j 4,4
ITM 1i 3,4
ITM 11 1,12
ITM 13 2,12
ITM 1d 3,12
ITM 1e 2,13
ITM 1c 3,13
ITM 1h 4,13
ITM 1b 2,5
ITM 1b 5,5
ITM 1d 3,5
ITM 1d 4,6
ITM 1i 1,8
ITM 1j 3,8
ITM 1d 2,8
ITM 1b 5,6
ITM 2h 1,6
ITM 2h 4,8
ITM 2h 5,10
ITM 2h 1,10
ITM 2h 4,12
ITM 2h 4,10
ITM 2h 6,9
ITM 2h 5,8
ITM 2i 5,7
ITM 2i 2,6
ITM 2i 1,9
ITM 2i 3,9
ITM 2i 6,11
ITM 1b 5,11
ITM u 6,8
ITM 2j 1,13
ITM 2m 4,5
EXT 7,11 i 14,1 DLG 4n
EXT 0,13 7 14,13 FX slide_l
PAL 0

TIL 10
11111111
11000011
11011011
11110111
11110111
11101111
11101111
11111111
NAME 7

TIL 11
11111111
11000011
11011011
11000011
11011011
11011011
11000011
11111111
NAME 8

TIL 12
11111111
11000011
11011011
11011011
11000011
11111011
11111011
11111111
NAME 9

TIL 13
11111111
11111111
11010001
11010101
11010101
11010001
11111111
11111111
NAME 10

TIL 14
11111111
11111111
11011011
11011011
11011011
11011011
11111111
11111111
NAME 11

TIL 15
11111111
11111111
11010011
11011101
11011011
11010001
11111111
11111111
NAME 12

TIL 16
11111111
11111111
11010011
11011101
11011011
11011101
11110011
11111111
NAME 13

TIL 17
11111111
11111111
11010101
11010001
11011101
11011101
11111111
11111111
NAME 14

TIL 18
11111111
11111111
11010001
11010111
11011011
11011101
11110011
11111111
NAME 15

TIL 19
11111111
11110001
11010111
11010001
11010101
11010001
11111111
11111111
NAME 16

TIL 20
11111111
10111101
10111101
10100101
10100101
11011011
11011011
11111111
NAME W

TIL 21
11111111
11011011
11011011
11100111
11100111
11011011
11011011
11111111
NAME X

TIL 22
11111111
10111011
11010111
11101111
11101111
11101111
11101111
11111111
NAME Y

TIL 23
11111111
11000011
11111011
11110111
11101111
11011111
11000011
11111111
NAME Z

TIL 24
00000000
01100110
01011010
01000010
01011010
01100110
00000000
00000000
NAME bedroom_pillow

TIL 25
00000000
00000000
00111111
01000000
01111111
01000000
01000000
01000000
NAME bedroom_sheet_tl

TIL 26
00000000
00000000
11111100
00000010
11111110
00000010
00000010
00000010
>
00000000
00000000
11100000
00010000
11001000
00110100
00000100
00000100
NAME bedroom_sheet_tr_opening

TIL 27
01000000
01000000
01000000
01000000
01000000
00111111
00000000
00000000
NAME bedroom_sheet_bl

TIL 28
00000010
00000010
00000010
00000010
00000010
11111100
00000000
00000000
>
00000110
00000010
00000010
00000010
00000010
11111100
00000000
00000000
NAME bedroom_sheet_br_opening

TIL 29
11111111
11111111
11110011
11110011
11110011
11000011
11100011
11111111
NAME toilet

TIL 30
01010101
01000101
00111000
00000001
01100011
11111111
11100000
00000000
NAME rug bml wood floor

TIL 31
10101010
10100010
00011100
11000000
11100011
11111111
01111000
00000000
NAME rug bmr wood floor

TIL 32
11101100
01000100
00011111
01010100
01010100
11111000
11100011
00000000
NAME rug br wood floor

TIL 33
11101101
11000100
00000100
11001100
11001110
00000100
11000111
11101100
NAME rug rm wood floor

TIL 34
11100001
00000000
11111011
01010100
01010100
00011100
01000101
11101100
NAME rug tr wood floor

TIL 35
00000010
00000010
00000010
00000010
00000010
11111100
00000000
00000000
NAME bed br

TIL 36
11100001
00000000
11111100
00000010
11111110
00000010
00000010
00000010
NAME bed tr wood floor

TIL 37
11100001
00000000
00111111
01000000
01111111
01000000
11000000
01000000
NAME bed tl wood floor

TIL 38
11001110
00000000
11100101
00001010
11111010
00001010
00010010
11111110
NAME couch r wood floor

TIL 39
01111001
00000000
00111100
00000000
11111111
00000000
00000000
11111111
NAME couch m wood floor

TIL 40
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
10000000
10000000
10000000
10000000
10000000
10000000

TIL 41
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000001
00000001
00000001
00000001
00000001
00000001

TIL 42
00000000
00000000
11111100
00000010
11111110
00000010
00000010
00000010
NAME bed tr

TIL 43
11111111
10000011
10000010
11111111
11111111
00000000
00000000
00000000
NAME keyboard mouse

TIL 44
00011111
00011111
00011111
00011111
00001111
00000000
00000000
00000000
NAME desk bl

TIL 45
11111000
11111000
11111000
11111000
11110000
00000000
00000000
00000000
NAME desk br

TIL 46
00000000
00000000
00000000
00001111
00011111
00011111
00011111
00011111
NAME desk smol tl

TIL 47
00000000
00000000
00000000
10000001
10000001
10000001
11111111
11111111
NAME desk smol tm

TIL 48
00000000
00000000
00000000
11110000
11111000
11111000
11111000
11111000

TIL 49
00000000
00000000
00011111
00101010
00101010
00111000
00100010
00110111
NAME rug tl

TIL a
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME block

TIL b
00000000
11100000
11111000
11111100
11111110
11111100
11111000
11110000
NAME BotDoorR
WAL false

TIL c
00000000
00000111
00011111
00111111
01111111
00111111
00011111
00001111
NAME BotDoorL

TIL d
00001111
00011111
00111111
01111111
00111111
00011111
00000111
00000000
NAME TopDoorL

TIL e
11110000
11111000
11111100
11111110
11111100
11111000
11100000
00000000
NAME TopDoorR

TIL f
11111111
11100111
11101011
11101011
11101011
11100111
11111111
11111111
NAME Door

TIL g
01111111
01111111
01111111
00111111
00111110
00011100
00001000
00000000
NAME RDoorBot

TIL h
00000000
00001000
00011100
00111110
00111111
01111111
01111111
01111111
NAME RDoorTop

TIL i
11111110
11111110
11111110
11111100
01111100
00111000
00010000
00000000
NAME LDoorBot

TIL j
00000000
00010000
00111000
01111100
11111100
11111110
11111110
11111110
NAME LDoorTop

TIL k
00000001
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME wall l
WAL true

TIL l
10000000
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME wall r
WAL true

TIL m
11111111
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME wall b
WAL true

TIL n
00000000
00000000
00000000
00000000
00000000
00000000
00000000
11111111
NAME wall t
WAL true

TIL o
11111111
10000000
10000000
10000000
10000000
10000000
10000000
10000000
NAME wall rb corn
WAL true

TIL p
00000001
00000001
00000001
00000001
00000001
00000001
00000001
11111111
NAME wall lt corn
WAL true

TIL q
10000000
10000000
10000000
10000000
10000000
10000000
10000000
11111111
NAME wall rt corn
WAL true

TIL r
11111111
00000001
00000001
00000001
00000001
00000001
00000001
00000001
NAME wall lb corn
WAL true

TIL s
11111111
11100111
11000111
11100111
11100111
11100111
11000011
11111111
NAME 1

TIL u
11111111
11100111
11011011
11110111
11101111
11011111
11000011
11111111
NAME 2

TIL v
11111111
11100111
11011011
11110111
11111011
11011011
11100111
11111111
NAME 3

TIL w
11111111
11110011
11101011
11011011
11000011
11111011
11111011
11111111
NAME 4

TIL y
11111111
11000011
11011111
11011111
11100111
11111011
11000111
11111111
NAME 5

TIL z
11111111
11100111
11011011
11011111
11000111
11011011
11100111
11111111
NAME 6

TIL 1a
11111111
11111111
11010001
11011101
11011011
11011011
11111111
11111111
NAME 17

TIL 1b
11111111
11111111
11010001
11010101
11010001
11010101
11110001
11111111
NAME 18

TIL 1c
11111111
11110001
11010101
11010001
11011101
11011101
11111111
11111111
NAME 19

TIL 1d
11111111
11111111
10010001
11100101
11010101
10110101
10000001
11111111
NAME 20

TIL 1e
11111111
11100111
11011011
11011011
11000011
11011011
11011011
11111111
NAME A

TIL 1f
11111111
11000111
11011011
11000011
11011011
11011011
11000111
11111111
NAME B

TIL 1g
11111111
11000011
11011011
11011111
11011111
11011111
11000011
11111111
NAME C

TIL 1h
11111111
11000111
11011011
11011011
11011011
11011011
11000111
11111111
NAME D

TIL 1i
11111111
11000011
11011111
11000111
11011111
11011111
11000011
11111111
NAME E

TIL 1j
11111111
11000011
11011111
11000111
11011111
11011111
11011111
11111111
NAME F

TIL 1k
11111111
11000011
11011111
11011111
11010011
11011011
11000011
11111111
NAME G

TIL 1l
11111111
11011011
11011011
11011011
11000011
11011011
11011011
11111111
NAME H

TIL 1m
11111111
11000111
11101111
11101111
11101111
11101111
11000111
11111111
NAME I

TIL 1n
11111111
11100011
11110111
11110111
11110111
11010111
11101111
11111111
NAME J

TIL 1o
11111111
11011011
11010111
11001111
11010111
11011011
11011011
11111111
NAME K

TIL 1p
11111111
11011111
11011111
11011111
11011111
11011111
11000011
11111111
NAME L

TIL 1q
11111111
11011101
11001001
11010101
11011101
11011101
11011101
11111111
NAME M

TIL 1r
11111111
11000111
11011011
11011011
11011011
11011011
11011011
11111111
NAME N

TIL 1s
11111111
11000011
11011011
11011011
11011011
11011011
11000011
11111111
NAME O

TIL 1t
11111111
11000011
11011011
11000011
11011111
11011111
11011111
11111111
NAME P

TIL 1u
11111111
11000011
11011011
11011011
11011011
11000011
11111001
11111111
NAME Q

TIL 1v
11111111
11000011
11011011
11011011
11000111
11011011
11011011
11111111
NAME R

TIL 1w
11111111
11100011
11011011
11101111
11110111
11011011
11000111
11111111
NAME S

TIL 1x
11111111
11000001
11110111
11110111
11110111
11110111
11110111
11111111
NAME T

TIL 1y
11111111
11011011
11011011
11011011
11011011
11011011
11000011
11111111
NAME U

TIL 1z
11111111
11011011
11011011
11011011
11011011
11100111
11100111
11111111
NAME V

TIL 2a
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 2b
11001100
11001100
00110011
00110011
11001100
11001100
00110011
00110011
NAME checker 1

TIL 2c
00110011
00110011
11001100
11001100
00110011
00110011
11001100
11001100
NAME checker 2

TIL 2d
01100110
01100110
10011001
10011001
01100110
01100110
10011001
10011001
NAME checker 3

TIL 2e
01100110
10011001
10011001
01100110
01100110
10011001
10011001
01100110
NAME checker 4

TIL 2f
11001100
00110011
00110011
11001100
11001100
00110011
00110011
11001100
NAME checker 5

TIL 2g
10000001
10000001
10000001
10000001
10000001
10000001
10000001
10000001
NAME wall Left Right
WAL true

TIL 2h
10000001
10000001
10000001
10000001
10000001
10000001
10000001
11111111
NAME wall LBR
WAL true

TIL 2i
11111111
00000000
00000000
00000000
00000000
00000000
00000000
11111111
NAME wall Top Bottom
WAL true

TIL 2j
11100001
00000000
00001111
00000000
01111000
00000000
11000011
00000000
NAME wood floor 1

TIL 2k
11000011
00000000
10000111
00000000
00111100
00000000
11100001
00000000
NAME wood floor 2

TIL 2l
00111100
00000000
11000011
00000000
01111000
00000000
00011110
00000000
NAME wood floor 3

TIL 2m
00000000
00000000
00000000
00111100
00111100
00110000
00000000
00000000
>
00000000
00000000
00000000
00101100
00101100
00111100
00000000
00000000
NAME behind tv

TIL 2n
01111111
01111111
01111111
01111111
01111111
00000000
11100001
00000000
NAME desk l wood floor

TIL 2o
11111111
10000011
10000010
11111111
11111111
00000000
11000111
00000000
NAME desk keyboard wood floor

TIL 2p
11111110
11111110
11111110
11111110
11111110
00000000
10001111
00000000
NAME desk r wood floor

TIL 2q
11000011
00000000
00000000
00000001
00000001
00000001
01111111
01111111
>
11000011
00000000
00000000
00000001
00000001
00000001
01111111
01111111
NAME behind monitor l

TIL 2r
00111100
00000000
00000000
10000001
10000001
10000001
11111111
11111111
NAME behind monitor m

TIL 2s
00000000
00000000
00000000
10000000
10000000
10000000
11111111
11111111
>
00000000
00000000
00000000
10000000
10000000
10000000
11111111
11111111
NAME behind monitor r

TIL 2t
11100001
00000000
00011111
00101010
11101010
00111000
00100010
00110111
NAME rug tl wood floor

TIL 2u
10110111
00100010
00111000
00101010
00101010
00011111
10000011
00000000
NAME rug bl wood floor

TIL 2v
11000111
00000000
11111111
11000111
00000011
00111000
01000101
01010101
NAME rug tml wood floor

TIL 2w
00110111
00100110
10100000
00110110
00110110
00100000
00100110
00110111
NAME rug lm wood floor

TIL 2x
10000001
00000000
11111111
11000110
10000000
00011100
10100010
10101010
NAME rug tmr wood floor

TIL 2y
01000100
00111000
00000011
01101010
01100000
00000111
00111000
01000100
NAME rug ml

TIL 2z
00100010
00011100
11100000
00000110
01010110
11000000
00011100
00100010
NAME rug mr

TIL 3a
10011100
00000000
00100110
01010000
01011111
01010000
11001000
01111111
NAME bed l wood floor

TIL 3b
00000001
00000001
00000001
00000001
00000000
00000001
00000001
00000001
NAME wall l false
WAL false

TIL 3c
11000011
10000001
00000000
00000000
00000000
00000000
10000001
11000011
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME drop off hole

TIL 3d
11111111
01111110
00011000
00000000
00000000
00000000
00000000
00000000
>
00000000
10000001
11111111
01111110
00011000
00000000
00000000
00000000
NAME drop off hole b

TIL 3e
00000000
00000000
00000000
00000000
00000000
00011000
01111110
11111111
>
00000000
00000000
00000000
00011000
01111110
11111111
10000001
00000000
NAME drop off hole t

TIL 3f
10000000
11000000
11000000
11100000
11100000
11000000
11000000
10000000
>
01100000
00110000
00110000
00111000
00111000
00110000
00110000
01100000
NAME drop off r

TIL 3g
00000001
00000011
00000011
00000111
00000111
00000011
00000011
00000001
>
00000110
00001100
00001100
00011100
00011100
00001100
00001100
00000110
NAME drop off l

TIL 3h
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
10000000
11000000
01100000
NAME drop off ur

TIL 3i
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000001
00000011
00000110
NAME drop off ul

TIL 3j
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000110
00000011
00000001
00000000
00000000
00000000
00000000
00000000
NAME drop off bl

TIL 3k
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
01100000
11000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME drop off br

TIL 3l
00000000
10011011
10111011
00111000
00000011
01110111
01110111
00000000
NAME tile floor 1

TIL 3m
00001100
11101101
11100001
01100000
00000111
01100111
01100001
00001100
NAME tile floor 2

TIL 3n
00000000
10110001
10111101
00001100
01100001
01101111
01101111
00000000
NAME tile floor 3

TIL 3o
00000000
01110111
01110111
01110111
00000000
01110111
01110111
01110111
NAME tile floor 4

TIL 3p
11000000
11001111
00001111
01101111
01101111
00000000
11011110
11011110
NAME tile floor 5

TIL 3q
00000000
00000000
11111100
00000010
00000010
00000010
00000010
00000010
NAME bed under ur sprite

TIL 3r
11001100
11001100
00110011
00110011
11001100
11001100
00110011
00110011
>
00110011
00110011
11001100
11001100
00110011
00110011
11001100
11001100
NAME checker 6 anim

TIL 3s
00000000
00000011
00000100
00101000
01010000
01011111
01010000
01111111
NAME couch front l
WAL true

TIL 3t
00111100
11000011
00000000
00000000
00000000
11111111
01000010
11111111
NAME couch front m
WAL true

TIL 3u
00000000
11000000
00100000
00010100
00001010
11111010
00001010
11111110
NAME couch front r
WAL true

TIL 3v
00000000
00011111
00101000
00101000
00101000
00101000
00101000
00101000
NAME bed side tl

TIL 3w
00101000
00101000
00101000
00101000
00101000
00101000
00011111
00000000
NAME bed side lb

TIL 3x
00000000
11111110
00000001
00000001
00000001
00000001
00000001
00000001
NAME bed side tr

TIL 3y
00000001
00000001
00000001
00000001
00000001
00000001
11111110
00000000
NAME bed side br

TIL 3z
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
11111111
00000000
00000000
00000000
00000000
00000000
00000000

TIL 4a
00000000
00000000
11111000
01010100
01010100
00011100
01000100
11101100
NAME rug tr

TIL 4b
11101100
01000100
00011100
01010100
01010100
11111000
00000000
00000000
NAME rug br

TIL 4c
00110111
00100010
00111000
00101010
00101010
00011111
00000000
00000000
NAME rug bl

TIL 4d
00000000
00000000
11111111
11000110
10000000
00011100
10100010
10101010
NAME rug tml

TIL 4e
00110111
00100110
00100000
00110110
00110110
00100000
00100110
00110111
NAME rug lm

TIL 4f
00000000
00000000
11111111
11000111
00000011
00111000
01000101
01010101
NAME rug tml

TIL 4g
00000000
00000000
11111111
11000110
10000000
00011100
10100010
10101010
NAME rug tmr

TIL 4h
01010101
01000101
00111000
00000001
01100011
11111111
00000000
00000000
NAME rug bml

TIL 4i
10101010
10100010
00011100
11000000
11100011
11111111
00000000
00000000
NAME rug bmr

TIL 4j
11101100
11000100
00000100
11001100
11001100
00000100
11000100
11101100
NAME rug rm

TIL 4k
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

TIL 4l
00000000
00000000
00000000
00011000
00111100
01111110
01011010
01000010
NAME stool

TIL 4m
00000000
00000000
00000000
00011111
00001000
00001000
00010111
00010000
NAME sleeping bag tl

TIL 4n
00000000
00000000
00000000
11100000
00010000
00010000
11110000
00100000
NAME sleeping bag tr

TIL 4o
00010000
00001000
00001010
00001001
00010000
00010010
00001000
00000111
NAME sleeping bag b l

TIL 4p
10100000
01010000
00010000
10010000
00010000
00100000
01000000
10000000
NAME sleeping bag b r

TIL 4q
00000000
00000011
00000100
00101000
01010000
01011111
01010000
01111111
NAME couch front l not wall
WAL false

SPR 10
00010100
00010100
00111110
00100010
00100010
00011100
00001000
00001000
NAME plug

SPR 11
00011000
00100100
11111111
10011001
10100101
10100101
10011001
11111111
NAME camera

SPR 12
11111000
10000101
10110111
10000111
11111001
01010000
01100000
01100000
NAME lazergun

SPR 13
00000000
00011000
00100100
00100100
01111110
01000010
01000010
01111110
NAME lock

SPR 14
00000000
00110000
01001000
01001000
00011111
00010001
00010001
00011111
NAME unlock

SPR 15
00111110
00110110
00111110
01011101
00111110
00010100
00010100
00110110
>
00111110
00110110
00111110
00011100
00111110
01010101
00010100
00110110
NAME alien one eye

SPR 16
00000000
00000000
11111100
00000010
11111110
00000010
00000010
00000010
>
00000000
00000000
11100000
00010000
11001000
00110100
00000100
00000100
NAME a13 bed ul
DLG 8
POS 3 9,6

SPR 17
00000000
00000000
00001111
00100101
00101011
01111111
01101111
00011011
>
00000000
01100000
01101111
00110101
00011111
00001111
00001111
00011011
>
00000000
01100000
01101111
00110101
00011111
00001111
00001111
00011011
>
00000000
01100000
01101111
00110101
00011111
00001111
00001111
00011011
>
00000000
01100000
01101111
00110101
00011111
00001111
00001111
00011011
>
00000000
01100000
01101111
00111111
00011111
00001111
00001111
00011011
>
00000000
01100000
01101111
00110101
00011111
00001111
00001111
00011011
>
00000000
00000000
00001111
00100101
00101011
01111111
01101111
00011011
>
00000000
00000000
00001111
00101010
00101101
01111111
01101111
00011011
NAME drunk man sitting A secondary hall
DLG 13
POS 2 13,6

SPR 18
00000000
01100010
01101010
01100010
01111110
01111110
00000000
00111100
>
00000000
01111110
01111110
01111110
01100110
01100110
00000000
00111100
NAME monitor box up down
DLG 46
POS 5 9,10

SPR 19
00000000
01111110
01000110
01010110
01000110
01111110
00000000
00111100
>
00000000
01111110
01100010
01101010
01100010
01111110
00000000
00111100
NAME monitor box side
DLG 44
POS 5 7,10

SPR 20
00000000
00000011
00000100
00101000
01010000
01011111
01010000
01011111

SPR 21
00111100
11000011
00000000
00000000
00000000
11111111
01000010
11111111

SPR 22
00111100
11010100
00111100
00101110
01111010
11011000
00010000
00000000
NAME a14 neighbor lady
DLG 16
POS 9 3,7

SPR 23
01000100
00101000
11111111
10000001
10011001
10000001
10100101
10011001
NAME a14 back of tv
DLG 1a
POS 9 2,9

SPR 24
00000001
00011110
00100001
01000000
01111111
01000110
01000010
01111110
NAME a14 tv stand l
DLG 24
POS 9 1,10

SPR 25
00011000
00000000
11111111
00000000
11111111
00000000
00000000
00000000
NAME a14 tv stand m
DLG 18
POS 9 2,10

SPR 26
10000000
01111110
10000010
00000110
11111010
01100010
01000100
01111000
NAME a14 tv stand r
DLG 19
POS 9 3,10

SPR 27
00000000
01111111
01000000
01100000
01011111
01010010
00100010
00011111
NAME a13 counter l 1
DLG 1h
POS 3 12,9

SPR 28
00000000
11111000
00000100
00000010
11111110
01000010
01000010
11111110
NAME a13 counter 1 r
DLG 5v
POS 3 14,9

SPR 29
00001111
00010000
00011111
00010001
00011100
00000000
00000000
00000000
NAME a13 chest 1 l
DLG 1d
POS 3 8,8

SPR 30
00000000
00011110
00100010
01000110
01111010
01101010
01010100
01111000
NAME a8 box 2
DLG 1q
POS c 14,9

SPR 31
00000000
00011110
00100010
01000110
01111010
01101010
01000100
01111000
NAME a8 box 3
DLG 1p
POS c 6,11

SPR 32
00000000
01111000
01010100
01100010
01011110
01010010
00100010
00011110
NAME a8 box 4
DLG 1o
POS c 9,10

SPR 33
10000000
01111110
10000010
00000110
11111010
01100010
01000100
01111000
NAME a8 tv stand r
POS c 6,10

SPR 34
00011000
00000000
11111111
00000000
11111111
00000000
00000000
00000000
NAME a8 tv stand m
DLG 2q
POS c 5,10

SPR 35
00000001
00011110
00100001
01000000
01111111
01000110
01000010
01111110
NAME a8 tv stand l
DLG 2p
POS c 4,10

SPR 36
01000100
00101000
11111111
10000001
10011001
10000001
10100101
10011001
NAME a8 back of tv
DLG 2r
POS c 5,9

SPR 37
00000000
00100011
01010101
01001001
00001000
01111110
00111100
00111100
NAME a sec plant 1
DLG 38
POS 2 8,12

SPR 38
00110000
00110000
11111100
01111000
01111000
01111000
00000000
00000000
NAME a sec plant 2 b
DLG 25
POS 2 9,12

SPR 39
00001000
00010101
00000010
01000010
10000100
10000100
01001000
00111000
NAME a sec plant 2 t
POS 2 9,11

SPR 40
01111110
11111111
01100110
01100110
11111111
01111110
00000000
11111111
>
01111110
11110111
01100010
01000110
11101111
01111110
00000000
11111111
>
01111110
11000011
01011010
01011010
11000011
01111110
00000000
11111111
>
01111110
11000011
01001010
01010010
11000011
01111110
00000000
11111111
NAME a2 counter kiosk
DLG 3x
POS f 8,5

SPR 41
00000000
11111000
00000100
00000010
11111110
01000010
01000010
11111110
NAME a2 counter r 1
DLG 6k
POS f 9,5

SPR 42
00000000
01111111
01000000
01100000
01011111
01010010
00100010
00011111
NAME a2 counter l 2
DLG 6a
POS f 2,2

SPR 43
00000000
11111111
00000000
00000000
11111111
00101010
00001000
11111111
NAME a2 counter m 5
DLG 6b
POS f 3,2

SPR 44
00000000
11111111
01011010
01011010
11111111
00100100
00100100
11000011
>
00000000
10001111
01111010
01111010
11111111
01110100
00100100
10100011
NAME a2 counter fryer 1
DLG 6l
POS f 4,2

SPR 45
00000000
11111111
01011010
01010010
11111111
00101010
00001000
11111111
NAME a2 counter cutting board
POS f 5,2

SPR 46
00000000
11111111
00000000
00000000
11111111
00101010
00001000
11111111
NAME a2 counter m 6
DLG 6c
POS f 6,2

SPR 47
01010101
10000000
00110110
00110110
10000000
01111111
01010101
11111111
NAME a2 counter oven stove
DLG 6m
POS f 7,2

SPR 48
00000000
11111111
00000000
00000000
11111111
00101010
00001000
11111111
NAME a2 counter m 7
DLG 6d
POS f 8,2

SPR 49
00000000
11111000
00000100
00000010
11111110
01010010
01000010
11111110
NAME a2 counter r 2
DLG 6e
POS f 9,2

SPR 50
00000000
00110000
01001000
10000000
01000000
01000000
10000000
00000000
NAME a main plant t r
POS 1 11,10

SPR A
00000000
00011110
00110000
00111100
01111110
10111101
00111100
00100100
>
00011110
00110000
00111100
01111110
10111101
00111100
00100100
00000100
>
00000000
00011110
00110000
00111100
01111110
10111101
00111100
00100100
>
00011110
00110000
00111100
01111110
10111101
00111100
00100100
00100000
POS 4 5,8

SPR a
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
>
00000000
00000000
01010100
01110010
01110010
01111100
00111100
00100100
NAME a13 cat
DLG 0
POS 3 12,11

SPR b
00111100
01011010
01011010
10011001
00011000
00100100
00100100
01100110
>
00111100
00111100
01011010
01011010
10011001
00011000
00100100
01100110
NAME Alien 1

SPR c
00111100
01011010
01011010
01111110
00100100
00011000
00111100
00111100
>
00000000
00111100
01011010
01011010
01111110
00100100
00011000
00111100
NAME Alien 1 Head

SPR d
00000000
01100110
01011010
01000010
01011010
01100110
00000000
00000000
>
11100111
10000001
10011001
01000010
10011001
10000001
11100111
00000000
NAME bedroom_pillow_action

SPR e
00000000
00000000
01111111
01010010
01000011
01111110
01000000
01000011
NAME a13_drawer_l_1
DLG 4

SPR f
00000000
00000000
11111110
01001010
11000010
01111110
00000010
11000010
NAME a13_drawer_r_1

SPR g
00000000
10111011
00001000
00000000
00111100
01111110
00111100
00000000
NAME a13_sink
DLG 1k
POS 3 13,9

SPR h
00000000
00000000
11111110
01001010
11000010
01111110
00000010
11000010
NAME a13_drawer_r_2

SPR i
00000000
00000000
01111111
01010010
01000011
01111110
01000000
01000011
NAME a13_drawer_l_2

SPR j
00101001
00111101
00100100
00100100
00110100
00100100
00111111
00000000
NAME a13_drawer_b_1

SPR k
00000000
00111111
00100100
00110100
00100100
00100100
00111101
00101001
NAME a13_drawer_t_1

SPR l
00100010
00010100
01111110
01100010
01000010
01000010
01111110
00111100
>
00100010
00010100
01111110
01000010
01000110
01000010
01111110
00111100
>
00100010
00010100
01111110
01000010
01000010
01001010
01111110
00111100
>
00100010
00010100
01111110
01000010
01100010
01000010
01111110
00111100
>
00100010
00010100
01111110
01000110
01000010
01000010
01111110
00111100
NAME tv
POS 5 7,5

SPR m
00000000
01111110
01111110
01111110
01111110
01111110
00000000
00111100
>
00000000
01111110
01011110
01111110
01111110
01111110
00000000
00111100
NAME monitor
DLG 45
POS 5 8,10

SPR n
00000000
01111100
01111101
00000000
00000000
00000000
00000000
00000000
NAME keyboard_mouse

SPR o
00111110
00111110
00111110
00000000
01111111
00011100
00011100
00000100
>
00000000
00111110
00101010
00111110
00000000
01111111
00011100
00010000
NAME robot
DLG a

SPR p
01000001
00111110
00101010
00010100
01111111
00011100
00011100
00010100
>
01000001
00111110
00101010
00011100
00111110
00111110
00011100
00010100
NAME alien
DLG 3y
POS f 6,4

SPR q
00111000
00001100
00111100
00111100
01111110
10111101
00100100
00100100
>
00000000
00111000
00001100
00111100
00111100
01111110
10111101
00100100
NAME people

SPR r
00000000
00111100
00010100
10111101
01111110
00111100
00111100
00100100
>
00111100
00010100
00111100
00101100
01111110
10111101
00100100
00100100
NAME a secondary excitedperson
DLG b
POS 2 6,11

SPR s
00111100
00010100
00111100
01111100
01111110
00111101
00100100
00100100
>
00111100
00010100
00101100
00111100
11111110
00111101
00100100
00100100
NAME a2 person 1
DLG 3q
POS f 5,13

SPR t
00000000
00000000
00000000
00111100
00101000
01111110
00111100
00100100
>
00000000
00000000
00000000
00111100
01101010
00110100
00111100
00100100
NAME child

SPR u
00000000
00100000
01000101
01000111
00100111
00011111
00011110
00010001
>
00010100
10001110
10001110
01011110
01111100
00111010
00110000
00100011
NAME a11 cat pounce 1
DLG 48
POS d 12,5

SPR v
10001000
11111000
10101000
01110001
00100001
01111001
01111101
10111110
>
10001000
11111000
10101000
01110010
00100010
01111001
01111101
10111110
>
10001000
11111000
10101000
01110100
00100010
01111010
01111110
10111110
NAME z main cat3
DLG 1m
POS 6 15,5

SPR w
11100111
10011001
11000011
00100100
00100100
00100100
00100100
00111100
NAME shirt

SPR x
00100000
11100000
11100001
00111110
00111110
00111110
00100010
01100110
>
00100000
11100000
00100010
11011110
00111110
00111110
00100010
01100110
NAME dog

SPR y
01110000
11010000
01110000
01111000
01111111
01111100
01111000
00100000
NAME bird

SPR z
00111110
01010010
10010010
11110010
10000010
10000010
10000010
11111110
NAME paper

SPR 1a
00000000
01000100
10101010
00010010
00010000
01111110
00111100
11111111
NAME a3 plant pot 1
DLG o
POS 5 14,9

SPR 1b
00000000
00100010
01010101
01001000
00001000
01111110
00111100
11111111
NAME a3 plant pot 2
DLG n
POS 5 14,12

SPR 1c
00000000
00000000
00000000
00000000
00000000
01111110
00111100
11111111

SPR 1d
00000000
00011110
00100010
01000110
01111010
01001010
01000100
01111000
NAME a3 box 1
DLG e
POS 5 4,5

SPR 1e
00000000
00011110
00100010
01000110
01111010
01101010
01000100
01111000
NAME a3 box 2
DLG f
POS 5 5,5

SPR 1f
00000000
01111000
01000100
01100010
01011110
01010010
00100010
00111110
NAME a3 box 3
DLG g
POS 5 5,8

SPR 1g
00000000
01111000
01000100
01100010
01011110
01010110
00101010
00011110
NAME a3 box 4
DLG h
POS 5 4,8

SPR 1h
00000000
00011110
00100010
01000110
01111010
01001010
01000100
01111000
NAME a3 box 5
DLG i
POS 5 3,10

SPR 1i
00000000
00011110
00100010
01000110
01111010
01101010
01010100
01111000
NAME a3 box 6
DLG j
POS 5 5,10

SPR 1j
00000000
01111111
01000000
01100000
01011111
01010010
00100010
00011111
NAME a3 counter l 1
DLG k
POS 5 11,12

SPR 1k
00000000
11111000
00000100
00000010
11111110
01000010
01000010
11111110
NAME a3 counter r 1
DLG l
POS 5 13,12

SPR 1l
00000000
10111011
00001000
00000000
00111100
01111110
00111100
00000000
NAME a3 sink
DLG m
POS 5 12,12

SPR 1m
01000010
01000010
01000010
01100010
01011110
01010010
00100010
00011110
NAME a3 counter b 2
DLG 14
POS 5 14,11

SPR 1n
00000000
01111000
01000100
01000010
01000010
01000010
01000010
01000010
NAME a3 counter t 2
DLG 15
POS 5 14,10

SPR 1o
00000000
00011000
00111100
01111110
01111110
00111100
00011000
00000000
>
00111100
01111110
11111111
11111111
11111111
11111111
01111110
00111100
NAME drop off hole center
DLG q
POS 8 5,4

SPR 1p
00000000
01111000
01000100
01000010
01000010
01000010
01000010
01000010
NAME a14 counter t 1
DLG 2n
POS 9 6,4

SPR 1q
01000010
01000010
01000010
01100010
01011110
01010010
00100010
00011110
NAME a14 counter b 1
DLG 2o
POS 9 6,5

SPR 1r
00000000
01111111
01000000
01100000
01011111
01010010
00100010
00011111
NAME a14 counter l 2
DLG 2g
POS 9 1,3

SPR 1s
00000000
11111000
00000100
00000010
11111110
01000010
01000010
11111110
NAME a14 counter 2 r
DLG 2k
POS 9 5,3

SPR 1t
00000000
10111011
00001000
00000000
00111100
01111110
00111100
00000000
NAME a14 sink
DLG 2j
POS 9 4,3

SPR 1u
00000000
11111111
00000000
00000000
11111111
00001000
00001000
11111111
NAME a14 counter 2 ml
DLG 2h
POS 9 2,3

SPR 1v
00000000
11111111
00000000
00000000
11111111
00010000
00010000
11111111
NAME a14 counter 2 mr
DLG 2i
POS 9 3,3

SPR 1x
00000000
01111111
01000000
01100000
01011111
01010010
00100010
00011111
NAME a14 counter l 2
DLG 17
POS 9 2,5

SPR 1y
00000000
11111111
00000000
00000000
11111111
00100100
00011000
11111111
NAME a14 counter m 
DLG 2l
POS 9 3,5

SPR 1z
00000000
11111000
00000100
00000010
11111110
01000010
01000010
11111110
NAME a14 counter r 2
DLG 2m
POS 9 4,5

SPR 2a
11110000
00001000
11111000
10001000
00111000
00000000
00000000
00000000
NAME a13 chest 1 r
DLG 1e
POS 3 9,8

SPR 2b
00000000
00011110
00100010
01000110
01111010
01001010
01000100
01111000
NAME a13 box 1
DLG 1j
POS 3 11,7

SPR 2c
00000000
00000000
00000000
00011110
00010100
00111011
00011110
00010010
>
00000000
00000000
00000000
00011110
00010100
00011010
00111111
00010010
>
00000000
00000000
00000000
00000000
00000000
00011110
00010100
00111011
>
00000000
00000000
00000000
00011111
00110100
00011010
00011110
00010010
>
00000111
00000101
00011111
00000111
00000111
00001001
00000000
00000000
>
00000000
00000000
00000000
00000001
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000001
00000000
00000001
00000000
00000000
00000000
00000000
00000000
>
00000000
00011110
00001010
00011111
00001110
00001110
00001001
00000000
>
00000000
00000000
00000000
00000000
00000000
00111100
00010100
01111110
>
00000000
00000000
00000000
00111100
00010100
01101110
00111100
00100100
NAME kidOutside A11 left frame
DLG 39
POS 2 11,14

SPR 2d
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
10000000
00000000
10000000
00000000
00000000
00000000
00000000
00000000
>
00000000
01111000
01010000
11111000
01110000
01110000
10010000
00000000
>
00000000
00000000
00000000
00000000
00000000
00111100
00101000
01111110
>
00000000
00000000
00000000
00111100
00101000
00110100
01111110
00100100
>
00000000
00000000
00000000
01111000
00101000
11011100
01111000
01001000
>
00000000
00000000
00000000
01111000
00101000
01011000
11111100
01001000
>
00000000
00000000
00000000
00000000
00000000
01111000
00101000
11111100
>
00000000
00000000
00000000
11111000
00101100
01111000
01111000
01001000
>
11100000
10100000
11111000
11100000
11100000
10010000
00000000
00000000
>
00000000
00000000
00000000
10000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
>
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME kidOutside A11 right frame
DLG 3a
POS 2 12,14

SPR 2e
00000000
00001110
00000110
00001110
00001111
00011110
00001110
00001010
>
00000000
00001110
00000110
00011110
00001111
00001110
00001110
00001010
>
00000000
00001110
00000110
00011110
00001111
00001110
00001110
00001010
>
00000000
00001110
00000110
00011110
00001111
00001110
00001110
00001010
>
00000000
00001110
00000110
00011110
00001111
00001110
00001110
00001010
>
00000000
00001110
00011110
00001110
00101111
00011110
00001110
00001010
>
00000000
01101110
01100110
00101110
00001111
00011110
00001110
00001010
>
11000000
10001110
00000110
00001110
00001111
00011110
00001110
00001010
NAME Z main guy smoking
DLG 1l
POS 6 14,2

SPR 2f
00000000
00000000
00000000
00000000
00010000
00111001
01111010
00011100
>
00000000
00000000
00000000
00010000
00110000
01111010
00011010
00011100
NAME rat 1

SPR 2g
00000000
00000000
00000000
00111000
01101111
11111110
00011100
00001000
>
00000000
00000000
00111000
01101000
11111100
00011110
00011111
00001000
NAME crow 1

SPR 2h
00000000
10000000
01000000
10000000
01000100
01111110
01111111
01100100
>
00000000
00000000
00100000
01000000
00100000
01000100
01111110
01111111
NAME rat 2

SPR 2i
00000000
00000000
00100000
01000000
01011010
00111110
00111011
00110100
>
00000000
00000000
00000000
01000000
10000000
01011010
00111110
00111011
NAME rat 3

SPR 2j
00000000
01000000
10000000
01101010
11111110
11111011
01111111
01011010
>
00000000
00000000
01000000
10000000
01101010
11111110
11111011
01111111
NAME rat 4
DLG 23
POS c 11,4

SPR 2k
00100000
01000000
10000000
10111000
11110110
01111111
00111100
01000100
>
00000000
10000000
01000000
01000000
10111000
11110110
01111111
00111100
NAME rat 5

SPR 2l
00000000
00010100
01001110
10011011
10111110
11111100
01111010
00101000
>
00000000
00010100
10001110
10011011
10111110
11111100
01111010
00101000
NAME rat 6

SPR 2m
00000000
01111111
01000000
01100000
01011111
01010010
00100010
00011111
NAME a8 counter left 1
DLG 22
POS c 1,4

SPR 2n
00000000
11111111
00000000
00000000
11111111
00001000
00001000
11111111
NAME a8 counter m 1
DLG 21
POS c 2,4

SPR 2o
00000000
11111111
00000000
00000000
11111111
00001000
00001000
11111111
NAME a8 counter m 2
DLG 20
POS c 3,4

SPR 2p
00000000
10111011
00001000
00000000
00111100
01111110
00111100
00000000
NAME a8 sink 
DLG 1z
POS c 4,4

SPR 2q
00000000
11111000
00000100
00000010
11111110
01000010
01000010
11111110
NAME a8 counter r 1
DLG 1y
POS c 6,4

SPR 2r
00000000
11111111
00000000
00000000
11111111
00001000
00001000
11111111
NAME a8 counter m 3
DLG 1x
POS c 5,4

SPR 2s
00000000
01111110
01111110
01111110
01111110
01111110
00000000
00111100
>
00000000
01111110
01011110
01111110
01111110
01111110
00000000
00111100
>
00000000
01111110
01111110
01111110
01111110
01111110
00000000
00111100
NAME a8 monitor
DLG 1w
POS c 13,4

SPR 2t
00000000
01111111
01000000
01100000
01011111
01010010
00100010
00011111
NAME a8 counter 2 l
DLG 1v
POS c 2,6

SPR 2u
00000000
11111111
00000000
00000000
11111111
00001000
00001000
11111111
NAME a8 counter m 3
DLG 1u
POS c 3,6

SPR 2v
00000000
11111111
00000000
00000000
11111111
00001000
00001000
11111111
NAME a8 counter m 4
DLG 1t
POS c 4,6

SPR 2w
00000000
11111000
00000100
00000010
11111110
01000010
01000010
11111110
NAME a8 counter r 2
DLG 1s
POS c 5,6

SPR 2x
00001111
00010000
00011111
00010001
00011100
00000000
00000000
00000000
NAME a8 chest 1 l
DLG 2s
POS c 9,6

SPR 2y
11110000
00001000
11111000
10001000
00111000
00000000
00000000
00000000
NAME a8 chest r 1
DLG 2t
POS c 10,6

SPR 2z
00000000
00011110
00100010
01000110
01111010
01001010
01000100
01111000
NAME a8 box 1
DLG 1r
POS c 14,10

SPR 3a
00000000
00000000
00000110
00001001
00001000
00000000
00000000
00000000
NAME a sec plant 2 tl
POS 2 8,11

SPR 3b
00000000
01111111
01000000
01100000
01011111
01010010
00100010
00011111
NAME a11 counter l 1 
DLG 4b
POS d 9,13

SPR 3c
00000000
11111000
00000100
00000010
11111110
01000010
01000010
11111110
NAME a11 counter r 1
DLG 4a
POS d 11,13

SPR 3d
00000000
10111011
00001000
00000000
00111100
01111110
00111100
00000000
NAME a11 sink
DLG 5t
POS d 10,13

SPR 3e
00000000
00000000
01010000
01111100
01110010
01111100
00111100
00100100
>
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
NAME a11 cat 1
DLG 47
POS d 9,3

SPR 3f
10001000
11111000
10101000
01110001
00100001
01111001
01111101
10111110
>
10001000
11111000
10101000
01110010
00100010
01111001
01111101
10111110
>
10001000
11111000
10101000
01110100
00100010
01111010
01111110
10111110
NAME a11 cat 2
DLG 49
POS d 10,8

SPR 3g
00000000
00000000
00000000
00000000
00010000
00111001
01111010
00011100
>
00000000
00000000
00000000
00010000
00110000
01111010
00011010
00011100
NAME rat 1

SPR 3h
00000000
00000000
11110000
10100000
11111000
11100000
10010000
01101000
>
00000000
00000000
11110000
10100000
11111000
11100000
10010000
01101000
>
00000000
00000000
11110000
10100000
11111000
11100000
10010000
01101000
>
00000000
00000000
11110000
10100000
11111000
11100000
10010000
01101000
>
00000000
00000000
11110000
10100000
11111000
11100000
10010000
01101000
>
00000000
00000000
11110000
10100000
11110000
11101000
10010000
01101000
NAME a11 child
DLG 29
POS d 8,13

SPR 3i
00000001
00011110
00100001
01000000
01111111
01000110
01000010
01111110
NAME a5 tv stand l
DLG 34
POS e 9,5

SPR 3j
00011000
00000000
11111111
00000000
11111111
00000000
00000000
00000000
NAME a5 tv stand m
DLG 36
POS e 10,5

SPR 3k
10000000
01111110
10000010
00000110
11111010
01100010
01000100
01111000
NAME a5 tv stand r
DLG 33
POS e 11,5

SPR 3l
01000100
00101000
11111111
10000001
10011001
10000001
10100101
10011001
NAME a5 tv back
DLG 35
POS e 10,4

SPR 3m
10111100
11010100
10111100
11101110
01111010
11011000
00010000
00000000
NAME a5 people r
DLG 2w
POS e 11,2

SPR 3n
00000111
00011010
00000111
00000101
00001111
00011011
00000010
00000000
NAME a5 people l
DLG 2v
POS e 10,2

SPR 3o
01000010
11000010
00000110
00001010
11110010
00000010
00000110
11111100
NAME a5 counter br corner
DLG 32
POS e 14,10

SPR 3p
00000000
11111111
00000000
00000000
11111111
00001000
00001000
11111111
NAME a5 counter m 1
DLG 2y
POS e 13,10

SPR 3q
00000000
01111000
01000100
01000010
01000010
01000010
01000010
01000010
NAME a5 counter t
DLG 2x
POS e 14,9

SPR 3r
00000000
01111111
01000000
01100000
01011111
01010010
00100010
00011111
NAME a5 counter l 1
DLG 31
POS e 10,10

SPR 3s
00000000
11111111
00000000
00000000
11111111
01001000
00001000
11111111
NAME a5 counter m 2
DLG 30
POS e 11,10

SPR 3t
00000000
10111011
00001000
00000000
00111100
01111110
00111100
00000000
NAME a5 sink
DLG 2z
POS e 12,10

SPR 3u
01111110
01000010
01000010
01000010
01111110
00011000
00011000
00011000
>
01111110
01000010
01000010
01000010
01111110
00011000
00011000
00011000
>
01111110
01100110
01000010
01100110
01111110
00011000
00011000
00011000
>
01111110
01000010
01011010
01000010
01111110
00011000
00011000
00011000
NAME a2 kiosk 1
DLG 3o
POS f 11,10

SPR 3v
00000000
01111111
01000000
01100000
01011111
01010010
00100010
00011111
NAME a2 counter l 1
DLG 6f
POS f 3,5

SPR 3w
00000000
11111111
00000000
00000000
11111111
00001000
00001000
11111111
NAME a2 counter m 1
DLG 6g
POS f 4,5

SPR 3x
00000000
11111111
00000000
00000000
11111111
00010000
00010000
11111111
NAME a2 counter m 2
DLG 6h
POS f 5,5

SPR 3y
00000000
11111111
00000000
00000000
11111111
00010000
00010000
11111111
NAME a2 counter m 3
DLG 6i
POS f 6,5

SPR 3z
00000000
11111111
00000000
00000000
11111111
00001000
00001000
11111111
NAME a2 counter m 4
DLG 6j
POS f 7,5

SPR 4a
00000000
00000000
00000000
00000000
11111111
00111100
00011000
00111100
NAME a2 table 1
DLG 3u
POS f 4,7

SPR 4b
00000000
00000000
00000000
00000000
11111111
00111100
00011000
00111100
NAME a2 table 2
DLG 3t
POS f 4,9

SPR 4c
00000100
00001000
00010010
11100010
11111111
00111100
00011000
00111100
>
00000100
00001000
11010010
00100010
11111111
00111100
00011000
00111100
NAME a2 table 3
DLG 3s
POS f 4,11

SPR 4d
00000000
00000000
00000110
11100110
11111111
00111100
00011000
00111100
NAME a2 table 4
DLG 3w
POS f 4,13

SPR 4e
00000000
00000000
00000000
00000000
11111111
00111100
00011000
00111100
DLG 3v
POS f 8,13

SPR 4f
00111100
00101000
00110100
00111100
01111111
10111100
00100100
00100100
>
00111100
00101000
00111100
00111110
01111110
10111100
00100100
00100100
NAME a2 person 2
DLG 3p
POS f 3,13

SPR 4g
00011110
00010100
00011110
00011111
00011110
00001110
00001010
00001010
NAME a2 guy on laptop
DLG 3r
POS f 3,11

SPR 4h
00111100
01100110
01100110
01000010
01111110
00011000
00011000
00000000
>
00111100
01100110
01100110
01000010
01111110
00011000
00000000
00011000
DLG 3z
POS f 7,8

SPR 4i
00000000
00000000
00000000
00111100
01001110
00111100
00011000
00111100
>
00000000
00000000
00000000
00111100
01110010
00111100
00011000
00111100
NAME robot propeller
DLG 40
POS f 7,7

SPR 4j
00000000
01111111
01000000
01100000
01011111
01010010
00100010
00011111
NAME z12 counter 1 l
DLG 58
POS i 1,3

SPR 4k
00000000
11111111
00000000
00000000
11111111
00001000
00001000
11111111
NAME z12 counter m 1
DLG 59
POS i 2,3

SPR 4l
00000000
11111111
00000000
00000000
11111111
00001000
00001000
11111111
NAME z12 counter m 2
DLG 5a
POS i 3,3

SPR 4m
00000000
10111011
00001000
00000000
00111100
01111110
00111100
00000000
NAME z12 sink
DLG 5b
POS i 4,3

SPR 4n
00000000
11111111
00000000
00000000
11111111
00010000
00010000
11111111
NAME z12 counter m 3
DLG 5c
POS i 5,3

SPR 4o
00000000
11111000
00000100
00000010
11111110
01000010
01000010
11111110
NAME z12 counter 1 r
DLG 5d
POS i 6,3

SPR 4p
00000001
00011110
00100001
01000000
01111111
01000110
01000010
01111110
NAME z12 tv stand l
DLG 5e
POS i 1,11

SPR 4q
00011000
00000000
11111111
00000000
11111111
00000000
00000000
00000000
NAME z12 tv stand m
DLG 5f
POS i 2,11

SPR 4r
10000000
01111110
10000010
00000110
11111010
01100010
01000100
01111000
NAME z12 tv stand r
DLG 6n
POS i 3,11

SPR 4s
01000100
00101000
11111111
10000001
10011001
10000001
10100101
10011001
NAME z12 tv
DLG 5h
POS i 2,10

SPR 4t
00111100
00101000
10110101
01111110
00111100
00111100
00100100
00000000
>
00000000
00111100
00101000
00111100
01111110
10111101
00111100
00100100
NAME a2 guy lost muni card
DLG 56
POS f 9,11

SPR 4u
00000000
00011110
00100010
01000110
01111010
01101010
01000100
01111000
NAME z12 box
DLG 5i
POS i 6,6

SPR 4v
00000000
00000000
11110000
10100000
11110000
11111000
11110000
11011000
>
00000000
00000000
11110000
10100000
11010000
11111000
11110000
11011000
NAME a main guy on floor 1
DLG 5j
POS 1 13,7

SPR 4w
00000010
00000000
11110000
11110000
11111000
11110000
11110000
11011000
>
00000000
00000000
11110000
10100000
11111000
11110000
11110000
11011000
>
00000000
00000000
11110000
11110000
11111000
11110000
11110000
11011000
>
00000000
00000000
11110000
10100000
11111000
11110000
11110000
11011000
>
00000000
00000000
11110000
10100000
11110000
11111000
11110000
11011000
>
00000000
00000000
11110000
10100000
11110100
11111000
11110000
11011000
>
00000000
00000000
11110010
10111110
11011100
11111000
11110000
11011000
>
00000011
00000111
11110010
10100100
11010000
11111000
11110000
11011000
NAME a main guy sitting smoking
DLG 5k
POS 1 13,6

SPR 4x
00110000
00110000
11111100
01111000
01111000
01111000
00000000
00000000
NAME a main plant base
DLG 5l
POS 1 10,11

SPR 4y
00010000
00101000
00010101
01000110
10100100
10000100
01001000
00111000
NAME a main plant top
POS 1 10,10

SPR 4z
00000000
00000000
00000110
00001001
00001000
00000000
00000000
00000000
NAME a main plant t l
POS 1 9,10

ITM 1
00000000
00111100
00100100
00111100
00010000
00011000
00010000
00011000
NAME key
DLG 2

ITM 2
00000000
00011000
00111100
00100100
00100100
00100100
00111100
00000000
NAME Empty Bottle
DLG 6

ITM 3
00000000
00011000
00111100
00111100
00111100
00111100
00111100
00000000
NAME Full Bottle

ITM 4
00000000
00000000
01111000
00111100
00000000
00000000
00000000
00000000
NAME muni
DLG 5

ITM 5
00000000
00000000
00111000
01110100
01111100
01111100
00111000
00000000
NAME ball
DLG 42

ITM 6
00000000
11111111
10000001
10100101
10000001
10111101
11111111
00000000
NAME cassette
DLG 2u

ITM 7
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM 8
00000000
00000000
00000000
00011111
00010001
00011111
00000000
00000000
>
00000000
00000000
00000000
00011111
00100001
00011111
00000000
00000000
NAME storage_stick

ITM 9
00000000
00100100
01111110
01111110
00111100
00011000
00011000
00000000
>
00100100
01011010
10000001
10000001
01000010
00100100
00100100
00011000
NAME heart

ITM 10
10000001
10001010
00000000
01100100
00000000
00010100
11000100
00000001
NAME dust5

ITM 11
11111111
11101010
11111111
11010101
11101110
10110101
11111110
10110100
NAME dust tl corner

ITM 12
10101100
11010001
10101000
10100001
11010000
11000000
10001000
10000000
NAME dust tlb

ITM 13
11111111
01110100
11001001
00100000
11001001
10000000
00010010
00000000
NAME dust tlr

ITM 14
01000000
10010000
00000000
10000000
01000000
10001000
00000000
11000000
NAME dust l

ITM 15
11111111
01011111
11110111
11101101
01010111
11111101
01010111
00101101
NAME dust tr corner

ITM 16
11011111
10110101
00101110
00000101
10000001
00100100
00000000
00000010
NAME dust trl

ITM 17
00110101
00001011
01000010
00000101
00000001
00100100
00000001
00001001
NAME dust trb

ITM 18
00101101
01111111
10101101
01110111
10101011
11111111
01010111
11111111
NAME dust br corner

ITM 19
00100000
00000100
00001001
10000011
00010101
01001010
00110111
11010111
NAME dust brl

ITM 20
00000000
00000000
00100000
01000000
01011010
00111110
00111011
00110100
>
00000000
00000000
00000000
01000000
10000000
01011010
00111110
00111011
NAME rat 5
DLG 4e

ITM 21
00100000
01000000
10000000
10111000
11110110
01111111
00111100
01000100
>
00000000
10000000
01000000
01000000
10111000
11110110
01111111
00111100
NAME rat 6
DLG 62

ITM 22
00000000
00000000
00000000
00000000
00000000
00000110
01101000
11110000
>
00000000
00000000
00000000
00000000
00000000
00000000
11000000
11111100
NAME dead rat
DLG 27

ITM 23
01100100
01100000
00001110
11011111
11111100
01111101
00011101
01000000
>
01100100
01100000
00001110
11011111
11111100
01111101
00011101
01000000
>
01100100
01100000
00001110
11011111
11111100
01111101
00011101
01000000
>
01100100
01100000
00001110
11011111
11111100
01111101
00011101
01000000
>
01100100
01100000
01001111
11011111
11111100
01111101
00111101
01000010
NAME trash pile rat
DLG 28

ITM 24
00000000
00000000
00111100
01111110
00100100
00100100
00111100
00000000
NAME bucket
DLG 4h

ITM 25
11011111
10110101
00101110
00000101
10000001
00100100
00000000
00000010
NAME z8 dust trl syringe
DLG 4i

ITM 26
10000001
10001010
00000000
01100100
00000000
00010100
11000100
00000001
NAME dust 5 key in the grime
DLG 4j

ITM 27
01100100
01100000
00001110
11011111
11111100
01111101
00011101
01000000
NAME trash pile 1 wrappers
DLG 4k

ITM 28
00000000
00000000
00000001
00100000
00000000
00000000
00000100
00000000
NAME a14 dust enter 1
DLG 4x

ITM 29
00101101
01111111
10101101
01110111
10101011
11111111
01010111
11111111
NAME a14 dust br corner empty bottle
DLG 4y

ITM a
00000000
00000000
00100000
01110000
01111110
00000000
00000000
00000000
NAME hat blue
DLG 7

ITM b
00000000
00011000
00111100
01111110
00111100
00011000
00000000
00000000
>
00011000
00111100
00000000
01111110
00000000
00111100
00011000
00000000
NAME burger

ITM c
00000000
00000000
00001100
00010100
00101000
00110000
00000000
00000000
>
00000000
00000000
00110000
00101000
00010100
00001100
00000000
00000000
NAME coin
DLG 43

ITM d
00111101
00110100
00111100
00000000
01111110
01111110
01111110
00000000
>
11000010
11001011
11000011
11111111
10000001
10000001
10000001
11111111
NAME floppydisk

ITM e
00111000
01111100
11111110
10010010
01101100
01111100
01010100
00000000
NAME skull

ITM f
00000000
00000110
00001010
01010100
00101000
01110000
11101000
01000000
NAME knife

ITM g
00000000
01111100
01000100
01000100
01000100
01111100
01010100
00111000
NAME portable_game_console
DLG d

ITM h
00000000
01111110
01111110
01111110
00000000
01010100
00101010
00000000
>
00000000
01111110
01011110
01111110
00000000
01010100
00101010
00000000
NAME laptop
DLG p

ITM i
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000

ITM j
01010000
00101000
01010000
11111100
10000111
10000101
10000110
01111000
>
01010000
01001000
00101000
11111100
10000111
10000101
10000110
01111000
NAME hot coffee

ITM k
00100000
00010000
00111110
00100010
00010100
00001000
00001000
00111110
NAME alcohol
DLG 54

ITM l
00000000
00011000
00100100
00100100
00111100
01100110
10100101
00111100
NAME sweatshirt
DLG 1g

ITM m
00000000
00111100
01110100
10100100
10111100
01101100
00100100
00111000
NAME backpack
DLG 1f

ITM n
00010000
01000010
10000000
00001000
00100000
00000100
00000010
00110000
NAME dust1

ITM o
10001100
11000001
00001101
01101000
00100010
00000110
11010000
00000101
NAME dust 2

ITM p
00010010
01001010
10000000
00101100
00100000
00000100
00000010
00110000
NAME dust3

ITM q
10110100
11101010
10111111
11101010
10110111
11101111
11111010
11111111
NAME dust bl corner pile

ITM r
00001000
01000000
00000010
10100000
10001001
01111100
10100000
11101101
NAME dust blr

ITM s
10010000
00000010
11000000
01000000
11101000
10000000
10110010
11101000
NAME dust blt 

ITM t
00001000
00000000
00000000
00000000
00100000
00000100
10000010
00000000
NAME dust blrr

ITM u
00000000
00000000
10000000
00000000
00000000
01000000
00000001
00010000
NAME dust bltt

ITM v
00000000
00000000
10000001
01111111
01001111
00110000
01000000
01100000
NAME gun revolver
DLG c

ITM w
00000000
00000000
00001100
00001100
00001100
00001100
00000000
00000000
NAME remote
DLG 41

ITM x
00000000
00000000
00000000
00011000
00000000
00011000
00011000
00000000
NAME spice shaker
DLG 37

ITM y
00000000
00000000
00000000
00011000
00011000
00000000
00011000
00000000
NAME can
DLG 26

ITM z
10000000
00001000
00000000
01000100
00000000
00010000
01000100
00000000
NAME dust4

ITM 1a
00000101
00000001
00000011
00010101
01000011
00001001
10100101
00111011
NAME dust brt

ITM 1b
00000000
00100000
00000000
00000000
00000010
01000000
00000000
00000000
NAME dust 6

ITM 1c
00001000
00000000
00000000
00000010
01000000
00000000
00000000
00010000
NAME dust 7

ITM 1d
00000000
00000000
00000001
00000000
00000000
01000000
00000100
00000000
NAME dust 8

ITM 1e
00000000
00000100
00000000
00000001
00000000
00000000
00000000
00001000
NAME dust 9

ITM 1f
00000001
01000000
00000001
00000010
00001001
00100001
00000010
00000001
NAME dust r 1

ITM 1g
00100001
00000001
10010010
00000011
00000001
00100000
00001001
10000010
NAME dust r 2

ITM 1h
00000000
00001000
01000000
00000000
10000100
00000000
00010000
11001101
NAME dust b 1

ITM 1i
01011001
00000010
01100000
00000000
00001000
00000000
00100000
00000000
NAME dust u 1

ITM 1j
10111001
00000100
01100000
00000010
00010000
00000000
00000010
10000000
NAME dust u 2

ITM 1k
00100000
01100010
00010110
00001001
00010000
01111110
00111100
11111111
NAME plant not to be picked up

ITM 1l
00000000
00000100
00000000
00000001
00000000
00000000
00000000
00001000
NAME dust 9 - first find in dust
DLG 1i

ITM 1m
00000000
00011110
00110000
00111100
01111110
10111101
00111100
00100100
>
00011110
00110000
00111100
01111110
10111101
00111100
00100100
00000100
>
00000000
00011110
00110000
00111100
01111110
10111101
00111100
00100100
>
00011110
00110000
00111100
01111110
10111101
00111100
00100100
00100000
NAME 4frameWalkTest

ITM 1n
01001000
00011100
01000110
00101100
10000110
01101100
01011001
11011101
NAME dust d

ITM 1o
00010000
00000010
01000000
00000000
00010100
01100101
00011011
10110101
NAME dust d 2

ITM 1p
00000101
00010011
00000101
10000011
00100010
00110001
00001011
00000010
NAME dust r

ITM 1q
00000101
00010001
00000100
00000001
00000010
00000001
00001011
00000010
NAME dust r 2

ITM 1r
00000000
00001000
00100001
00000100
01011010
10001011
01011110
10110101
NAME dust d 3

ITM 1s
00000000
00000000
00000000
00000000
01111100
01000100
01111100
00000000
>
00000000
00000000
00000000
00000000
01111100
01001100
01111100
00000000
>
00000000
00000000
00000000
00000000
01111100
01010100
01111100
00000000
>
00000000
00000000
00000000
00000000
01111100
01100100
01111100
00000000
NAME a13 your phone
DLG 1n

ITM 1t
01100100
01100000
00001110
11011111
11111100
01111101
00011101
01000000
NAME trash pile 1

ITM 1u
11011100
11000001
00110110
00111110
00111010
11011000
10011101
01000100
NAME trash pile 2

ITM 1v
00000000
01100000
01100000
01100110
00000000
00110000
00110000
00000000
NAME trash pile 3

ITM 1w
00000000
00000000
00000000
00000000
00010000
00111001
01111010
00011100
>
00000000
00000000
00000000
00010000
00110000
01111010
00011010
00011100
NAME rat 1
DLG 4g

ITM 1x
00000000
00000000
00000000
00000000
00100000
01110010
11110100
00111000
>
00000000
00000000
00000000
00100000
01100000
11110000
00110110
00111000
NAME rat 2
DLG 4f

ITM 1y
00000000
00000000
00000000
00000000
00001000
10011100
01011110
00111000
>
00000000
00000000
00000000
00001000
00001100
00011110
11011000
00111000
NAME rat 3
DLG 4d

ITM 1z
00000000
00000000
10000000
01000000
10000100
01111110
01111111
01100100
>
00000000
00000000
00100000
01000000
00100000
01000100
01111110
01111111
NAME rat 4
DLG 4c

ITM 2a
00000000
00100000
00000000
00000000
00000010
01000000
00000000
00000000
NAME a8 look at rat dust
DLG 4z

ITM 2b
00000000
00000100
00000000
00000001
00000000
00000000
00000000
00001000
NAME dust plain muni
DLG 50

ITM 2c
00001000
01000000
00000010
10100000
10001001
01111100
10100000
11101101
NAME a8 dust blr find password
DLG 51

ITM 2d
01100100
01100000
00001110
11011111
11111100
01111101
00011101
01000000
NAME trash pile find charge cord
DLG 52

ITM 2e
00000000
00000000
00000001
00000000
00000000
01000000
00000100
00000000
NAME a11 dust find toy car
DLG 53

ITM 2f
00110101
00001011
01000010
00000101
00000001
00100100
00000001
00001001
NAME dust find trading card 1
DLG 55

ITM 2g
00000000
01100000
01100000
01100110
00000000
00110000
00110000
00000000
NAME z8 a11 key trash
DLG 57

ITM 2h
00000000
00000000
00100000
00000000
00000000
00000000
00000010
00000000
NAME dust 10

ITM 2i
00000000
00000100
00000000
00000000
00000000
00000000
00000000
01000000
NAME dust 11

ITM 2j
00000000
00100000
00000000
00000000
00000010
01000000
00000000
00000000
NAME z12 dust enter room
DLG 5g

ITM 2k
10101100
11010001
10101000
10100001
11010000
11000000
10001000
10000000
NAME a main chicken bone dust
DLG 5m

ITM 2l
00000000
00000000
10000000
00000000
00000000
01000000
00000001
00010000
NAME a main dust bottle cap
DLG 5n

ITM 2m
10000000
00001000
00000000
01000100
00000000
00010000
01000100
00000000
NAME dust 4 muni
DLG 5o

ITM 2n
00000000
01100000
01100000
01100110
00000000
00110000
00110000
00000000
NAME trash pile with rat bones
DLG 5p

ITM 2o
01100100
01100000
00001110
11011111
11111100
01111101
00011101
01000000
NAME trash pile with debit card
DLG 5s

ITM 2p
00000000
00100000
00000000
00000000
00000010
01000000
00000000
00000000
DLG 5u

ITM 2q
10110100
11101010
10111111
11101010
10110111
11101111
11111010
11111111
NAME a sec dust bl muni
DLG 5w

ITM 2s
11011100
11001001
00111110
01111110
00101011
11010100
10011101
01000110
NAME pile of trash skull
DLG 5z

ITM 2t
00100000
00000100
00001001
10000011
00010101
01001010
00110111
11010111
NAME z6a dust brl door code
DLG 63

ITM 2u
00000000
00000000
00000000
00000000
00100000
01110010
11110100
00111000
>
00000000
00000000
00000000
00100000
01100000
11110000
00110110
00111000
NAME rat 2 bite
DLG 64

ITM 2v
00000000
00000000
00000000
00000000
00001000
10011100
01011110
00111000
>
00000000
00000000
00000000
00001000
00001100
00011110
11011000
00111000
NAME rat 3 bite
DLG 65

ITM 2w
00000000
00011000
00111100
00100100
00100100
00100100
00111100
00000000
NAME empty bottle 2
DLG 66

ITM 2x
00000000
00011000
00111100
00100100
00100100
00100100
00111100
00000000
NAME empty bottle 3
DLG 67

ITM 2y
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME a5 dust tv sequence
DLG 68

ITM 2z
00000000
00000000
01111000
00111100
00000000
00000000
00000000
00000000
NAME muni tv sequence
DLG 69

DLG 0
"""
{sequence
  - meow
  - {wvy}meow{wvy}
  - mao
  - {wvy}myroooo{wvy}
  - {rbw}prrrrrrrr{rbw}
}
"""
NAME cat dialog

DLG 1
You found a nice warm cup of tea
NAME tea dialog

DLG 2
A key! {wvy}What does it open?{wvy}
NAME key dialog

DLG 3
"""
{sequence
  - ...
    ...incoming message...
    
    noone: your neighbor in A3 has passed away.  go to their apartment and collect their water.  you may keep any valuables you find.  once you collect the water, you will receive further instructions.
  - 
}
"""

DLG 4
"""
{
  - {item "4"} < 5 ?
    {wvy}*searching*{wvy}
    
    you found 5 muni{item "4" {{item "4"} + 5}}
  - else ?
    {wvy}*searching*{wvy}
    
    you found nothing interesting
}
"""
NAME a13_drawer_l_1 dialog

DLG 5
you found muni
NAME muni dialog

DLG 6
"""
you picked up an empty bottle{hasEmptyBottle1 = 1}{tempInt = hasBlueHat + hasSweatshirt + hasBackpack + hasEmptyBottle1}
{
  - hasBlueHat + hasSweatshirt + hasBackpack + hasEmptyBottle1 >= 4 ?
    {canLeaveFirstRoom = 1}{tempString = "you're ready to go"}
  - else ?
    {tempString = ""}
}(p){say tempString}

"""
NAME Empty Bottle dialog

DLG 7
"""
you put on your {droop}blue hat{droop}{hasBlueHat = 1}
{tempInt = hasBlueHat + hasSweatshirt + hasBackpack + hasEmptyBottle1}{
  - hasBlueHat + hasSweatshirt + hasBackpack + hasEmptyBottle1 >= 4 ?
    {canLeaveFirstRoom = 1}{tempString = "you're ready to go"}
  - else ?
    {tempString = ""}
}(p){say tempString}
"""
NAME hat_blue dialog

DLG 8
"""
Greeting text{choice
	- Response one
	  answer to response one
	- Response two
	  answer to response two
    }
"""

DLG 9

NAME bed_dialog

DLG 10

NAME exit narration 10

DLG 11
to main A hall
NAME exit narration 11

DLG 12
to A3
NAME exit narration 12

DLG 13
"""
*burp* hey, buddy(p)do you have a couple of munies to spare?(p)they said I can't go in there when I'm drunk(p)dialogchoice give him muni? yes you gave him 1 muni no if has cannabis give him cannabis? yes you gave him 1 cannabis no 2choices fuck off fack off

aSec_drunk
"""
NAME man sitting drinking dialog

DLG 14
"""
INSERT dialog about found a spatula
a3_counter_3
"""
NAME a3 counter b 2 dialog

DLG 15
"""
INSERT counter dialog about finding computer password in way of finding obscure scifi novel and trying the novel name for the password

a3_counter_4
"""
NAME a3 counter 4

DLG 16
"""
{sequence
  - neighbor: what are you doing in my apartment?
  - you need to leave
  - get out
  - did he send you in here?
  - you need to leave
  - you need to leave
}
"""
NAME a14 neighbor lady dialog

DLG 17
"""
INSERT counter dialog

a14_counter_7
"""
NAME sprite 1x dialog

DLG 18
it's the backside of a tv, chill out
NAME sprite 25 dialog

DLG 19
"""
the cabinet contains a westation series z game console

a14_cabinet_2
"""
NAME a14 cabinet 2 dialog

DLG 20
"""
INSERT counter dialog

a8_counter_3
"""
NAME a8 counter m 2 dialog

DLG 21
"""
INSERT counter dialog

a8_counter_2
"""
NAME a8 counter m 1 dialog

DLG 22
"""
INSERT counter dialog

a8_counter_1
"""
NAME a8 counter left 1 dialog

DLG 23
"""
{wvy}...picking up {noise}rat{noise} that you think probably belongs to your neighbor that lost a {u}rat{u}...{wvy}(p){rbw}you were bit by the rat.{rbw}(p)it may or may not be your neighbor's rat, but it won't let you pick it up(p)you are now {clr1}bleeding{clr1}

a8_rat
gotBit
sinceBit
health

30 intereactions after being bit kills you unless you find bandages
"""
NAME rat 4 dialog

DLG 24
"""
you find a cabinet full of HD DVDs and MiniDiscs... 'useful'

a14_cabinet_1
"""
NAME a14 tv stand l dialog

DLG 25
it's a plant.(p)'i don't remember this ever having leaves.'
NAME a sec plant 2 b dialog

DLG 26
you found can
NAME can dialog

DLG 27
this rat is dead(p)some of its blood got on you(p)'yuck'
NAME item 22 dialog

DLG 28
you found a rat in this pile of trash
NAME trash pile rat dialog

DLG 29
"""
have you seen my parents?

You'll have the options to give the kid the toy car

You'll also have the option to give the kid food

a11_child
"""
NAME a11 child dialog

DLG 30
"""
INSERT counter dialog

a5_counter_2
"""
NAME a5 counter m 2 dialog

DLG 31
"""
INSERT counter dialog

a5_counter_1
"""
NAME a5 counter l 1 dialog

DLG 32
'i don't think i can reach this'
NAME a5 counter br corner dialog

DLG 33
"""
INSERT cabinet dialog

a5_showSequence
"""
NAME a5 tv stand r dialog

DLG 34
"""
INSERT cabinet dialog

a5_showSequence
"""
NAME a5 tv stand l dialog

DLG 35
"""
INSERT dialog with a series of potential quotes from a murder porn show

a5_showSequence
"""
NAME a5 tv back dialog

DLG 36
"""
it's the back side of a tv

a5_showSequence
"""
NAME a5 tv stand m dialog

DLG 37
"""
you found turmeric

a5_showSequence
tumeric
"""
NAME spice shaker dialog

DLG 38
'this plant doesn't look very good'
NAME a sec plant 1 dialog

DLG 39
"""
INSERT dialog that changes depending on if you have talked to either side.  Have something about how they're locked out of their apartment and they haven't seen their parents in two weeks and that they can't find their younger sibling

foundDeadParent
a11_toyCar
"""
NAME kidOutside A11 left frame dialog

DLG 40
INSERT robot dialog also
NAME robot propeller dialog

DLG 41
you picked up a remote
NAME remote dialog

DLG 42
you picked up a ball
NAME ball dialog

DLG 43
you found 1 muni
NAME coin dialog

DLG 44
"""
INSERT monitor dialog about 3D models on the monitor

a3_unlock
"""
NAME monitor box side dialog

DLG 45
"""
INSERT monitor dialog saying something about aliens

if have a3_password you can unlock all 3 monitors

a3_unlock would become 1
"""
NAME monitor dialog

DLG 46
"""
INSERT monitor description of a deep underground military base

a3_unlock
"""
NAME monitor box up down dialog

DLG 47
"""
INSERT cat dialog

a11_cat_1
"""
NAME a11 cat 1 dialog

DLG 48
"""
INSERT cat dialog

a11_cat_2

this is the pouncing 1
"""
NAME a11 cat pounce 1 dialog

DLG 49
"""
INSERT cat dialog

a11_cat_3
"""
NAME a11 cat 2 dialog

DLG 50
INSERT you found 1 muni
NAME dust plain muni dialog

DLG 51
INSERT you found a password written on a small piece of paper
NAME a8 dust blr find password dialog

DLG 52
INSERT dialog about finding a charger cord
NAME trash pile find charge cord dialog

DLG 53
"""
INSERT dialog about finding a toy car that you can give to either of the children
Giving it to the starving kid prompts them saying "hey, this was already my toy car, how'd you get it?"

a11_toyCar
"""
NAME a11 dust find toy car dialog

DLG 54
"""
INSERT dialog about picking up an alcoholic beverage

a5_showSequence
"""
NAME alcohol dialog

DLG 55
"""
INSERT dialog about finding a trading card

ALSO add in a bit about the tv show

a5_showSequence
"""
NAME dust find trading card 1 dialog

DLG 56
"""
INSERT dialog about having lost their muni card and they have no muni

You can give them their card if you found it

you can give them muni

you can tell them "that's a bummer"

a2_muniCardGuy
foundMuniCard
"""
NAME a2 guy lost muni card dialog

DLG 57
"""
INSERT dialog about finding neighbor's key in the sleeping bag

a11_key
"""
NAME z8 a11 key trash dialog

DLG 58
"""
INSERT counter dialog

z12_counter_1
"""
NAME z12 counter 1 l dialog

DLG 59
"""
INSERT counter dialog

z12_counter_2
"""
NAME z12 counter m 1 dialog

DLG 60
you enter the secondary Z hall
NAME exit narration 26

DLG 61
you enter Z6
NAME exit narration 27

DLG 62
INSERT rat dialog
NAME rat 6 dialog

DLG 63
INSERT you found a 5 digit code on a piece of paper
NAME z6a dust brl door code dialog

DLG 64
INSERT rat bite dialog
NAME rat 2 bite dialog

DLG 65
INSERT rat bite dialog
NAME rat 3 bite dialog

DLG 66
INSERT add an empty bottle to inventory
NAME empty bottle 2 dialog

DLG 67
INSERT add an empty bottle to inv and add a bit of text from the show
NAME empty bottle 3 dialog

DLG 68
INSERT first bit of show sequence
NAME a5 dust tv sequence dialog

DLG 69
"""
a5_showSequence

INSERT you found muni
"""
NAME muni tv sequence dialog

DLG a
"""
{
  - metBernice >= 1 ?

  - else ?
    {bernices = bernices + 1}
}{
  - bernices == 1 ?
    {tempString = ":"}
  - else ?
    {tempString = " " + bernices + ":"}
}Bernice {say tempString} {wvy}I am robot Bernice{wvy}
"""
NAME robot dialog

DLG b
oh no! i lost my pet rat. it means the world to me.(p)could you please help me find it?  i'll owe you big time.(p)i'm sure i could make it up to you some how.
NAME excitedperson dialog

DLG c
"""
you found gun
INSERT hasGun = 1
"""
NAME gun revolver dialog

DLG d
you found a portable game console
NAME portable_game_console dialog

DLG e
INSERT box dialog you get muni a3_box_1
NAME a3 box 1 dialog

DLG f
"""
{wvy}...searching...{wvy}(p)you found {rbw}nothing{rbw}
a3_box_2
"""
NAME a3 box 2 dialog

DLG g
"""
INSERT box dialog about a can of beans
a3_box_3
"""
NAME a3 box 3 dialog

DLG h
"""
INSERT box dialog about finding tape
a3_box_4
"""
NAME a3 box 4 dialog

DLG i
"""
INSERT box dialog about finding 5 muni
a3_box_5
"""
NAME a3 box 5 dialog

DLG j
"""
INSERT box dialog about finding old jerky

a3_box_6
"""
NAME a3 box 6 dialog

DLG k
"""
INSERT counter dialog about finding a knife  a3_counter_1

"""
NAME a3 counter l

DLG l
"""
INSERT counter dialog about finding a chili powder shaker
a3_counter_2
"""
NAME a3 counter 2

DLG m
"""
you collected some water 
a3_sink

incoming message

noone: good work

drop the water off in the secret room in Z6
"""
NAME a3 sink dialog

DLG n
it's a fake plant
NAME plant pot 2 dialog

DLG o
'it's a fake plant'
NAME plant pot 1 dialog

DLG p
"""
you picked up a laptop

"""
NAME laptop dialog

DLG q
you put the water in the hole
NAME drop off hole center dialog

DLG r
"""
{property locked true}{
  - canLeaveFirstRoom >= 1 ?
    {property locked false}to the secondary A hall
  - else ?
    you must get dressed, grab your backpack and an empty bottle before you leave.  (p)also, do you have any muni?
}
"""
NAME exit narration 1

DLG s
welcome home
NAME exit narration 2

DLG t
to main A hall
NAME exit narration 3

DLG u
to secondary A hall
NAME exit narration 4

DLG v
to Z main hall
NAME exit narration 5

DLG w
to A main hall
NAME exit narration 6

DLG x
to secondary Z hall
NAME exit narration 7

DLG y
to main Z hall
NAME exit narration 8

DLG z
'what's this?'
NAME exit narration 9

DLG 1a
neighbor: get the fuck out of the way of my tv and get out of my fucking house!
NAME sprite 23 dialog

DLG 1b
you barge into your neighbor's apartment uninvited
NAME exit narration 13

DLG 1c
neighbor: stay out of my fucking apartment or i'll call the enforcers
NAME exit narration 14

DLG 1d
"""
{
  - a13_chest1 < 1 ?
    you found {rbw}something{rbw} in the chest{a13_chest1 = a13_chest1 + 1}
  - else ?
     you found nothing
}
"""
NAME a13 chest 1 l dialog

DLG 1e
"""
{
  - a13_chest1 < 1 ?
    you found 1 muni in the chest{a13_chest1 = a13_chest1 + 1}{muni = muni + 1}
  - else ?
     the chest is empty
}
"""
NAME a13 chest 1 r dialog

DLG 1f
"""
you picked up your backpack{hasBackpack = 1}{tempInt = hasBlueHat + hasSweatshirt + hasBackpack + hasEmptyBottle1}
{
  - hasBlueHat + hasSweatshirt + hasBackpack + hasEmptyBottle1 >= 4 ?
    {canLeaveFirstRoom = 1}{tempString = "you're ready to go"}
  - else ?
    {tempString = ""}
}(p){say tempString}
"""
NAME backpack dialog

DLG 1g
"""
you put on your sweatshirt{hasSweatshirt = 1}{tempInt = hasBlueHat + hasSweatshirt + hasBackpack + hasEmptyBottle1}
{
  - hasBlueHat + hasSweatshirt + hasBackpack + hasEmptyBottle1 >= 4 ?
    {canLeaveFirstRoom = 1}{tempString = "you're ready to go"}
  - else ?
    {tempString = ""}
}(p){say tempString}
"""
NAME sweatshirt dialog

DLG 1h
"""
{wvy}...searching...{wvy}(p)
{
  - muni <= 5 ?
    you got 5 muni{muni = muni + 5}
  - else ?
    you found nothing
}
"""
NAME a13 counter l 1 dialog

DLG 1i
"""
"wow, this place is filthy.  maybe I should clean it up"(p)you found 1 muni in the dust
{muni = muni + 1}
"""
NAME dust 9 - first find in dust dialog

DLG 1j
"""
{wvy}...searching...{wvy}
{
  - cannabis <= 5 ?
    (p)you found 1 {rbw}cannabis{rbw} in the box
    {cannabis = cannabis + 1}
  - else ?
    (p)you found nothing.(p)you already have {say cannabis} cannabis on you.(p)do something else
}
"""
NAME a13 box 1 dialog

DLG 1k
it is not your time for water.  the government has decided you get water every day at 2:30 pm.
NAME a13_sink dialog

DLG 1l
"""
hey, i'm trying to make this curry dish, but i'm out of turmeric.  you wouldn't happen to have any to spare, would you?

zMain_smoker
"""
NAME guy smoking dialog

DLG 1m
marow
NAME z main cat3 dialog

DLG 1n
you picked up your phone(p){wvy}...incoming message...{wvy}(p)INSERT message about getting water in A3
NAME a13 your phone dialog

DLG 1o
"""
INSERT box dialog

a8_box_2
"""
NAME a8 box 4 dialog

DLG 1p
"""
INSERT box dialog

a8_box_1
"""
NAME a8 box 3 dialog

DLG 1q
"""
INSERT box dialog

a8_box_3
"""
NAME a8 box 2 dialog

DLG 1r
"""
INSERT box dialog

a8_box_4
"""
NAME a8 box 1 dialog

DLG 1s
"""
INSERT counter dialog

a8_counter_9
"""
NAME a8 counter r 2 dialog

DLG 1t
"""
INSERT counter dialog

a8_counter_8
"""
NAME a8 counter m 4 dialog

DLG 1u
"""
INSERT counter dialog

a8_counter_7
"""
NAME a8 counter m 3 dialog

DLG 1v
"""
INSERT counter dialog

a8_counter_6
"""
NAME a8 counter 2 l dialog

DLG 1w
"""
INSERT monitor dialog if you picked up the paper with the password, you can log in and see something funny maybe it's open to a search engine with the search "how to know if a rat loves you"

a8_password
a8_unlocked
"""
NAME a8 monitor dialog

DLG 1x
"""
INSERT counter dialog

a8_counter_4
"""
NAME a8 counter m 3 dialog 1

DLG 1y
"""
INSERT counter dialog

a8_counter_5
"""
NAME a8 counter r 1 dialog

DLG 1z
"""
INSERT sink dialog

"""
NAME a8 sink  dialog

DLG 2a
"""
{property locked true}...the door is locked...

"""
NAME locked exit 1

DLG 2b
"""
{property locked true}...the door is locked...

"""
NAME locked exit 2

DLG 2c
"""
{property locked true}...the door is locked...

"""
NAME locked exit 3

DLG 2d
"""
{property locked true}...the door is locked...

"""
NAME locked exit 4

DLG 2e
"""
{property locked true}...the door is locked...

"""
NAME locked exit 5

DLG 2f
"""
{property locked true}...the door is locked...

"""
NAME locked exit 6

DLG 2g
"""
INSERT counter dialog

a14_counter_
"""
NAME a14 counter l 2 dialog

DLG 2h
"""
INSERT counter dialog
a14_counter_2
"""
NAME a14 counter 2 ml dialog

DLG 2i
"""
INSERT counter dialog
a14_counter_3
"""
NAME a14 counter 2 mr dialog

DLG 2j
neighbor: don't you {shk}dare{shk} touch my sink.
NAME a14 sink dialog

DLG 2k
"""
INSERT counter dialog

a14_counter_4
"""
NAME a14 counter 2 r dialog

DLG 2l
"""
INSERT counter dialog
a14_counter_8
"""
NAME a14 counter m  dialog

DLG 2m
"""
INSERT counter dialog

a14_counter_9
"""
NAME a14 counter r 2 dialog

DLG 2n
"""
INSERT counter dialog

a14_counter_5
"""
NAME a14 counter t 1 dialog

DLG 2o
"""
INSERT counter dialog

a14_counter_6
"""
NAME a14 counter b 1 dialog

DLG 2p
INSERT cabinet dialog
NAME a8 tv stand l dialog

DLG 2q
it's the back of a tv(p)you find 
NAME a8 tv stand m dialog

DLG 2r
INSERT tv dialog
NAME a8 back of tv dialog

DLG 2s
INSERT chest dialog
NAME a8 chest 1 l dialog

DLG 2t
INSERT chest dialog
NAME a8 chest r 1 dialog

DLG 2u
"""
you picked up a cassette tape

a8_cassette
"""
NAME cassette dialog

DLG 2v
"""
INSERT dialog for person on couch with partner

a5_showSequence
"""
NAME a5 people l dialog

DLG 2w
"""
INSERT dialog for other person on couch with partner

a5_showSequence
"""
NAME a5 people r dialog

DLG 2x
"""
INSERT counter dialog

a5_counter_4
"""
NAME a5 counter t dialog

DLG 2y
"""
INSERT counter dialog

a5_counter_3
"""
NAME a5 counter m 1 dialog

DLG 2z
"""
INSERT sink dialog neighbor: don't touch that

a5_showSequence
"""
NAME a5 sink dialog

DLG 3a
INSERT dialog that changes depending on if you have talked to either side.  Have something about how they're locked out of their apartment and they haven't seen their parents in two weeks and that they can't find their younger sibling
NAME kidOutside A11 right frame dialog

DLG 3b
{property locked true}the door is locked.(p)you weren't invited in anyway, why are you trying to go into your neighbor's apartment? 
NAME locked exit 7

DLG 3c
{property locked true}the door is locked.
NAME locked exit 8

DLG 3d
{property locked true}this area is under construction
NAME locked exit 9

DLG 3e
{property locked true}this area is under construction
NAME locked exit 10

DLG 3f
{property locked true}the door is locked.
NAME locked exit 11

DLG 3g
{property locked true}the door is locked.
NAME locked exit 12

DLG 3h
'weird.  i thought I lived in A 13'
NAME exit narration 15

DLG 3i
{property locked true}the door is locked.
NAME locked exit 13

DLG 3j
{property locked true}the door is locked.
NAME locked exit 14

DLG 3k
{property locked true}the door is locked.
NAME locked exit 15

DLG 3l
{property locked true}the door is locked.
NAME locked exit 16

DLG 3m
{property locked true}the door is locked.
NAME locked exit 17

DLG 3n
{property locked true}the door is locked.
NAME locked exit 18

DLG 3o
kiosk: welcome to talulah's cafe @ A2
NAME sprite 3u dialog

DLG 3p
INSERT dialog about how good the food is
NAME a2 person 2 dialog

DLG 3q
INSERT dialog "please don't bother us"
NAME a2 person 1 dialog

DLG 3r
guy: "i'm working here.(p)please leave me alone"
NAME a2 guy on laptop dialog

DLG 3s
guy: "can you stop looking at my screen?(p)this is sensitive work
NAME a2 table 3 dialog

DLG 3t
this is a table
NAME a2 table 2 dialog

DLG 3u
this is also a table
NAME a2 table 1 dialog

DLG 3v
table
NAME sprite 4e dialog

DLG 3w
guy: "the fuck is wrong with you?(p)don't touch our food"
NAME a2 table 4 dialog

DLG 3x
"""
INSERT food ordering system that will also explain that robots do the work

a2_kiosk
"""
NAME a2 counter kiosk dialog

DLG 3y
talulah: "welcome to my cafe(p)i don't really do much here since i got these robots to work for me"
NAME alien dialog

DLG 3z
"""
INSERT robot dialog

'whoa, i should watch out for the jets'
"""
NAME sprite 4h dialog

DLG 4a
"""
INSERT counter dialog - they probably don't have any food

a11_counter_2
"""
NAME a11 counter r 1 dialog

DLG 4b
"""
INSERT counter dialog - no food

a11_counter_1
"""
NAME a11 counter l 1  dialog

DLG 4c
"""
INSERT rat dialog

"""
NAME rat 4 dialog 1

DLG 4d
INSERT rat dialog
NAME rat 3 dialog

DLG 4e
INSERT rat dialog
NAME rat 5 dialog

DLG 4f
INSERT rat dialog
NAME rat 2 dialog

DLG 4g
INSERT rat dialog
NAME rat 1 dialog

DLG 4h
"""
you picked up a bucket full of unimaginable things

{health = health - 2}
"""
NAME bucket dialog

DLG 4i
"""
you found a syringe in the grime(p)'i hope it doesn't poke me'

{health = health - 3}
"""
NAME dust trl syringe dialog

DLG 4j
INSERT dialog this is where you find the key to the kids' apartment
NAME dust 5 key in the grime dialog

DLG 4k
INSERT dialog about finding low quality pastry wrappers
NAME trash pile 1 wrappers dialog

DLG 4l
{property locked true}the door is locked
NAME locked exit 19

DLG 4m
{property locked true}the door is locked
NAME locked exit 20

DLG 4n
{property locked true}the door is locked(p)'it's kinda weird they used a shitty key code system for their front door and still lock this door with a physical key'
NAME locked exit 21

DLG 4o
this door will be locked.  once the player finds the passcode, they will be given the prompt to enter the code and gain access.
NAME locked exit 22

DLG 4p
to restaurant
NAME exit narration 16

DLG 4q
to main A hall
NAME exit narration 17

DLG 4r
you barge into your neighbor's apartment uninvited
NAME exit narration 18

DLG 4s
to secondary A hall
NAME exit narration 19

DLG 4t
in search for your neighbor's lost pet rat, you decide to check their apartment for the rat.
NAME exit narration 20

DLG 4u
to secondary A hall
NAME exit narration 21

DLG 4v
this will have a key lock.  you find the key in the stinky room in the z sec hall
NAME exit narration 22

DLG 4w
to secondary A hall
NAME exit narration 23

DLG 4x
neighbor: "hey, what are you doing?(p){shk}get out of here{shk}"
NAME a14 dust enter 1 dialog

DLG 4y
INSERT find empty bottle dialog
NAME a14 dust br corner empty bottle dialog

DLG 4z
"""
'is that the rat?'(p)'how did my neighbor not check their own apartment?'

a8_sawBigRat
"""
NAME a8 look at rat dust dialog

DLG 5a
"""
INSERT counter dialog

z12_counter_3
"""
NAME z12 counter m 2 dialog

DLG 5b
INSERT sink dialog
NAME z12 sink dialog

DLG 5c
"""
INSERT counter dialog

z12_counter_4
"""
NAME z12 counter m 3 dialog

DLG 5d
"""
INSERT counter dialog

z12_counter_5
"""
NAME z12 counter 1 r dialog

DLG 5e
"""
INSERT cabinet dialog

z12_cabinet_1
"""
NAME z12 tv stand l dialog

DLG 5f
INSERT it's the back of a tv(p)'wait, what's that shoved into one of the ports ?'(p){wvy}...searching...{wvy}(p)you found a melted chocolate and peanut butter candy.
NAME z12 tv stand m dialog

DLG 5g
INSERT dialog about the apartment not being too dirty
NAME z12 dust enter room dialog

DLG 5h
INSERT turned off tv description
NAME z12 tv dialog

DLG 5i
"""
INSERT dialog about being full of packing peanuts

z12_box
"""
NAME z12 box dialog

DLG 5j
INSERT dialog about the restaurant at A2
NAME a main guy on floor 1 dialog

DLG 5k
INSERT dialog about eating at A2 after they smoke a bit
NAME a main guy sitting smoking dialog

DLG 5l
"""
INSERT dialog about digging in the dirt to find the key to A3

"""
NAME a main plant base dialog

DLG 5m
INSERT dialog about finding chicken bones 
NAME a main chicken bone dust dialog

DLG 5n
"""
INSERT dialog about finding bottle cap

"""
NAME a main dust bottle cap dialog

DLG 5o
INSERT dialog about finding 1 muni
NAME dust 4 muni dialog

DLG 5p
INSERT dialog about finding rat bones
NAME trash pile with rat bones dialog

DLG 5q
{property locked true}the door is locked...
NAME locked exit 23

DLG 5r
{property locked true}the door is locked...
NAME locked exit 24

DLG 5s
"""
INSERT dialog about finding debit card in the trash pile

foundMuniCard
"""
NAME trash pile with debit card dialog

DLG 5t
INSERT sink dialog
NAME a11 sink dialog

DLG 5u
neighbor: "{shk}help{shk}"
NAME item 2p dialog

DLG 5v
INSERT counter dialog last counter a13
NAME a13 last counter dialog

DLG 5w
INSERT dialog about finding 2 muni
NAME a sec dust bl muni dialog

DLG 5x
you enter Z8
NAME exit narration 24

DLG 5y
to the secondary Z hall
NAME exit narration 25

DLG 5z
"""
you found human remains

foundDeadParent
"""
NAME pile of trash skull dialog

DLG 6a
"""
INSERT counter dialog

a2_counter_1
"""
NAME a2 counter l 2 dialog

DLG 6b
a2_counter_2
NAME a2 counter m 5 dialog

DLG 6c
a2_counter_3
NAME a2 counter m 6 dialog

DLG 6d
a2_counter_4
NAME a2 counter m 7 dialog

DLG 6e
a2_counter_5
NAME a2 counter r 2 dialog

DLG 6f
a2_counter_6
NAME a2 counter l 1 dialog

DLG 6g
a2_counter_7
NAME a2 counter m 1 dialog

DLG 6h
a2_counter_8
NAME a2 counter m 2 dialog

DLG 6i
a2_counter_9
NAME a2 counter m 3 dialog

DLG 6j
a2_counter_10
NAME a2 counter m 4 dialog

DLG 6k
a2_counter_11
NAME a2 counter r 1 dialog

DLG 6l
a2_fryer
NAME a2 counter fryer 1 dialog

DLG 6m
a2_stove
NAME a2 counter oven stove dialog

DLG 6n
"""
INSERT cabinet dialog

z12_cabinet_2
"""
NAME z12 tv stand r dialog

DLG 6o
"""
{
  - {item "1"} >= 1 ?
    {property locked false}
    The key opens the door!
  - else ?
    {property locked true}
    The door is locked...
}
"""
NAME locked exit 25

VAR hasBlueHat
0

VAR hasSweatshirt
0

VAR hasBackpack
0

VAR hasEmptyBottle1
0

VAR canLeaveFirstRoom
0

VAR a13_chest1
0

VAR muni
3

VAR turmeric
0

VAR cumin
0

VAR chili
0

VAR fenugreek
0

VAR cannabis
0

VAR a13_counter_1
0

VAR aMain_plant
0

VAR aMain_smoker
0

VAR aMain_sitter
0

VAR aSec_kid
0

VAR aSec_drunk
0

VAR aSec_ratPerson
0

VAR a13_bed
0

VAR a3_counter_1
0

VAR a3_sink
0

VAR a3_counter_2
0

VAR a3_counter_3
0

VAR a3_counter_4
0

VAR a3_box_1
0

VAR a3_box_2
0

VAR a3_box_3
0

VAR a3_box_4
0

VAR a3_box_5
0

VAR a3_box_6
0

VAR a3_key
0

VAR a3_password
0

VAR a3_unlocked
0

VAR hasGun
0

VAR zMain_smoker
0

VAR z6_lock
0

VAR a14_counter_1
0

VAR a14_counter_2
0

VAR a14_counter_3
0

VAR a14_counter_4
0

VAR a14_counter_5
0

VAR a14_counter_6
0

VAR a14_counter_7
0

VAR a14_counter_8
0

VAR a14_counter_9
0

VAR a14_cabinet_1
0

VAR a14_cabinet_2
0

VAR a8_counter_1
0

VAR a8_counter_2
0

VAR a8_counter_3
0

VAR a8_counter_4
0

VAR a8_counter_5
0

VAR a8_counter_6
0

VAR a8_counter_7
0

VAR a8_counter_8
0

VAR a8_counter_9
0

VAR a8_box_1
0

VAR a8_box_2
0

VAR a8_box_3
0

VAR a8_box_4
0

VAR a8_chest
0

VAR a8_password
0

VAR a8_unlocked
0

VAR a8_rat
0

VAR gotBit
0

VAR sinceBit
0

VAR health
40

VAR ratsCollected
0

VAR bandages
0

VAR a8_sawBigRat
0

VAR a13_leftHome
0

VAR a8_cassette
0

VAR a11_cat_1
0

VAR a11_cat_2
0

VAR a11_cat_3
0

VAR a11_child
0

VAR a11_toyCar
0

VAR a11_counter_1
0

VAR a11_counter_2
0

VAR a5_counter_1
0

VAR a5_counter_2
0

VAR a5_counter_3
0

VAR a5_counter_4
0

VAR a5_showSequence
0

VAR a2_counter_1
0

VAR a2_counter_2
0

VAR a2_counter_3
0

VAR a2_counter_4
0

VAR a2_counter_5
0

VAR a2_counter_6
0

VAR a2_counter_7
0

VAR a2_counter_8
0

VAR a2_counter_9
0

VAR a2_counter_10
0

VAR a2_counter_11
0

VAR a2_fryer
0

VAR a2_stove
0

VAR a2_kiosk
0

VAR a2_muniCardGuy
0

VAR foundDeadParent
0

VAR foundMuniCard
0

VAR a11_key
0

VAR z12_counter_1
0

VAR z12_counter_2
0

VAR z12_counter_3
0

VAR z12_counter_4
0

VAR z12_counter_5
0

VAR z12_box
0

VAR z12_cabinet_1
0

VAR z12_cabinet_2
0

VAR food
0

VAR hasPhone
0


</script>

<style>
html {
	margin: 0;
	padding: 0;
}

body {
	margin: 0;
	padding: 0;
	overflow: hidden;
	background: #000;
}

#game {
	background: black;
	width: 100vw;
	max-width: 100vh;
	margin: auto;
	display: block;
	touch-action: none; /* fixing touch-input errors in chrome */

	/* sharp pixel edges */
	/* https://caniuse.com/#search=image-render */
	-ms-interpolation-mode: nearest-neighbor; /* IE */
	image-rendering: -moz-crisp-edges; /* FF 6.0+ */
	image-rendering: pixelated; /* Chrome, Safari */
}

</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
	var gameCanvas = document.getElementById("game");
	var gameData = document.getElementById("exportedGameData").text.slice(1);
	var defaultFontData = document.getElementById(defaultFontName).text.slice(1)
	attachCanvas(gameCanvas);
	loadGame(gameData, defaultFontData);
}
</script>

<script>
/* logging */
var DebugLogCategory = {
	system: false,
	bitsy : false,
	editor : false,
};

var isLoggingVerbose = false;

/* input */
var key = {
	left : 37,
	right : 39,
	up : 38,
	down : 40,
	space : 32,
	enter : 13,
	w : 87,
	a : 65,
	s : 83,
	d : 68,
	r : 82,
	shift : 16,
	ctrl : 17,
	alt : 18,
	cmd : 224
};

var InputManager = function() {
	var self = this;

	var pressed;
	var ignored;
	var touchState;

	var isRestartComboPressed = false;

	var SwipeDir = {
		None : -1,
		Up : 0,
		Down : 1,
		Left : 2,
		Right : 3,
	};

	function resetAll() {
		isRestartComboPressed = false;

		pressed = {};
		ignored = {};

		touchState = {
			isDown : false,
			startX : 0,
			startY : 0,
			curX : 0,
			curY : 0,
			swipeDistance : 30,
			swipeDirection : SwipeDir.None,
			tapReleased : false
		};
	}

	resetAll();

	function stopWindowScrolling(e) {
		if(e.keyCode == key.left || e.keyCode == key.right || e.keyCode == key.up || e.keyCode == key.down || !isPlayerEmbeddedInEditor)
			e.preventDefault();
	}

	function isRestartCombo(e) {
		return (e.keyCode === key.r && (e.getModifierState("Control")|| e.getModifierState("Meta")));
	}

	function eventIsModifier(event) {
		return (event.keyCode == key.shift || event.keyCode == key.ctrl || event.keyCode == key.alt || event.keyCode == key.cmd);
	}

	function isModifierKeyDown() {
		return ( self.isKeyDown(key.shift) || self.isKeyDown(key.ctrl) || self.isKeyDown(key.alt) || self.isKeyDown(key.cmd) );
	}

	this.ignoreHeldKeys = function() {
		for (var key in pressed) {
			if (pressed[key]) { // only ignore keys that are actually held
				ignored[key] = true;
				// bitsyLog("IGNORE -- " + key, "system");
			}
		}
	}

	this.onkeydown = function(event) {
		// bitsyLog("KEYDOWN -- " + event.keyCode, "system");

		stopWindowScrolling(event);

		isRestartComboPressed = isRestartCombo(event);

		// Special keys being held down can interfere with keyup events and lock movement
		// so just don't collect input when they're held
		{
			if (isModifierKeyDown()) {
				return;
			}

			if (eventIsModifier(event)) {
				resetAll();
			}
		}

		if (ignored[event.keyCode]) {
			return;
		}

		pressed[event.keyCode] = true;
		ignored[event.keyCode] = false;
	}

	this.onkeyup = function(event) {
		// bitsyLog("KEYUP -- " + event.keyCode, "system");
		pressed[event.keyCode] = false;
		ignored[event.keyCode] = false;
	}

	this.ontouchstart = function(event) {
		event.preventDefault();

		if( event.changedTouches.length > 0 ) {
			touchState.isDown = true;

			touchState.startX = touchState.curX = event.changedTouches[0].clientX;
			touchState.startY = touchState.curY = event.changedTouches[0].clientY;

			touchState.swipeDirection = SwipeDir.None;
		}
	}

	this.ontouchmove = function(event) {
		event.preventDefault();

		if( touchState.isDown && event.changedTouches.length > 0 ) {
			touchState.curX = event.changedTouches[0].clientX;
			touchState.curY = event.changedTouches[0].clientY;

			var prevDirection = touchState.swipeDirection;

			if( touchState.curX - touchState.startX <= -touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Left;
			}
			else if( touchState.curX - touchState.startX >= touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Right;
			}
			else if( touchState.curY - touchState.startY <= -touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Up;
			}
			else if( touchState.curY - touchState.startY >= touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Down;
			}

			if( touchState.swipeDirection != prevDirection ) {
				// reset center so changing directions is easier
				touchState.startX = touchState.curX;
				touchState.startY = touchState.curY;
			}
		}
	}

	this.ontouchend = function(event) {
		event.preventDefault();

		touchState.isDown = false;

		if( touchState.swipeDirection == SwipeDir.None ) {
			// tap!
			touchState.tapReleased = true;
		}

		touchState.swipeDirection = SwipeDir.None;
	}

	this.isKeyDown = function(keyCode) {
		return pressed[keyCode] != null && pressed[keyCode] == true && (ignored[keyCode] == null || ignored[keyCode] == false);
	}

	this.anyKeyDown = function() {
		var anyKey = false;

		for (var key in pressed) {
			if (pressed[key] && (ignored[key] == null || ignored[key] == false) &&
				!(key === key.up || key === key.down || key === key.left || key === key.right) &&
				!(key === key.w || key === key.s || key === key.a || key === key.d)) {
				// detected that a key other than the d-pad keys are down!
				anyKey = true;
			}
		}

		return anyKey;
	}

	this.isRestartComboPressed = function() {
		return isRestartComboPressed;
	}

	this.swipeLeft = function() {
		return touchState.swipeDirection == SwipeDir.Left;
	}

	this.swipeRight = function() {
		return touchState.swipeDirection == SwipeDir.Right;
	}

	this.swipeUp = function() {
		return touchState.swipeDirection == SwipeDir.Up;
	}

	this.swipeDown = function() {
		return touchState.swipeDirection == SwipeDir.Down;
	}

	this.isTapReleased = function() {
		return touchState.tapReleased;
	}

	this.resetTapReleased = function() {
		touchState.tapReleased = false;
	}

	this.onblur = function() {
		// bitsyLog("~~~ BLUR ~~", "system");
		resetAll();
	}

	this.resetAll = resetAll;
}

var input = new InputManager();

/* events */
var onLoadFunction = null;
var onQuitFunction = null;
var onUpdateFunction = null;
var updateInterval = null;

function initSystem() {
	// temp hack for the editor? unless??
	drawingBuffers[screenBufferId] = createDrawingBuffer(128, 128, scale);
	drawingBuffers[textboxBufferId] = createDrawingBuffer(0, 0, textScale);
}

function loadGame(gameData, defaultFontData) {
	drawingBuffers[screenBufferId] = createDrawingBuffer(128, 128, scale);
	drawingBuffers[textboxBufferId] = createDrawingBuffer(0, 0, textScale);

	document.addEventListener('keydown', input.onkeydown);
	document.addEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.addEventListener('touchstart', input.ontouchstart, {passive:false});
		canvas.addEventListener('touchmove', input.ontouchmove, {passive:false});
		canvas.addEventListener('touchend', input.ontouchend, {passive:false});
	}
	else {
		// creates a 'touchTrigger' element that covers the entire screen and can universally have touch event listeners added w/o issue.

		// we're checking for existing touchTriggers both at game start and end, so it's slightly redundant.
		var existingTouchTrigger = document.querySelector('#touchTrigger');

		if (existingTouchTrigger === null) {
			var touchTrigger = document.createElement("div");
			touchTrigger.setAttribute("id","touchTrigger");

			// afaik css in js is necessary here to force a fullscreen element
			touchTrigger.setAttribute(
				"style","position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden;"
			);

			document.body.appendChild(touchTrigger);

			touchTrigger.addEventListener('touchstart', input.ontouchstart);
			touchTrigger.addEventListener('touchmove', input.ontouchmove);
			touchTrigger.addEventListener('touchend', input.ontouchend);
		}
	}

	window.onblur = input.onblur;

	if (onLoadFunction) {
		// todo : is this the right place to supply default font data?
		onLoadFunction(gameData, defaultFontData);
	}

	updateInterval = setInterval(
		function() {
			if (onUpdateFunction) {
				onUpdateFunction();
			}

			renderGame();

			input.resetTapReleased();

			if (bitsyGetButton(5)) {
				if (confirm("Restart the game?")) {
					input.resetAll();
					reset_cur_game();
				}

				return;
			}
		},
		16);
}

function renderGame() {
	// bitsyLog("render game mode=" + curGraphicsMode, "system");

	bitsyLog(systemPalette.length, "system");

	var startIndex = curGraphicsMode === 0 ? screenBufferId : (drawingBuffers.length - 1);

	for (var i = startIndex; i >= 0; i--) {
		var buffer = drawingBuffers[i];
		if (buffer && buffer.canvas === null) {
			bitsyLog("render buffer " + i, "system");
			renderDrawingBuffer(i, buffer);
		}
	}

	// show screen buffer
	var screenBuffer = drawingBuffers[screenBufferId];
	ctx.drawImage(
		screenBuffer.canvas,
		0,
		0,
		screenBuffer.width * screenBuffer.scale,
		screenBuffer.height * screenBuffer.scale);
}

function quitGame() {
	document.removeEventListener('keydown', input.onkeydown);
	document.removeEventListener('keyup', input.onkeyup);

	if (isPlayerEmbeddedInEditor) {
		canvas.removeEventListener('touchstart', input.ontouchstart);
		canvas.removeEventListener('touchmove', input.ontouchmove);
		canvas.removeEventListener('touchend', input.ontouchend);
	}
	else {
		//check for touchTrigger and removes it

		var existingTouchTrigger = document.querySelector('#touchTrigger');

		if (existingTouchTrigger !== null) {
			existingTouchTrigger.removeEventListener('touchstart', input.ontouchstart);
			existingTouchTrigger.removeEventListener('touchmove', input.ontouchmove);
			existingTouchTrigger.removeEventListener('touchend', input.ontouchend);

			existingTouchTrigger.parentElement.removeChild(existingTouchTrigger);
		}
	}

	window.onblur = null;

	if (onQuitFunction) {
		onQuitFunction();
	}

	clearInterval(updateInterval);
}

/* graphics */
var canvas;
var ctx;

var textScale = 2; // todo : move tile scale into here too?

var curGraphicsMode = 0;
var systemPalette = [[0, 0, 0]];
var curBufferId = -1; // note: -1 is invalid
var drawingBuffers = [];

var screenBufferId = 0;
var textboxBufferId = 1;
var tileStartBufferId = 2;
var nextBufferId = tileStartBufferId;

var DrawingInstruction = {
	Pixel : 0,
	Tile : 1,
	Clear : 2,
	Textbox : 3,
	PixelIndex : 4,
};

function attachCanvas(c) {
	canvas = c;
	canvas.width = width * scale;
	canvas.height = width * scale;
	ctx = canvas.getContext("2d");
}

function createDrawingBuffer(width, height, scale) {
	var buffer = {
		width : width,
		height : height,
		scale : scale, // logical-pixel to display-pixel scale
		instructions : [], // drawing instructions
		canvas : null,
	}

	return buffer;
}

function renderPixelInstruction(bufferId, buffer, paletteIndex, x, y) {
	if (bufferId === screenBufferId && curGraphicsMode != 0) {
		return;
	}

	if (!systemPalette[paletteIndex]) {
		// bitsyLog("invalid index " + paletteIndex + " @ " + x + "," + y, "system");
		return;
	}

	var color = systemPalette[paletteIndex];

	if (buffer.imageData) {
		for (var sy = 0; sy < buffer.scale; sy++) {
			for (var sx = 0; sx < buffer.scale; sx++) {
				var pixelIndex = (((y * buffer.scale) + sy) * buffer.width * buffer.scale * 4) + (((x * buffer.scale) + sx) * 4);

				buffer.imageData.data[pixelIndex + 0] = color[0];
				buffer.imageData.data[pixelIndex + 1] = color[1];
				buffer.imageData.data[pixelIndex + 2] = color[2];
				buffer.imageData.data[pixelIndex + 3] = 255;
			}
		}
	}
	else {
		var bufferContext = buffer.canvas.getContext("2d");
		bufferContext.fillStyle = "rgb(" + color[0] + "," + color[1] + "," + color[2] + ")";
		bufferContext.fillRect(x * buffer.scale, y * buffer.scale, buffer.scale, buffer.scale);
	}
}

function renderPixelAtIndexInstruction(bufferId, buffer, paletteIndex, index) {
	if (bufferId === screenBufferId && curGraphicsMode != 0) {
		return;
	}

	if (!systemPalette[paletteIndex]) {
		// bitsyLog("invalid index " + paletteIndex + " @ " + x + "," + y, "system");
		return;
	}

	var color = systemPalette[paletteIndex];

	if (buffer.imageData) {
		for (var sy = 0; sy < buffer.scale; sy++) {
			for (var sx = 0; sx < buffer.scale; sx++) {
				var pixelIndex = index * 4;

				buffer.imageData.data[pixelIndex + 0] = color[0];
				buffer.imageData.data[pixelIndex + 1] = color[1];
				buffer.imageData.data[pixelIndex + 2] = color[2];
				buffer.imageData.data[pixelIndex + 3] = 255;
			}
		}
	}
	else {
		var y = Math.floor(index / buffer.width);
		var x = index - (y * buffer.width);
		var bufferContext = buffer.canvas.getContext("2d");
		bufferContext.fillStyle = "rgb(" + color[0] + "," + color[1] + "," + color[2] + ")";
		bufferContext.fillRect(x * buffer.scale, y * buffer.scale, buffer.scale, buffer.scale);
	}
}

function renderTileInstruction(bufferId, buffer, tileId, x, y) {
	if (bufferId != screenBufferId || curGraphicsMode != 1) {
		return;
	}

	if (!drawingBuffers[tileId]) {
		return;
	}

	var tileBuffer = drawingBuffers[tileId];

	var bufferContext = buffer.canvas.getContext("2d");
	bufferContext.drawImage(
		tileBuffer.canvas,
		x * tilesize * buffer.scale,
		y * tilesize * buffer.scale,
		tilesize * buffer.scale,
		tilesize * buffer.scale);
}

function renderClearInstruction(bufferId, buffer, paletteIndex) {
	var color = systemPalette[paletteIndex];
	var bufferContext = buffer.canvas.getContext("2d");
	bufferContext.fillStyle = "rgb(" + color[0] + "," + color[1] + "," + color[2] + ")";
	bufferContext.fillRect(0, 0, buffer.canvas.width, buffer.canvas.height);
}

function renderTextboxInstruction(bufferId, buffer, x, y) {
	if (bufferId != screenBufferId || curGraphicsMode != 1) {
		return;
	}

	if (!drawingBuffers[textboxBufferId]) {
		return;
	}

	var textboxBuffer = drawingBuffers[textboxBufferId];

	var bufferContext = buffer.canvas.getContext("2d");
	bufferContext.drawImage(
		textboxBuffer.canvas,
		x * buffer.scale,
		y * buffer.scale,
		textboxBuffer.canvas.width,
		textboxBuffer.canvas.height);
}

function renderDrawingBuffer(bufferId, buffer) {
	// bitsyLog("render buffer " + bufferId, "system");

	// if (bufferId === 0) {
	// 	bitsyLog("instructions " + buffer.instructions.length, "system");
	// }

	buffer.canvas = document.createElement("canvas");
	buffer.canvas.width = buffer.width * buffer.scale;
	buffer.canvas.height = buffer.height * buffer.scale;

	for (var i = 0; i < buffer.instructions.length; i++) {
		var instruction = buffer.instructions[i];
		switch (instruction.type) {
			case DrawingInstruction.Pixel:
				renderPixelInstruction(bufferId, buffer, instruction.id, instruction.x, instruction.y);
				break;
			case DrawingInstruction.Tile:
				renderTileInstruction(bufferId, buffer, instruction.id, instruction.x, instruction.y);
				break;
			case DrawingInstruction.Clear:
				renderClearInstruction(bufferId, buffer, instruction.id);
				break;
			case DrawingInstruction.Textbox:
				renderTextboxInstruction(bufferId, buffer, instruction.x, instruction.y);
				break;
			case DrawingInstruction.PixelIndex:
				renderPixelAtIndexInstruction(bufferId, buffer, instruction.id, instruction.index);
		}
	}

	if (buffer.imageData) {
		var bufferContext = buffer.canvas.getContext("2d");
		bufferContext.putImageData(buffer.imageData, 0, 0);
	}
}

function invalidateDrawingBuffer(buffer) {
	buffer.canvas = null;
}

function hackForEditor_GetImageFromTileId(tileId) {
	if (tileId === undefined || !drawingBuffers[tileId]) {
		bitsyLog("editor hack::invalid tile id!", "system");
		return null;
	}

	// force render the buffer if it hasn't been
	if (drawingBuffers[tileId].canvas === null) {
		renderDrawingBuffer(tileId, drawingBuffers[tileId]);
	}

	return drawingBuffers[tileId].canvas;
}

/* ==== */
function bitsyLog(message, category) {
	if (!category) {
		category = "bitsy";
	}

	var summary = category + "::" + message;

	if (DebugLogCategory[category] === true) {
		if (isLoggingVerbose) {
			console.group(summary);

			console.dir(message);

			console.group("stack")
			console.trace();
			console.groupEnd();

			console.groupEnd();
		}
		else {
			console.log(summary);
		}
	}
}

function bitsyGetButton(buttonCode) {
	switch (buttonCode) {
		case 0: // UP
			return (input.isKeyDown(key.up) || input.isKeyDown(key.w) || input.swipeUp());
		case 1: // DOWN
			return (input.isKeyDown(key.down) || input.isKeyDown(key.s) || input.swipeDown());
		case 2: // LEFT
			return (input.isKeyDown(key.left) || input.isKeyDown(key.a) || input.swipeLeft());
		case 3: // RIGHT
			return ((input.isKeyDown(key.right) || input.isKeyDown(key.d) || input.swipeRight()));
		case 4: // OK (equivalent to "any key" on the keyboard or "tap" on touch screen)
			return (input.anyKeyDown() || input.isTapReleased());
		case 5: // MENU / RESTART (restart the game: "ctrl+r" on keyboard, no touch control yet)
			return input.isRestartComboPressed();
	}

	return false;
}

// two modes (0 == pixel mode, 1 == tile mode)
function bitsySetGraphicsMode(mode) {
	curGraphicsMode = mode;

	var screenBuffer = drawingBuffers[screenBufferId];
	if (curGraphicsMode === 0) {
		screenBuffer.imageData = ctx.createImageData(screenBuffer.width * screenBuffer.scale, screenBuffer.height * screenBuffer.scale);
	}
	else {
		screenBuffer.imageData = undefined;
	}
}

function bitsySetColor(paletteIndex, r, g, b) {
	systemPalette[paletteIndex] = [r, g, b];

	// invalidate all drawing buffers
	for (var i = 0; i < drawingBuffers.length; i++) {
		if (drawingBuffers[i]) {
			invalidateDrawingBuffer(drawingBuffers[i]);
		}
	}
}

function bitsyResetColors() {
	systemPalette = [[0, 0, 0]];

	// invalidate all drawing buffers
	for (var i = 0; i < drawingBuffers.length; i++) {
		if (drawingBuffers[i]) {
			invalidateDrawingBuffer(drawingBuffers[i]);
		}
	}
}

function bitsyDrawBegin(bufferId) {
	curBufferId = bufferId;
	var buffer = drawingBuffers[curBufferId];
	invalidateDrawingBuffer(buffer);
}

function bitsyDrawEnd() {
	curBufferId = -1;
}

function bitsyDrawPixel(paletteIndex, x, y) {
	if (curBufferId === screenBufferId && curGraphicsMode != 0) {
		return;
	}

	// avoid trying to render out-of-bounds colors
	if (paletteIndex >= systemPalette.length) {
		bitsyLog("invalid color! " + paletteIndex, "system");
		paletteIndex = systemPalette.length - 1;
	}

	var buffer = drawingBuffers[curBufferId];
	buffer.instructions.push({ type: DrawingInstruction.Pixel, id: paletteIndex, x: x, y: y, });
}

// todo : name is too long :(
// todo : merge with function above?
function bitsySetPixelAtIndex(paletteIndex, pixelIndex) {
	if (curBufferId === screenBufferId && curGraphicsMode != 0) {
		return;
	}

	// avoid trying to render out-of-bounds colors
	if (paletteIndex >= systemPalette.length) {
		bitsyLog("invalid color! " + paletteIndex, "system");
		paletteIndex = systemPalette.length - 1;
	}

	var buffer = drawingBuffers[curBufferId];
	buffer.instructions.push({ type: DrawingInstruction.PixelIndex, id: paletteIndex, index: pixelIndex, });
}

function bitsyDrawTile(tileId, x, y) {
	if (curBufferId != screenBufferId || curGraphicsMode != 1) {
		return;
	}

	var buffer = drawingBuffers[curBufferId];
	buffer.instructions.push({ type: DrawingInstruction.Tile, id: tileId, x: x, y: y, });
}

function bitsyDrawTextbox(x, y) {
	if (curBufferId != screenBufferId || curGraphicsMode != 1) {
		return;
	}

	var buffer = drawingBuffers[curBufferId];
	buffer.instructions.push({ type: DrawingInstruction.Textbox, x: x, y: y, });
}

function bitsyClear(paletteIndex) {
	// avoid trying to render out-of-bounds colors
	if (paletteIndex >= systemPalette.length) {
		paletteIndex = systemPalette.length - 1;
	}

	drawingBuffers[curBufferId].instructions = []; // reset instructions
	drawingBuffers[curBufferId].instructions.push({ type: DrawingInstruction.Clear, id: paletteIndex, });
}

// allocates a tile buffer and returns the ID
function bitsyAddTile() {
	var tileBufferId = nextBufferId;
	nextBufferId++;

	drawingBuffers[tileBufferId] = createDrawingBuffer(tilesize, tilesize, scale);

	return tileBufferId;
}

// clears all tile buffers
function bitsyResetTiles() {
	bitsyLog("RESET TILES", "system");
	// bitsyLog(drawingBuffers, "system");
	// bitsyLog(tileStartBufferId, "system");
	// bitsyLog(drawingBuffers.slice(tileStartBufferId), "system");
	drawingBuffers = drawingBuffers.slice(0, tileStartBufferId);
}

// note: width and height are in text scale pixels
function bitsySetTextboxSize(w, h) {
	drawingBuffers[textboxBufferId] = createDrawingBuffer(w, h, textScale);
}

function bitsyOnLoad(fn) {
	onLoadFunction = fn;
}

function bitsyOnQuit(fn) {
	onQuitFunction = fn;
}

function bitsyOnUpdate(fn) {
	onUpdateFunction = fn;
}
</script>

<script>
var TransitionManager = function() {
	var transitionStart = null;
	var transitionEnd = null;

	var isTransitioning = false;
	var transitionTime = 0; // milliseconds
	var minStepTime = 125; // cap the frame rate
	var curStep = 0;

	this.BeginTransition = function(startRoom, startX, startY, endRoom, endX, endY, effectName) {
		bitsyLog("--- START ROOM TRANSITION ---");

		curEffect = effectName;

		var tmpRoom = player().room;
		var tmpX = player().x;
		var tmpY = player().y;

		if (transitionEffects[curEffect].showPlayerStart) {
			player().room = startRoom;
			player().x = startX;
			player().y = startY;
		}
		else {
			player().room = "_transition_none"; // kind of hacky!!
		}

		var startRoomPixels = createRoomPixelBuffer(room[startRoom]);
		var startPalette = getPal(room[startRoom].pal);
		var startImage = new PostProcessImage(startRoomPixels);
		transitionStart = new TransitionInfo(startImage, startPalette, startX, startY);

		if (transitionEffects[curEffect].showPlayerEnd) {
			player().room = endRoom;
			player().x = endX;
			player().y = endY;
		}
		else {
			player().room = "_transition_none";
		}

		var endRoomPixels = createRoomPixelBuffer(room[endRoom]);
		var endPalette = getPal(room[endRoom].pal);
		var endImage = new PostProcessImage(endRoomPixels);
		transitionEnd = new TransitionInfo(endImage, endPalette, endX, endY);

		isTransitioning = true;
		transitionTime = 0;
		curStep = 0;

		player().room = tmpRoom;
		player().x = tmpX;
		player().y = tmpY;
	}

	this.UpdateTransition = function(dt) {
		if (!isTransitioning) {
			return;
		}

		// todo : shouldn't need to set this every frame!
		bitsySetGraphicsMode(0);

		transitionTime += dt;

		var maxStep = transitionEffects[curEffect].stepCount;

		if (transitionTime >= minStepTime) {
			curStep++;

			var step = curStep;
			bitsyLog("transition step " + step);

			if (transitionEffects[curEffect].paletteEffectFunc) {
				var colors = transitionEffects[curEffect].paletteEffectFunc(transitionStart, transitionEnd, (step / maxStep));
				updatePaletteWithTileColors(colors);
			}

			bitsyDrawBegin(0);
			for (var y = 0; y < 128; y++) {
				for (var x = 0; x < 128; x++) {
					var color = transitionEffects[curEffect].pixelEffectFunc(transitionStart, transitionEnd, x, y, (step / maxStep));
					bitsyDrawPixel(color, x, y);
				}
			}
			bitsyDrawEnd();

			transitionTime = 0;
		}

		if (curStep >= (maxStep - 1)) {
			isTransitioning = false;
			transitionTime = 0;
			transitionStart = null;
			transitionEnd = null;
			curStep = 0;

			if (transitionCompleteCallback != null) {
				transitionCompleteCallback();
			}
			transitionCompleteCallback = null;
		}
	}

	this.IsTransitionActive = function() {
		return isTransitioning;
	}

	// todo : should this be part of the constructor?
	var transitionCompleteCallback = null;
	this.OnTransitionComplete = function(callback) {
		if (isTransitioning) { // TODO : safety check necessary?
			transitionCompleteCallback = callback;
		}
	}

	var transitionEffects = {};
	var curEffect = "none";
	this.RegisterTransitionEffect = function(name, effect) {
		transitionEffects[name] = effect;
	}

	this.RegisterTransitionEffect("none", {
		showPlayerStart : false,
		showPlayerEnd : false,
		paletteEffectFunc : function() {},
		pixelEffectFunc : function() {},
	});

	this.RegisterTransitionEffect("fade_w", { // TODO : have it linger on full white briefly?
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 6,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			var colors = [];

			if (delta < 0.5) {
				delta = delta / 0.5;

				for (var i = 0; i < start.Palette.length; i++) {
					colors.push(lerpColor(start.Palette[i], [255, 255, 255], delta));
				}
			}
			else {
				delta = ((delta - 0.5) / 0.5);

				for (var i = 0; i < end.Palette.length; i++) {
					colors.push(lerpColor([255, 255, 255], end.Palette[i], delta));
				}
			}

			return colors;
		},
	});

	this.RegisterTransitionEffect("fade_b", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 6,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			var colors = [];

			if (delta < 0.5) {
				delta = delta / 0.5;

				for (var i = 0; i < start.Palette.length; i++) {
					colors.push(lerpColor(start.Palette[i], [0, 0, 0], delta));
				}
			}
			else {
				delta = ((delta - 0.5) / 0.5);

				for (var i = 0; i < end.Palette.length; i++) {
					colors.push(lerpColor([0, 0, 0], end.Palette[i], delta));
				}
			}

			return colors;
		},
	});

	this.RegisterTransitionEffect("wave", {
		showPlayerStart : true,
		showPlayerEnd : true,
		stepCount : 12,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var waveDelta = delta < 0.5 ? delta / 0.5 : 1 - ((delta - 0.5) / 0.5);

			var offset = (pixelY + (waveDelta * waveDelta * 0.2 * start.Image.Height));
			var freq = 4;
			var size = 2 + (14 * waveDelta);
			pixelX += Math.floor(Math.sin(offset / freq) * size);

			if (pixelX < 0) {
				pixelX += start.Image.Width;
			}
			else if (pixelX >= start.Image.Width) {
				pixelX -= start.Image.Width;
			}

			var curImage = delta < 0.5 ? start.Image : end.Image;
			return curImage.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			return delta < 0.5 ? start.Palette : end.Palette;
		},
	});

	this.RegisterTransitionEffect("tunnel", {
		showPlayerStart : true,
		showPlayerEnd : true,
		stepCount : 12,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			if (delta <= 0.4) {
				var tunnelDelta = 1 - (delta / 0.4);

				var xDist = start.PlayerCenter.x - pixelX;
				var yDist = start.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > start.Image.Width * tunnelDelta) {
					return 0;
				}
				else {
					return start.Image.GetPixel(pixelX, pixelY);
				}
			}
			else if (delta <= 0.6) {
				return 0;
			}
			else {
				var tunnelDelta = (delta - 0.6) / 0.4;

				var xDist = end.PlayerCenter.x - pixelX;
				var yDist = end.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > end.Image.Width * tunnelDelta) {
					return 0;
				}
				else {
					return end.Image.GetPixel(pixelX, pixelY);
				}
			}
		},
		paletteEffectFunc : function(start, end, delta) {
			return delta < 0.5 ? start.Palette : end.Palette;
		},
	});

	function lerpPalettes(start, end, delta) {
		var colors = [];

		var maxLength = (start.Palette.length > end.Palette.length) ?
			start.Palette.length : end.Palette.length;

		for (var i = 0; i < maxLength; i++) {
			if (i < start.Palette.length && i < end.Palette.length) {
				colors.push(lerpColor(start.Palette[i], end.Palette[i], delta));
			}
			else if (i < start.Palette.length) {
				colors.push(lerpColor(
					start.Palette[i],
					end.Palette[end.Palette.length - 1],
					delta));
			}
			else if (i < end.Palette.length) {
				colors.push(lerpColor(
					start.Palette[start.Palette.length - 1],
					end.Palette[i],
					delta));
			}
		}

		return colors;
	}

	this.RegisterTransitionEffect("slide_u", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			if (slidePixelY >= 0) {
				return start.Image.GetPixel(pixelX, slidePixelY);
			}
			else {
				slidePixelY += start.Image.Height;
				return end.Image.GetPixel(pixelX, slidePixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_d", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			if (slidePixelY < start.Image.Height) {
				return start.Image.GetPixel(pixelX, slidePixelY);
			}
			else {
				slidePixelY -= start.Image.Height;
				return end.Image.GetPixel(pixelX, slidePixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_l", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			if (slidePixelX >= 0) {
				return start.Image.GetPixel(slidePixelX, pixelY);
			}
			else {
				slidePixelX += start.Image.Width;
				return end.Image.GetPixel(slidePixelX, pixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_r", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			if (slidePixelX < start.Image.Width) {
				return start.Image.GetPixel(slidePixelX, pixelY);
			}
			else {
				slidePixelX -= start.Image.Width;
				return end.Image.GetPixel(slidePixelX, pixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	// todo : move to Renderer()?
	function createRoomPixelBuffer(room) {
		var pixelBuffer = [];

		for (var i = 0; i < 128 * 128; i++) {
			pixelBuffer.push(tileColorStartIndex);
		}

		var drawTileInPixelBuffer = function(sourceData, frameIndex, colorIndex, tx, ty, pixelBuffer) {
			var frameData = sourceData[frameIndex];

			for (var y = 0; y < tilesize; y++) {
				for (var x = 0; x < tilesize; x++) {
					var color = tileColorStartIndex + (frameData[y][x] === 1 ? colorIndex : 0);
					pixelBuffer[(((ty * tilesize) + y) * 128) + ((tx * tilesize) + x)] = color;
				}
			}
		}

		//draw tiles
		for (i in room.tilemap) {
			for (j in room.tilemap[i]) {
				var id = room.tilemap[i][j];
				var x = parseInt(j);
				var y = parseInt(i);

				if (id != "0" && tile[id] != null) {
					drawTileInPixelBuffer(
						renderer.GetDrawingSource(tile[id].drw),
						tile[id].animation.frameIndex,
						tile[id].col,
						x,
						y,
						pixelBuffer);
				}
			}
		}

		//draw items
		for (var i = 0; i < room.items.length; i++) {
			var itm = room.items[i];
			drawTileInPixelBuffer(
				renderer.GetDrawingSource(item[itm.id].drw),
				item[itm.id].animation.frameIndex,
				item[itm.id].col,
				itm.x,
				itm.y,
				pixelBuffer);
		}

		//draw sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.room === room.id) {
				drawTileInPixelBuffer(
					renderer.GetDrawingSource(spr.drw),
					spr.animation.frameIndex,
					spr.col,
					spr.x,
					spr.y,
					pixelBuffer);
			}
		}

		return pixelBuffer;
	}

	function lerpColor(colorA, colorB, t) {
		return [
			colorA[0] + ((colorB[0] - colorA[0]) * t),
			colorA[1] + ((colorB[1] - colorA[1]) * t),
			colorA[2] + ((colorB[2] - colorA[2]) * t),
		];
	};
}; // TransitionManager()

// todo : is this wrapper still useful?
var PostProcessImage = function(imageData) {
	this.Width = 128;
	this.Height = 128;

	this.GetPixel = function(x, y) {
		return imageData[(y * 128) + x];
	};

	this.GetData = function() {
		return imageData;
	};
};

var TransitionInfo = function(image, palette, playerX, playerY) {
	this.Image = image;
	this.Palette = palette;
	this.PlayerTilePos = { x: playerX, y: playerY };
	this.PlayerCenter = { x: Math.floor((playerX * tilesize) + (tilesize / 2)), y: Math.floor((playerY * tilesize) + (tilesize / 2)) };
};
</script>

<script>
/*
TODO:
- can I simplify this more now that I've removed the external resources stuff?
*/

function FontManager(packagedFontNames) {

var self = this;

var fontExtension = ".bitsyfont";
this.GetExtension = function() {
	return fontExtension;
}

// place to store font data
var fontResources = {};

// load fonts from the editor
if (packagedFontNames != undefined && packagedFontNames != null && packagedFontNames.length > 0
		&& Resources != undefined && Resources != null) {

	for (var i = 0; i < packagedFontNames.length; i++) {
		var filename = packagedFontNames[i];
		fontResources[filename] = Resources[filename];
	}
}

// manually add resource
this.AddResource = function(filename, fontdata) {
	fontResources[filename] = fontdata;
}

this.ContainsResource = function(filename) {
	return fontResources[filename] != null;
}

function GetData(fontName) {
	return fontResources[fontName + fontExtension];
}
this.GetData = GetData;

function Create(fontData) {
	return new Font(fontData);
}
this.Create = Create;

this.Get = function(fontName) {
	var fontData = self.GetData(fontName);
	return self.Create(fontData);
}

function Font(fontData) {
	var name = "unknown";
	var width = 6; // default size so if you have NO font or an invalid font it displays boxes
	var height = 8;
	var chardata = {};

	// create invalid char data at default size in case the font is missing
	var invalidCharData = {};
	updateInvalidCharData();

	this.getName = function() {
		return name;
	}

	this.getData = function() {
		return chardata;
	}

	this.getWidth = function() {
		return width;
	}

	this.getHeight = function() {
		return height;
	}

	this.hasChar = function(char) {
		var codepoint = char.charCodeAt(0);
		return chardata[codepoint] != null;
	}

	this.getChar = function(char) {

		var codepoint = char.charCodeAt(0);

		if (chardata[codepoint] != null) {
			return chardata[codepoint];
		}
		else {
			return invalidCharData;
		}
	}

	this.allCharCodes = function() {
		var codeList = [];
		for (var code in chardata) {
			codeList.push(code);
		}
		return codeList;
	}

	function createCharData() {
		return { 
			width: width,
			height: height,
			offset: {
				x: 0,
				y: 0
			},
			spacing: width,
			data: [],
		};
	}

	function updateInvalidCharData() {
		invalidCharData = createCharData();
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				if (x < width-1 && y < height-1) {
					invalidCharData.data.push(1);
				}
				else {
					invalidCharData.data.push(0);
				}
			}
		}
	}

	function parseFont(fontData) {
		if (fontData == null) {
			return;
		}

		var lines = fontData.split("\n");

		var isReadingChar = false;
		var isReadingCharProperties = false;
		var curCharLineCount = 0;
		var curCharCode = 0;

		for (var i = 0; i < lines.length; i++) {
			var line = lines[i];

			if (line[0] === "#") {
				continue; // skip comment lines
			}

			if (!isReadingChar) {
				// READING NON CHARACTER DATA LINE
				var args = line.split(" ");
				if (args[0] == "FONT") {
					name = args[1];
				}
				else if (args[0] == "SIZE") {
					width = parseInt(args[1]);
					height = parseInt(args[2]);
				}
				else if (args[0] == "CHAR") {
					isReadingChar = true;
					isReadingCharProperties = true;

					curCharLineCount = 0;
					curCharCode = parseInt(args[1]);
					chardata[curCharCode] = createCharData();
				}
			}
			else {
				// CHAR PROPERTIES
				if (isReadingCharProperties) {
					var args = line.split(" ");
					if (args[0].indexOf("CHAR_") == 0) { // Sub-properties start with "CHAR_"
						if (args[0] == "CHAR_SIZE") {
							// Custom character size - overrides the default character size for the font
							chardata[curCharCode].width = parseInt(args[1]);
							chardata[curCharCode].height = parseInt(args[2]);
							chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first
						}
						else if (args[0] == "CHAR_OFFSET") {
							// Character offset - shift the origin of the character on the X or Y axis
							chardata[curCharCode].offset.x = parseInt(args[1]);
							chardata[curCharCode].offset.y = parseInt(args[2]);
						}
						else if (args[0] == "CHAR_SPACING") {
							// Character spacing:
							// specify total horizontal space taken up by the character
							// lets chars take up more or less space on a line than its bitmap does
							chardata[curCharCode].spacing = parseInt(args[1]);
						}
					}
					else {
						isReadingCharProperties = false;
					}
				}

				// CHAR DATA
				if (!isReadingCharProperties) {
					// READING CHARACTER DATA LINE
					for (var j = 0; j < chardata[curCharCode].width; j++)
					{
						chardata[curCharCode].data.push( parseInt(line[j]) );
					}

					curCharLineCount++;
					if (curCharLineCount >= height) {
						isReadingChar = false;
					}
				}
			}
		}

		// re-init invalid character box at the actual font size once it's loaded
		updateInvalidCharData();
	}

	parseFont(fontData);
}

} // FontManager
</script>

<script>
function Script() {

this.CreateInterpreter = function() {
	return new Interpreter();
};

this.CreateUtils = function() {
	return new Utils();
};

var Interpreter = function() {
	var env = new Environment();
	var parser = new Parser( env );

	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };

	// TODO -- maybe this should return a string instead othe actual script??
	this.Compile = function(scriptName, scriptStr) {
		// bitsyLog("COMPILE");
		var script = parser.Parse(scriptStr, scriptName);
		env.SetScript(scriptName, script);
	}
	this.Run = function(scriptName, exitHandler, objectContext) { // Runs pre-compiled script
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = env.GetScript(scriptName);

		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.Interpret = function(scriptStr, exitHandler, objectContext) { // Compiles and runs code immediately
		// bitsyLog("INTERPRET");
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = parser.Parse(scriptStr, "anonymous");
		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.HasScript = function(name) { return env.HasScript(name); };

	this.ResetEnvironment = function() {
		env = new Environment();
		parser = new Parser( env );
	}

	this.Parse = function(scriptStr, rootId) { // parses a script but doesn't save it
		return parser.Parse(scriptStr, rootId);
	}

	// TODO : add back in if needed later...
	// this.CompatibilityParse = function(scriptStr, compatibilityFlags) {
	// 	env.compatibilityFlags = compatibilityFlags;

	// 	var result = parser.Parse(scriptStr);

	// 	delete env.compatibilityFlags;

	// 	return result;
	// }

	this.Eval = function(scriptTree, exitHandler) { // runs a script stored externally
		var localEnv = new LocalEnvironment(env); // TODO : does this need an object context?
		scriptTree.Eval(
			localEnv,
			function(result) {
				OnScriptReturn(result, exitHandler);
			});
	}

	function OnScriptReturn(result, exitHandler) {
		if (exitHandler != null) {
			exitHandler(result);
		}
	}

	this.CreateExpression = function(expStr) {
		return parser.CreateExpression(expStr);
	}

	this.SetVariable = function(name,value,useHandler) {
		env.SetVariable(name,value,useHandler);
	}

	this.DeleteVariable = function(name,useHandler) {
		env.DeleteVariable(name,useHandler);
	}
	this.HasVariable = function(name) {
		return env.HasVariable(name);
	}

	this.SetOnVariableChangeHandler = function(onVariableChange) {
		env.SetOnVariableChangeHandler(onVariableChange);
	}
	this.GetVariableNames = function() {
		return env.GetVariableNames();
	}
	this.GetVariable = function(name) {
		return env.GetVariable(name);
	}

	function DebugVisualizeScriptTree(scriptTree) {
		var printVisitor = {
			Visit : function(node,depth) {
				bitsyLog("-".repeat(depth) + "- " + node.ToString());
			},
		};

		scriptTree.VisitAll( printVisitor );
	}

	this.DebugVisualizeScriptTree = DebugVisualizeScriptTree;

	this.DebugVisualizeScript = function(scriptName) {
		DebugVisualizeScriptTree(env.GetScript(scriptName));
	}
}


var Utils = function() {
	// for editor ui
	this.CreateDialogBlock = function(children,doIndentFirstLine) {
		if (doIndentFirstLine === undefined) {
			doIndentFirstLine = true;
		}

		var block = new DialogBlockNode(doIndentFirstLine);

		for (var i = 0; i < children.length; i++) {
			block.AddChild(children[i]);
		}
		return block;
	}

	this.CreateOptionBlock = function() {
		var block = new DialogBlockNode(false);
		block.AddChild(new FuncNode("print", [new LiteralNode(" ")]));
		return block;
	}

	this.CreateItemConditionPair = function() {
		var itemFunc = this.CreateFunctionBlock("item", ["0"]);
		var condition = new ExpNode("==", itemFunc, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("print", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateVariableConditionPair = function() {
		var varNode = this.CreateVariableNode("a");
		var condition = new ExpNode("==", varNode, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("print", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateDefaultConditionPair = function() {
		var condition = this.CreateElseNode();
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("print", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateEmptyPrintFunc = function() {
		return new FuncNode("print", [new LiteralNode("...")]);
	}

	this.CreateFunctionBlock = function(name, initParamValues) {
		var parameters = [];
		for (var i = 0; i < initParamValues.length; i++) {
			parameters.push(new LiteralNode(initParamValues[i]));
		}

		var node = new FuncNode(name, parameters);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	// TODO : rename ParseStringToLiteralNode?
	this.CreateLiteralNode = function(str) {
		if (str === "true") {
			return new LiteralNode(true);
		}
		else if (str === "false") {
			return new LiteralNode(false);
		}
		else if (!isNaN(parseFloat(str))) {
			return new LiteralNode(parseFloat(str));
		}
		else {
			return new LiteralNode(str);
		}
	}

	this.CreateVariableNode = function(variableName) {
		return new VarNode(variableName);
	}

	this.CreatePropertyNode = function(propertyName, literalValue) {
		var varNode = new VarNode(propertyName);
		var valNode = new LiteralNode(literalValue);
		var node = new FuncNode("property", [varNode, valNode]);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	this.CreateElseNode = function() {
		return new ElseNode();
	}

	this.CreateStringLiteralNode = function(str) {
		return new LiteralNode(str);
	}

	// TODO : need to split up code & dialog blocks :|
	this.CreateCodeBlock = function() {
		return new CodeBlockNode();
	}

	this.ChangeSequenceType = function(oldSequence, type) {
		if(type === "sequence") {
			return new SequenceNode(oldSequence.children);
		}
		else if(type === "cycle") {
			return new CycleNode(oldSequence.children);
		}
		else if(type === "shuffle") {
			return new ShuffleNode(oldSequence.children);
		}
		return oldSequence;
	}

	this.CreateSequenceBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var sequence = new SequenceNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateCycleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var sequence = new CycleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateShuffleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var sequence = new ShuffleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateIfBlock = function() {
		var leftNode = new CodeBlockNode();
		leftNode.AddChild( new FuncNode("item", [new LiteralNode("0")] ) );
		var rightNode = new LiteralNode( 1 );
		var condition1 = new ExpNode("==", leftNode, rightNode );

		var condition2 = new ElseNode();

		var result1 = new DialogBlockNode();
		result1.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var result2 = new DialogBlockNode();
		result2.AddChild(new FuncNode("print", [new LiteralNode("...")]));

		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );
		var block = new CodeBlockNode();
		block.AddChild( ifNode );
		return block;
	}

	this.ReadDialogScript = function(lines, i) {
		var scriptStr = "";
		if (lines[i] === Sym.DialogOpen) {
			scriptStr += lines[i] + "\n";
			i++;
			while(lines[i] != Sym.DialogClose) {
				scriptStr += lines[i] + "\n";
				i++;
			}
			scriptStr += lines[i];
			i++;
		}
		else {
			scriptStr += lines[i];
			i++;
		}
		return { script:scriptStr, index:i };
	}

	// TODO this.ReadCodeScript (reads through code open and close symbols), and this.ReadScript

	this.EnsureDialogBlockFormat = function(dialogStr) {
		// TODO -- what if it's already enclosed in dialog symbols??
		if(dialogStr.indexOf('\n') > -1) {
			dialogStr = Sym.DialogOpen + "\n" + dialogStr + "\n" + Sym.DialogClose;
		}
		return dialogStr;
	}

	this.RemoveDialogBlockFormat = function(source) {
		var sourceLines = source.split("\n");
		var dialogStr = "";
		if(sourceLines[0] === Sym.DialogOpen) {
			// multi line
			var i = 1;
			while (i < sourceLines.length && sourceLines[i] != Sym.DialogClose) {
				dialogStr += sourceLines[i] + (sourceLines[i+1] != Sym.DialogClose ? '\n' : '');
				i++;
			}
		}
		else {
			// single line
			dialogStr = source;
		}
		return dialogStr;
	}

	this.SerializeDialogNodeList = function(nodeList) {
		var tempBlock = new DialogBlockNode(false);
		 // set children directly to avoid breaking the parenting chain for this temp operation
		tempBlock.children = nodeList;
		return tempBlock.Serialize();
	}

	this.GetOperatorList = function() {
		return [Sym.Set].concat(Sym.Operators);
	}

	this.IsInlineCode = function(node) {
		return isInlineCode(node);
	}
}


/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?
function deprecatedFunc(environment,parameters,onReturn) {
	bitsyLog("BITSY SCRIPT WARNING: Tried to use deprecated function");
	onReturn(null);
}

function printFunc(environment, parameters, onReturn) {
	if (parameters[0] != undefined && parameters[0] != null) {
		var textStr = "" + parameters[0];
		environment.GetDialogBuffer().AddText(textStr);
		environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
	}
	else {
		onReturn(null);
	}
}

function linebreakFunc(environment, parameters, onReturn) {
	// bitsyLog("LINEBREAK FUNC");
	environment.GetDialogBuffer().AddLinebreak();
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function pagebreakFunc(environment, parameters, onReturn) {
	environment.GetDialogBuffer().AddPagebreak(function() { onReturn(null); });
}

function printDrawingFunc(environment, parameters, onReturn) {
	var drawingId = parameters[0];
	environment.GetDialogBuffer().AddDrawing(drawingId);
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function printSpriteFunc(environment,parameters,onReturn) {
	var spriteId = parameters[0];
	if(names.sprite[spriteId] != undefined) spriteId = names.sprite[spriteId]; // id is actually a name
	var drawingId = sprite[spriteId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printTileFunc(environment,parameters,onReturn) {
	var tileId = parameters[0];
	if(names.tile[tileId] != undefined) tileId = names.tile[tileId]; // id is actually a name
	var drawingId = tile[tileId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printItemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];
	if(names.item[itemId] != undefined) itemId = names.item[itemId]; // id is actually a name
	var drawingId = item[itemId].drw;
	printDrawingFunc(environment, [drawingId], onReturn);
}

function printFontFunc(environment, parameters, onReturn) {
	var allCharacters = "";
	var font = fontManager.Get(fontName);
	var codeList = font.allCharCodes();
	for (var i = 0; i < codeList.length; i++) {
		allCharacters += String.fromCharCode(codeList[i]) + " ";
	}
	printFunc(environment, [allCharacters], onReturn);
}

function itemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];

	if (names.item[itemId] != undefined) {
		// id is actually a name
		itemId = names.item[itemId];
	}

	var curItemCount = player().inventory[itemId] ? player().inventory[itemId] : 0;

	if (parameters.length > 1) {
		// TODO : is it a good idea to force inventory to be >= 0?
		player().inventory[itemId] = Math.max(0, parseInt(parameters[1]));
		curItemCount = player().inventory[itemId];

		if (onInventoryChanged != null) {
			onInventoryChanged(itemId);
		}
	}

	onReturn(curItemCount);
}

function addOrRemoveTextEffect(environment,name) {
	if( environment.GetDialogBuffer().HasTextEffect(name) )
		environment.GetDialogBuffer().RemoveTextEffect(name);
	else
		environment.GetDialogBuffer().AddTextEffect(name);
}

function rainbowFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"rbw");
	onReturn(null);
}

// TODO : should the colors use a parameter instead of special names?
function color1Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr1");
	onReturn(null);
}

function color2Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr2");
	onReturn(null);
}

function color3Func(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"clr3");
	onReturn(null);
}

function wavyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"wvy");
	onReturn(null);
}

function shakyFunc(environment,parameters,onReturn) {
	addOrRemoveTextEffect(environment,"shk");
	onReturn(null);
}

function propertyFunc(environment, parameters, onReturn) {
	var outValue = null;

	if (parameters.length > 0 && parameters[0]) {
		var propertyName = parameters[0];

		if (environment.HasProperty(propertyName)) {
			// TODO : in a future update I can handle the case of initializing a new property
			// after which we can move this block outside the HasProperty check
			if (parameters.length > 1) {
				var inValue = parameters[1];
				environment.SetProperty(propertyName, inValue);
			}

			outValue = environment.GetProperty(propertyName);
		}
	}

	bitsyLog("PROPERTY! " + propertyName + " " + outValue);

	onReturn(outValue);
}

function endFunc(environment,parameters,onReturn) {
	isEnding = true;
	isNarrating = true;
	dialogRenderer.SetCentered(true);
	onReturn(null);
}

function exitFunc(environment,parameters,onReturn) {
	var destRoom = parameters[0];

	if (names.room[destRoom] != undefined) {
		// it's a name, not an id! (note: these could cause trouble if people names things weird)
		destRoom = names.room[destRoom];
	}

	var destX = parseInt(parameters[1]);
	var destY = parseInt(parameters[2]);

	if (parameters.length >= 4) {
		var transitionEffect = parameters[3];

		transition.BeginTransition(
			player().room,
			player().x,
			player().y,
			destRoom,
			destX,
			destY,
			transitionEffect);
		transition.UpdateTransition(0);
	}

	var movePlayerAndResumeScript = function() {
		// update world state
		player().room = destRoom;
		player().x = destX;
		player().y = destY;
		curRoom = destRoom;

		// update game state
		initRoom(curRoom);

		// resume dialog script
		onReturn(null);
	};

	// TODO : this doesn't play nice with pagebreak because it thinks the dialog is finished!
	if (transition.IsTransitionActive()) {
		transition.OnTransitionComplete(movePlayerAndResumeScript);
	}
	else {
		movePlayerAndResumeScript();
	}
}

/* BUILT-IN OPERATORS */
function setExp(environment,left,right,onReturn) {
	// bitsyLog("SET " + left.name);

	if(left.type != "variable") {
		// not a variable! return null and hope for the best D:
		onReturn( null );
		return;
	}

	right.Eval(environment,function(rVal) {
		environment.SetVariable( left.name, rVal );
		// bitsyLog("VAL " + environment.GetVariable( left.name ) );
		left.Eval(environment,function(lVal) {
			onReturn( lVal );
		});
	});
}
function equalExp(environment,left,right,onReturn) {
	// bitsyLog("EVAL EQUAL");
	// bitsyLog(left);
	// bitsyLog(right);
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal === rVal );
		});
	});
}
function greaterExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal > rVal );
		});
	});
}
function lessExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal < rVal );
		});
	});
}
function greaterEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal >= rVal );
		});
	});
}
function lessEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal <= rVal );
		});
	});
}
function multExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal * rVal );
		});
	});
}
function divExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal / rVal );
		});
	});
}
function addExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal + rVal );
		});
	});
}
function subExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal - rVal );
		});
	});
}

/* ENVIRONMENT */
var Environment = function() {
	var dialogBuffer = null;
	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };
	this.GetDialogBuffer = function() { return dialogBuffer; };

	var functionMap = {};
	functionMap["print"] = printFunc;
	functionMap["say"] = printFunc;
	functionMap["br"] = linebreakFunc;
	functionMap["item"] = itemFunc;
	functionMap["rbw"] = rainbowFunc;
	functionMap["clr1"] = color1Func;
	functionMap["clr2"] = color2Func;
	functionMap["clr3"] = color3Func;
	functionMap["wvy"] = wavyFunc;
	functionMap["shk"] = shakyFunc;
	functionMap["printSprite"] = printSpriteFunc;
	functionMap["printTile"] = printTileFunc;
	functionMap["printItem"] = printItemFunc;
	functionMap["debugOnlyPrintFont"] = printFontFunc; // DEBUG ONLY
	functionMap["end"] = endFunc;
	functionMap["exit"] = exitFunc;
	functionMap["pg"] = pagebreakFunc;
	functionMap["property"] = propertyFunc;

	this.HasFunction = function(name) { return functionMap[name] != undefined; };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		functionMap[name](env, parameters, onReturn);
	}

	var variableMap = {};

	this.HasVariable = function(name) { return variableMap[name] != undefined; };
	this.GetVariable = function(name) { return variableMap[name]; };
	this.SetVariable = function(name,value,useHandler) {
		// bitsyLog("SET VARIABLE " + name + " = " + value);
		if(useHandler === undefined) useHandler = true;
		variableMap[name] = value;
		if(onVariableChangeHandler != null && useHandler){
			onVariableChangeHandler(name);
		}
	};
	this.DeleteVariable = function(name,useHandler) {
		if(useHandler === undefined) useHandler = true;
		if(variableMap[name] != undefined) {
			variableMap.delete(name);
			if(onVariableChangeHandler != null && useHandler) {
				onVariableChangeHandler(name);
			}
		}
	};

	var operatorMap = {};
	operatorMap["="] = setExp;
	operatorMap["=="] = equalExp;
	operatorMap[">"] = greaterExp;
	operatorMap["<"] = lessExp;
	operatorMap[">="] = greaterEqExp;
	operatorMap["<="] = lessEqExp;
	operatorMap["*"] = multExp;
	operatorMap["/"] = divExp;
	operatorMap["+"] = addExp;
	operatorMap["-"] = subExp;

	this.HasOperator = function(sym) { return operatorMap[sym] != undefined; };
	this.EvalOperator = function(sym,left,right,onReturn) {
		operatorMap[ sym ]( this, left, right, onReturn );
	}

	var scriptMap = {};
	this.HasScript = function(name) { return scriptMap[name] != undefined; };
	this.GetScript = function(name) { return scriptMap[name]; };
	this.SetScript = function(name,script) { scriptMap[name] = script; };

	var onVariableChangeHandler = null;
	this.SetOnVariableChangeHandler = function(onVariableChange) {
		onVariableChangeHandler = onVariableChange;
	}
	this.GetVariableNames = function() {
		var variableNames = [];

		for (var key in variableMap) {
			variableNames.push(key);
		}

		return variableNames;
	}
}

// Local environment for a single run of a script: knows local context
var LocalEnvironment = function(parentEnvironment) {
	// this.SetDialogBuffer // not allowed in local environment?
	this.GetDialogBuffer = function() { return parentEnvironment.GetDialogBuffer(); };

	this.HasFunction = function(name) { return parentEnvironment.HasFunction(name); };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalFunction(name,parameters,onReturn,env);
	}

	this.HasVariable = function(name) { return parentEnvironment.HasVariable(name); };
	this.GetVariable = function(name) { return parentEnvironment.GetVariable(name); };
	this.SetVariable = function(name,value,useHandler) { parentEnvironment.SetVariable(name,value,useHandler); };
	// this.DeleteVariable // not needed in local environment?

	this.HasOperator = function(sym) { return parentEnvironment.HasOperator(sym); };
	this.EvalOperator = function(sym,left,right,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalOperator(sym,left,right,onReturn,env);
	};

	// TODO : I don't *think* any of this is required by the local environment
	// this.HasScript
	// this.GetScript
	// this.SetScript

	// TODO : pretty sure these debug methods aren't required by the local environment either
	// this.SetOnVariableChangeHandler
	// this.GetVariableNames

	/* Here's where specific local context data goes:
	 * this includes access to the object running the script
	 * and any properties it may have (so far only "locked")
	 */

	// The local environment knows what object called it -- currently only used to access properties
	var curObject = null;
	this.HasObject = function() { return curObject != undefined && curObject != null; }
	this.SetObject = function(object) { curObject = object; }
	this.GetObject = function() { return curObject; }

	// accessors for properties of the object that's running the script
	this.HasProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return true;
		}
		else {
			return false;
		}
	};
	this.GetProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return curObject.property[name]; // TODO : should these be getters and setters instead?
		}
		else {
			return null;
		}
	};
	this.SetProperty = function(name, value) {
		// NOTE : for now, we need to gaurd against creating new properties
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			curObject.property[name] = value;
		}
	};
}

function leadingWhitespace(depth) {
	var str = "";
	for(var i = 0; i < depth; i++) {
		str += "  "; // two spaces per indent
	}
	// bitsyLog("WHITESPACE " + depth + " ::" + str + "::");
	return str;
}

/* NODES */
var TreeRelationship = function() {
	this.parent = null;
	this.children = [];

	this.AddChild = function(node) {
		this.children.push(node);
		node.parent = this;
	};

	this.AddChildren = function(nodeList) {
		for (var i = 0; i < nodeList.length; i++) {
			this.AddChild(nodeList[i]);
		}
	};

	this.SetChildren = function(nodeList) {
		this.children = [];
		this.AddChildren(nodeList);
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.rootId = null; // for debugging
	this.GetId = function() {
		// bitsyLog(this);
		if (this.rootId != null) {
			return this.rootId;
		}
		else if (this.parent != null) {
			var parentId = this.parent.GetId();
			if (parentId != null) {
				return parentId + "_" + this.parent.children.indexOf(this);
			}
		}
		else {
			return null;
		}
	}
}

var DialogBlockNode = function(doIndentFirstLine) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "dialog_block";

	this.Eval = function(environment, onReturn) {
		// bitsyLog("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// bitsyLog(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// bitsyLog("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	if (doIndentFirstLine === undefined) {
		doIndentFirstLine = true; // This is just for serialization
	}

	this.Serialize = function(depth) {
		if (depth === undefined) {
			depth = 0;
		}

		var str = "";
		var lastNode = null;

		for (var i = 0; i < this.children.length; i++) {

			var curNode = this.children[i];

			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);
			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === "function" && lastNode.name === "br");

			if (shouldIndentFirstLine || shouldIndentAfterLinebreak) {
				str += leadingWhitespace(depth);
			}

			str += curNode.Serialize(depth);

			lastNode = curNode;
		}

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

var CodeBlockNode = function() {
	Object.assign( this, new TreeRelationship() );
	this.type = "code_block";

	this.Eval = function(environment, onReturn) {
		// bitsyLog("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// bitsyLog(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// bitsyLog("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	this.Serialize = function(depth) {
		if(depth === undefined) {
			depth = 0;
		}

		// bitsyLog("SERIALIZE BLOCK!!!");
		// bitsyLog(depth);
		// bitsyLog(doIndentFirstLine);

		var str = "{"; // todo: increase scope of Sym?

		// TODO : do code blocks ever have more than one child anymore????
		for (var i = 0; i < this.children.length; i++) {
			var curNode = this.children[i];
			str += curNode.Serialize(depth);
		}

		str += "}";

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function isInlineCode(node) {
	return isTextEffectBlock(node) || isUndefinedBlock(node) || isMultilineListBlock(node);
}

function isUndefinedBlock(node) {
	return node.type === "code_block" && node.children.length > 0 && node.children[0].type === "undefined";
}

var textEffectBlockNames = ["clr1", "clr2", "clr3", "wvy", "shk", "rbw", "printSprite", "printItem", "printTile", "print", "say", "br"];
function isTextEffectBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0 && node.children[0].type === "function") {
			var func = node.children[0];
			return textEffectBlockNames.indexOf(func.name) != -1;
		}
	}
	return false;
}

var listBlockTypes = ["sequence", "cycle", "shuffle", "if"];
function isMultilineListBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0) {
			var child = node.children[0];
			return listBlockTypes.indexOf(child.type) != -1;
		}
	}
	return false;
}

// for round-tripping undefined code through the parser (useful for hacks!)
var UndefinedNode = function(sourceStr) {
	Object.assign(this, new TreeRelationship());
	this.type = "undefined";
	this.source = sourceStr;

	this.Eval = function(environment,onReturn) {
		addOrRemoveTextEffect(environment, "_debug_highlight");
		printFunc(environment, ["{" + sourceStr + "}"], function() {
			onReturn(null);
		});
		addOrRemoveTextEffect(environment, "_debug_highlight");
	}

	this.Serialize = function(depth) {
		return this.source;
	}

	this.ToString = function() {
		return "undefined" + " " + this.GetId();
	}
}

var FuncNode = function(name,args) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "function";
	this.name = name;
	this.args = args;

	this.Eval = function(environment,onReturn) {
		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var self = this; // hack to deal with scope (TODO : move up higher?)

		var argumentValues = [];
		var i = 0;

		function evalArgs(args, done) {
			// TODO : really hacky way to make we get the first
			// symbol's NAME instead of its variable value
			// if we are trying to do something with a property
			if (self.name === "property" && i === 0 && i < args.length) {
				if (args[i].type === "variable") {
					argumentValues.push(args[i].name);
					i++;
				}
				else {
					// first argument for a property MUST be a variable symbol
					// -- so skip everything if it's not!
					i = args.length;
				}
			}

			if (i < args.length) {
				// Evaluate each argument
				args[i].Eval(
					environment,
					function(val) {
						argumentValues.push(val);
						i++;
						evalArgs(args, done);
					});
			}
			else {
				done();
			}
		};

		evalArgs(
			this.args,
			function() {
				if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
					events.Raise("script_node_exit", { id: self.GetId() });
				}

				environment.EvalFunction(self.name, argumentValues, onReturn);
			});
	}

	this.Serialize = function(depth) {
		var isDialogBlock = this.parent.type === "dialog_block";
		if (isDialogBlock && this.name === "print") {
			// TODO this could cause problems with "real" print functions
			return this.args[0].value; // first argument should be the text of the {print} func
		}
		else if (isDialogBlock && this.name === "br") {
			return "\n";
		}
		else {
			var str = "";
			str += this.name;
			for(var i = 0; i < this.args.length; i++) {
				str += " ";
				str += this.args[i].Serialize(depth);
			}
			return str;
		}
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

var LiteralNode = function(value) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "literal";
	this.value = value;

	this.Eval = function(environment,onReturn) {
		onReturn(this.value);
	}

	this.Serialize = function(depth) {
		var str = "";

		if (this.value === null) {
			return str;
		}

		if (typeof this.value === "string") {
			str += '"';
		}

		str += this.value;

		if (typeof this.value === "string") {
			str += '"';
		}

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.value + " " + this.GetId();
	};
}

var VarNode = function(name) {
	Object.assign( this, new TreeRelationship() );
	// Object.assign( this, new Runnable() );
	this.type = "variable";
	this.name = name;

	this.Eval = function(environment,onReturn) {
		// bitsyLog("EVAL " + this.name + " " + environment.HasVariable(this.name) + " " + environment.GetVariable(this.name));
		if( environment.HasVariable(this.name) )
			onReturn( environment.GetVariable( this.name ) );
		else
			onReturn(null); // not a valid variable -- return null and hope that's ok
	} // TODO: might want to store nodes in the variableMap instead of values???

	this.Serialize = function(depth) {
		var str = "" + this.name;
		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

var ExpNode = function(operator, left, right) {
	Object.assign( this, new TreeRelationship() );
	this.type = "operator";
	this.operator = operator;
	this.left = left;
	this.right = right;

	this.Eval = function(environment,onReturn) {
		// bitsyLog("EVAL " + this.operator);
		var self = this; // hack to deal with scope
		environment.EvalOperator( this.operator, this.left, this.right, 
			function(val){
				// bitsyLog("EVAL EXP " + self.operator + " " + val);
				onReturn(val);
			} );
		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods
	}

	this.Serialize = function(depth) {
		var isNegativeNumber = this.operator === "-" && this.left.type === "literal" && this.left.value === null;

		if (!isNegativeNumber) {
			var str = "";

			if (this.left != undefined && this.left != null) {
				str += this.left.Serialize(depth) + " ";
			}

			str += this.operator;

			if (this.right != undefined && this.right != null) {
				str += " " + this.right.Serialize(depth);
			}

			return str;
		}
		else {
			return this.operator + this.right.Serialize(depth); // hacky but seems to work
		}
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		if(this.left != null)
			this.left.VisitAll( visitor, depth + 1 );
		if(this.right != null)
			this.right.VisitAll( visitor, depth + 1 );
	};

	this.ToString = function() {
		return this.type + " " + this.operator + " " + this.GetId();
	};
}

var SequenceBase = function() {
	this.Serialize = function(depth) {
		var str = "";
		str += this.type + "\n";
		for (var i = 0; i < this.children.length; i++) {
			str += leadingWhitespace(depth + 1) + Sym.List + " ";
			str += this.children[i].Serialize(depth + 2);
			str += "\n";
		}
		str += leadingWhitespace(depth);
		return str;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

var SequenceNode = function(options) {
	Object.assign(this, new TreeRelationship());
	Object.assign(this, new SequenceBase());
	this.type = "sequence";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// bitsyLog("SEQUENCE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
	}
}

var CycleNode = function(options) {
	Object.assign(this, new TreeRelationship());
	Object.assign(this, new SequenceBase());
	this.type = "cycle";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// bitsyLog("CYCLE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
		else {
			index = 0;
		}
	}
}

var ShuffleNode = function(options) {
	Object.assign(this, new TreeRelationship());
	Object.assign(this, new SequenceBase());
	this.type = "shuffle";
	this.AddChildren(options);

	var optionsShuffled = [];
	function shuffle(options) {
		optionsShuffled = [];
		var optionsUnshuffled = options.slice();
		while (optionsUnshuffled.length > 0) {
			var i = Math.floor(Math.random() * optionsUnshuffled.length);
			optionsShuffled.push(optionsUnshuffled.splice(i,1)[0]);
		}
	}
	shuffle(this.children);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		optionsShuffled[index].Eval(environment, onReturn);
		
		index++;
		if (index >= this.children.length) {
			shuffle(this.children);
			index = 0;
		}
	}
}

// TODO : rename? ConditionalNode?
var IfNode = function(conditions, results, isSingleLine) {
	Object.assign(this, new TreeRelationship());
	this.type = "if";

	for (var i = 0; i < conditions.length; i++) {
		this.AddChild(new ConditionPairNode(conditions[i], results[i]));
	}

	var self = this;
	this.Eval = function(environment, onReturn) {
		// bitsyLog("EVAL IF");
		var i = 0;
		function TestCondition() {
			self.children[i].Eval(environment, function(result) {
				if (result.conditionValue == true) {
					onReturn(result.resultValue);
				}
				else if (i+1 < self.children.length) {
					i++;
					TestCondition();
				}
				else {
					onReturn(null);
				}
			});
		};
		TestCondition();
	}

	if (isSingleLine === undefined) {
		isSingleLine = false; // This is just for serialization
	}

	this.Serialize = function(depth) {
		var str = "";
		if(isSingleLine) {
			// HACKY - should I even keep this mode???
			str += this.children[0].children[0].Serialize() + " ? " + this.children[0].children[1].Serialize();
			if (this.children.length > 1 && this.children[1].children[0].type === Sym.Else) {
				str += " " + Sym.ElseExp + " " + this.children[1].children[1].Serialize();
			}
		}
		else {
			str += "\n";
			for (var i = 0; i < this.children.length; i++) {
				str += this.children[i].Serialize(depth);
			}
			str += leadingWhitespace(depth);
		}
		return str;
	}

	this.IsSingleLine = function() {
		return isSingleLine;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	};

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

var ConditionPairNode = function(condition, result) {
	Object.assign(this, new TreeRelationship());

	this.type = "condition_pair";

	this.AddChild(condition);
	this.AddChild(result);

	var self = this;

	this.Eval = function(environment, onReturn) {
		self.children[0].Eval(environment, function(conditionSuccess) {
			if (conditionSuccess) {
				self.children[1].Eval(environment, function(resultValue) {
					onReturn({ conditionValue:true, resultValue:resultValue });
				});
			}
			else {
				onReturn({ conditionValue:false });
			}
		});
	}

	this.Serialize = function(depth) {
		var str = "";
		str += leadingWhitespace(depth + 1);
		str += Sym.List + " " + this.children[0].Serialize(depth) + " " + Sym.ConditionEnd + Sym.Linebreak;
		str += this.children[1].Serialize(depth + 2) + Sym.Linebreak;
		return str;
	}

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	}
}

var ElseNode = function() {
	Object.assign( this, new TreeRelationship() );
	this.type = Sym.Else;

	this.Eval = function(environment, onReturn) {
		onReturn(true);
	}

	this.Serialize = function() {
		return Sym.Else;
	}

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

var Sym = {
	DialogOpen : '"""',
	DialogClose : '"""',
	CodeOpen : "{",
	CodeClose : "}",
	Linebreak : "\n", // just call it "break" ?
	Separator : ":",
	List : "-",
	String : '"',
	ConditionEnd : "?",
	Else : "else",
	ElseExp : ":", // special shorthand for expressions (deprecate?)
	Set : "=",
	Operators : ["==", ">=", "<=", ">", "<", "-", "+", "/", "*"], // operators need to be in reverse order of precedence
};

var Parser = function(env) {
	var environment = env;

	this.Parse = function(scriptStr, rootId) {
		var rootNode = new DialogBlockNode();
		rootNode.rootId = rootId;
		var state = new ParserState(rootNode, scriptStr);

		bitsyLog(scriptStr);
		bitsyLog(state.Source());

		if (state.MatchAhead(Sym.DialogOpen)) {
			// multi-line dialog block
			var dialogStr = state.ConsumeBlock(Sym.DialogOpen + Sym.Linebreak, Sym.Linebreak + Sym.DialogClose);
			rootNode = new DialogBlockNode();
			rootNode.rootId = rootId; // hacky!!
			state = new ParserState(rootNode, dialogStr);
			state = ParseDialog(state);
		}
		else {
			// single-line dialog block
			state = ParseDialog(state);
		}

		return state.rootNode;
	};

	var ParserState = function( rootNode, str ) {
		this.rootNode = rootNode;
		this.curNode = this.rootNode;

		var sourceStr = str;
		var i = 0;
		this.Index = function() { return i; };
		this.Count = function() { return sourceStr.length; };
		this.Done = function() { return i >= sourceStr.length; };
		this.Char = function() { return sourceStr[i]; };
		this.Step = function(n) { if(n===undefined) n=1; i += n; };
		this.MatchAhead = function(str) {
			// bitsyLog(str);
			str = "" + str; // hack to turn single chars into strings
			// bitsyLog(str);
			// bitsyLog(str.length);
			for (var j = 0; j < str.length; j++) {
				if (i + j >= sourceStr.length) {
					return false;
				}
				else if (str[j] != sourceStr[i+j]) {
					return false;
				}
			}
			return true;
		}
		this.Peak = function(end) {
			var str = "";
			var j = i;
			// bitsyLog(j);
			while (j < sourceStr.length && end.indexOf(sourceStr[j]) == -1) {
				str += sourceStr[j];
				j++;
			}
			// bitsyLog("PEAK ::" + str + "::");
			return str;
		}
		this.ConsumeBlock = function(open, close, includeSymbols) {
			if (includeSymbols === undefined || includeSymbols === null) {
				includeSymbols = false;
			}

			var startIndex = i;

			var matchCount = 0;
			if (this.MatchAhead(open)) {
				matchCount++;
				this.Step(open.length);
			}

			while (matchCount > 0 && !this.Done()) {
				if (this.MatchAhead(close)) {
					matchCount--;
					this.Step( close.length );
				}
				else if (this.MatchAhead(open)) {
					matchCount++;
					this.Step(open.length);
				}
				else {
					this.Step();
				}
			}

			if (includeSymbols) {
				return sourceStr.slice(startIndex, i);
			}
			else {
				return sourceStr.slice(startIndex + open.length, i - close.length);
			}
		}

		this.Print = function() { bitsyLog(sourceStr); };
		this.Source = function() { return sourceStr; };
	};

	/*
		ParseDialog():
		This function adds {print} nodes and linebreak {br} nodes to display text,
		interleaved with bracketed code nodes for functions and flow control,
		such as text effects {shk} {wvy} or sequences like {cycle} and {shuffle}.
		The parsing of those code blocks is handled by ParseCode.

		Note on parsing newline characters:
		- there should be an implicit linebreak {br} after each dialog line
		- a "dialog line" is defined as any line that either:
			- 1) contains dialog text (any text outside of a code block)
			- 2) is entirely empty (no text, no code)
			- *or* 3) contains a list block (sequence, cycle, shuffle, or conditional)
		- lines *only* containing {code} blocks are not dialog lines

		NOTE TO SELF: all the state I'm storing in here feels like
		evidence that the parsing system kind of broke down at this point :(
		Maybe it would feel better if I move into the "state" object
	*/
	function ParseDialog(state) {
		var curLineNodeList = [];
		var curText = "";
		var curLineIsEmpty = true;
		var curLineContainsDialogText = false;
		var prevLineIsDialogLine = false;

		var curLineIsDialogLine = function() {
			return curLineContainsDialogText || curLineIsEmpty;
		}

		var resetLineStateForNewLine = function() {
			prevLineIsDialogLine = curLineIsDialogLine();
			curLineContainsDialogText = false;
			curLineIsEmpty = true;
			curText = "";
			curLineNodeList = [];
		}

		var tryAddTextNodeToList = function() {
			if (curText.length > 0) {
				var printNode = new FuncNode("print", [new LiteralNode(curText)]);
				curLineNodeList.push(printNode);

				curText = "";
				curLineIsEmpty = false;
				curLineContainsDialogText = true;
			}
		}

		var addCodeNodeToList = function() {
			var codeSource = state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			var codeState = new ParserState(new CodeBlockNode(), codeSource);
			codeState = ParseCode(codeState);
			var codeBlockNode = codeState.rootNode;
			curLineNodeList.push(codeBlockNode);

			curLineIsEmpty = false;

			// lists count as dialog text, because they can contain it
			if (isMultilineListBlock(codeBlockNode)) {
				curLineContainsDialogText = true;
			}
		}

		var tryAddLinebreakNodeToList = function() {
			if (prevLineIsDialogLine) {
				var linebreakNode = new FuncNode("br", []);
				curLineNodeList.unshift(linebreakNode);
			}
		}

		var addLineNodesToParent = function() {
			for (var i = 0; i < curLineNodeList.length; i++) {
				state.curNode.AddChild(curLineNodeList[i]);
			}
		}

		while (!state.Done()) {
			if (state.MatchAhead(Sym.CodeOpen)) { // process code block
				// add any buffered text to a print node, and parse the code
				tryAddTextNodeToList();
				addCodeNodeToList();
			}
			else if (state.MatchAhead(Sym.Linebreak)) { // process new line
				// add any buffered text to a print node, 
				// and add a linebreak if we are between two dialog lines
				tryAddTextNodeToList();
				tryAddLinebreakNodeToList();

				// since we've reached the end of a line
				// add stored nodes for this line to the parent node we are building,
				// and reset state for the next line
				addLineNodesToParent();
				resetLineStateForNewLine();

				state.Step();
			}
			else {
				// continue adding text to the current text buffer
				curText += state.Char();
				state.Step();
			}
		}

		// to make sure we don't leave anything behind:
		// add buffered text to a print node and add all nodes
		// to the current parent node
		tryAddTextNodeToList();
		tryAddLinebreakNodeToList();
		addLineNodesToParent();

		return state;
	}

	function ParseDialogBlock(state) {
		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );

		var dialogState = new ParserState(new DialogBlockNode(), dialogStr);
		dialogState = ParseDialog( dialogState );

		state.curNode.AddChild( dialogState.rootNode );

		return state;
	}

	/*
		ParseConditional():
		A conditional contains a list of conditions that can be
		evaluated to true or false, followed by more dialog
		that will be evaluated if the condition is true. The first
		true condition is the one that gets evaluated.
	*/
	function ParseConditional(state) {
		var conditionStrings = [];
		var resultStrings = [];
		var curIndex = -1;
		var requiredLeadingWhitespace = -1;

		// TODO : very similar to sequence parsing - can we share anything?
		function parseConditionalItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewCondition = false;
			var encounteredNonWhitespace = false;
			var encounteredConditionEnd = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewCondition = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// if this is the condition, we need to track whether we've
				// reached the end of the condition
				if (isNewCondition && !encounteredConditionEnd) {
					if (state.Char() === Sym.ConditionEnd) {
						encounteredConditionEnd = true;
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					if (!encounteredConditionEnd) { // skip all characters including & after the condition end
						lineText += state.Char();
					}
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewCondition:isNewCondition };
		}

		// TODO : this is copied from sequence parsing; share?
		function trimLeadingWhitespace(text, trimLength) {
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseConditionalItemLine(state);

			if (lineResults.isNewCondition) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curIndex++;
				conditionStrings[curIndex] = "";
				resultStrings[curIndex] = "";
			}

			// to avoid extra newlines in nested conditionals, only count lines
			// that at least match the whitespace count of the initial line
			// NOTE: see the comment in sequence parsing for more details
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);

				if (lineResults.isNewCondition) {
					conditionStrings[curIndex] += trimmedText;
				}
				else {
					resultStrings[curIndex] += trimmedText + Sym.Linebreak;
				}
			}
		}

		// hack: cut off the trailing newlines from all the result strings
		resultStrings = resultStrings.map(function(result) { return result.slice(0,-1); });

		var conditions = [];
		for (var i = 0; i < conditionStrings.length; i++) {
			var str = conditionStrings[i].trim();
			if (str === Sym.Else) {
				conditions.push(new ElseNode());
			}
			else {
				var exp = CreateExpression(str);
				conditions.push(exp);
			}
		}

		var results = [];
		for (var i = 0; i < resultStrings.length; i++) {
			var str = resultStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			results.push(dialogBlock);
		}

		state.curNode.AddChild(new IfNode(conditions, results));

		return state;
	}

	function IsSequence(str) {
		// bitsyLog("IsSequence? " + str);
		return str === "sequence" || str === "cycle" || str === "shuffle";
	}

	/*
		ParseSequence():
		Sequence nodes contain a list of dialog block nodes. The order those
		nodes are evaluated is determined by the type of sequence:
		- sequence: each child node evaluated once in order
		- cycle: repeats from the beginning after all nodes evaluate
		- shuffle: evaluate in a random order

		Each item in a sequence is sepearated by a "-" character.
		The seperator must come at the beginning of the line,
		but may be preceded by whitespace (in any amount).

		About whitespace: Whitespace at the start of a line
		is ignored if it less than or equal to the count of
		whitespace that preceded the list separator ("-") at
		the start of that item. (The count also includes the
		seperator and the extra space after the seperator.)
	 */
	function ParseSequence(state, sequenceType) {
		var itemStrings = [];
		var curItemIndex = -1; // -1 indicates not reading an item yet
		var requiredLeadingWhitespace = -1;

		function parseSequenceItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewListItem = false;
			var encounteredNonWhitespace = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewListItem = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					lineText += state.Char();
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewListItem:isNewListItem };
		}

		function trimLeadingWhitespace(text, trimLength) {
			// the split and join is necessary because a single "line"
			// can contain sequences that may contain newlines of their own
			// (we treat them all as one "line" for sequence parsing purposes)
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseSequenceItemLine(state);

			if (lineResults.isNewListItem) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curItemIndex++;
				itemStrings[curItemIndex] = "";
			}

			// to avoid double counting closing lines (empty ones ending in a curly brace)
			// we only allow lines that have at least as much whitespace as the start of the list item
			// TODO : I think right now this leads to a bug if the list item's indentation is less than
			// its parent code block... hopefully that won't be a big deal for now
			// (NOTE: I think the bug could be fixed by only applying this to the FINAL line of an item, but
			// that would require more consideration and testing)
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);
				itemStrings[curItemIndex] += trimmedText + Sym.Linebreak;
			}
		}

		// a bit hacky: cut off the trailing newlines from all the items
		itemStrings = itemStrings.map(function(item) { return item.slice(0,-1); });

		var options = [];
		for (var i = 0; i < itemStrings.length; i++) {
			var str = itemStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(false /* doIndentFirstLine */), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			options.push(dialogBlock);
		}

		if (sequenceType === "sequence") {
			state.curNode.AddChild(new SequenceNode(options));
		}
		else if (sequenceType === "cycle") {
			state.curNode.AddChild(new CycleNode(options));
		}
		else if (sequenceType === "shuffle") {
			state.curNode.AddChild(new ShuffleNode(options));
		}

		return state;
	}

	function ParseFunction(state, funcName) {
		bitsyLog("~~~ PARSE FUNCTION " + funcName);

		var args = [];

		var curSymbol = "";
		function OnSymbolEnd() {
			curSymbol = curSymbol.trim();
			// bitsyLog("PARAMTER " + curSymbol);
			args.push( StringToValue(curSymbol) );
			// bitsyLog(args);
			curSymbol = "";
		}

		while( !( state.Char() === "\n" || state.Done() ) ) {
			if( state.MatchAhead(Sym.CodeOpen) ) {
				var codeBlockState = new ParserState(new CodeBlockNode(), state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose));
				codeBlockState = ParseCode( codeBlockState );
				var codeBlock = codeBlockState.rootNode;
				args.push( codeBlock );
				curSymbol = "";
			}
			else if( state.MatchAhead(Sym.String) ) {
				/* STRING LITERAL */
				var str = state.ConsumeBlock(Sym.String, Sym.String);
				// bitsyLog("STRING " + str);
				args.push( new LiteralNode(str) );
				curSymbol = "";
			}
			else if(state.Char() === " " && curSymbol.length > 0) {
				OnSymbolEnd();
			}
			else {
				curSymbol += state.Char();
			}
			state.Step();
		}

		if(curSymbol.length > 0) {
			OnSymbolEnd();
		}

		state.curNode.AddChild( new FuncNode( funcName, args ) );

		return state;
	}

	function IsValidVariableName(str) {
		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		var isValid = reg.test(str);
		// bitsyLog("VALID variable??? " + isValid);
		return isValid;
	}

	function StringToValue(valStr) {
		if(valStr[0] === Sym.CodeOpen) {
			// CODE BLOCK!!!
			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky
			var codeBlockState = new ParserState(new CodeBlockNode(), codeStr);
			codeBlockState = ParseCode( codeBlockState );
			return codeBlockState.rootNode;
		}
		else if(valStr[0] === Sym.String) {
			// STRING!!
			// bitsyLog("STRING");
			var str = "";
			var i = 1;
			while (i < valStr.length && valStr[i] != Sym.String) {
				str += valStr[i];
				i++;
			}
			// bitsyLog(str);
			return new LiteralNode( str );
		}
		else if(valStr === "true") {
			// BOOL
			return new LiteralNode( true );
		}
		else if(valStr === "false") {
			// BOOL
			return new LiteralNode( false );
		}
		else if( !isNaN(parseFloat(valStr)) ) {
			// NUMBER!!
			// bitsyLog("NUMBER!!! " + valStr);
			return new LiteralNode( parseFloat(valStr) );
		}
		else if(IsValidVariableName(valStr)) {
			// VARIABLE!!
			// bitsyLog("VARIABLE");
			return new VarNode(valStr); // TODO : check for valid potential variables
		}
		else {
			// uh oh
			return new LiteralNode(null);
		}
	}

	function CreateExpression(expStr) {
		expStr = expStr.trim();

		function IsInsideString(index) {
			var inString = false;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.String)
					inString = !inString;

				if(index === i)
					return inString;
			}
			return false;
		}

		function IsInsideCode(index) {
			var count = 0;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.CodeOpen)
					count++;
				else if(expStr[i] === Sym.CodeClose)
					count--;

				if(index === i)
					return count > 0;
			}
			return false;
		}

		var operator = null;

		// set is special because other operator can look like it, and it has to go first in the order of operations
		var setIndex = expStr.indexOf(Sym.Set);
		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator
			if( expStr[setIndex+1] != "=" && expStr[setIndex-1] != ">" && expStr[setIndex-1] != "<" ) {
				// ok it actually IS a set operator and not ==, >=, or <=
				operator = Sym.Set;
				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing
				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);
				var right = CreateExpression( expStr.substring(setIndex+Sym.Set.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		// special if "expression" for single-line if statements
		var ifIndex = expStr.indexOf(Sym.ConditionEnd);
		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {
			operator = Sym.ConditionEnd;
			var conditionStr = expStr.substring(0,ifIndex).trim();
			var conditions = [ CreateExpression(conditionStr) ];

			var resultStr = expStr.substring(ifIndex+Sym.ConditionEnd.length);
			var results = [];
			function AddResult(str) {
				var dialogBlockState = new ParserState(new DialogBlockNode(), str);
				dialogBlockState = ParseDialog( dialogBlockState );
				var dialogBlock = dialogBlockState.rootNode;
				results.push( dialogBlock );
			}

			var elseIndex = resultStr.indexOf(Sym.ElseExp); // does this need to test for strings?
			if(elseIndex > -1) {
				conditions.push( new ElseNode() );

				var elseStr = resultStr.substring(elseIndex+Sym.ElseExp.length);
				var resultStr = resultStr.substring(0,elseIndex);

				AddResult( resultStr.trim() );
				AddResult( elseStr.trim() );
			}
			else {
				AddResult( resultStr.trim() );
			}

			return new IfNode( conditions, results, true /*isSingleLine*/ );
		}

		for( var i = 0; (operator == null) && (i < Sym.Operators.length); i++ ) {
			var opSym = Sym.Operators[i];
			var opIndex = expStr.indexOf( opSym );
			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {
				operator = opSym;
				var left = CreateExpression( expStr.substring(0,opIndex) );
				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		if( operator == null ) {
			return StringToValue(expStr);
		}
	}
	this.CreateExpression = CreateExpression;

	function IsWhitespace(str) {
		return ( str === " " || str === "\t" || str === "\n" );
	}

	function IsExpression(str) {
		var tempState = new ParserState(null, str); // hacky
		var textOutsideCodeBlocks = "";

		while (!tempState.Done()) {
			if (tempState.MatchAhead(Sym.CodeOpen)) {
				tempState.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			}
			else {
				textOutsideCodeBlocks += tempState.Char();
				tempState.Step();
			}
		}

		var containsAnyExpressionOperators = (textOutsideCodeBlocks.indexOf(Sym.ConditionEnd) != -1) ||
				(textOutsideCodeBlocks.indexOf(Sym.Set) != -1) ||
				(Sym.Operators.some(function(opSym) { return textOutsideCodeBlocks.indexOf(opSym) != -1; }));

		return containsAnyExpressionOperators;
	}

	function IsLiteral(str) {
		var isBool = str === "true" || str === "false";
		var isNum = !isNaN(parseFloat(str));
		var isStr = str[0] === '"' && str[str.length-1] === '"';
		var isVar = IsValidVariableName(str);
		var isEmpty = str.length === 0;
		return isBool || isNum || isStr || isVar || isEmpty;
	}

	function ParseExpression(state) {
		var line = state.Source(); // state.Peak( [Sym.Linebreak] ); // TODO : remove the linebreak thing
		// bitsyLog("EXPRESSION " + line);
		var exp = CreateExpression(line);
		// bitsyLog(exp);
		state.curNode.AddChild(exp);
		state.Step(line.length);
		return state;
	}

	function IsConditionalBlock(state) {
		var peakToFirstListSymbol = state.Peak([Sym.List]);

		var foundListSymbol = peakToFirstListSymbol < state.Source().length;

		var areAllCharsBeforeListWhitespace = true;
		for (var i = 0; i < peakToFirstListSymbol.length; i++) {
			if (!IsWhitespace(peakToFirstListSymbol[i])) {
				areAllCharsBeforeListWhitespace = false;
			}
		}

		var peakToFirstConditionSymbol = state.Peak([Sym.ConditionEnd]);
		peakToFirstConditionSymbol = peakToFirstConditionSymbol.slice(peakToFirstListSymbol.length);
		var hasNoLinebreakBetweenListAndConditionEnd = peakToFirstConditionSymbol.indexOf(Sym.Linebreak) == -1;

		return foundListSymbol && 
			areAllCharsBeforeListWhitespace && 
			hasNoLinebreakBetweenListAndConditionEnd;
	}

	function ParseCode(state) {
		if (IsConditionalBlock(state)) {
			state = ParseConditional(state);
		}
		else if (environment.HasFunction(state.Peak([" "]))) { // TODO --- what about newlines???
			var funcName = state.Peak([" "]);
			state.Step(funcName.length);
			state = ParseFunction(state, funcName);
		}
		else if (IsSequence(state.Peak([" ", Sym.Linebreak]))) {
			var sequenceType = state.Peak([" ", Sym.Linebreak]);
			state.Step(sequenceType.length);
			state = ParseSequence(state, sequenceType);
		}
		else if (IsLiteral(state.Source()) || IsExpression(state.Source())) {
			state = ParseExpression(state);
		}
		else {
			var undefinedSrc = state.Peak([]);
			var undefinedNode = new UndefinedNode(undefinedSrc);
			state.curNode.AddChild(undefinedNode);
		}

		// just go to the end now
		while (!state.Done()) {
			state.Step();
		}

		return state;
	}

	function ParseCodeBlock(state) {
		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );
		var codeState = new ParserState(new CodeBlockNode(), codeStr);
		codeState = ParseCode( codeState );
		state.curNode.AddChild( codeState.rootNode );
		return state;
	}

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {

	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?
	var textboxInfo = {
		width : 104,
		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
		font_scale : 0.5, // we draw font at half-size compared to everything else
		padding_vert : 2,
		padding_horz : 4,
		arrow_height : 5,
	};

	var font = null;
	this.SetFont = function(f) {
		font = f;
		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;

		// todo : clean up all the scale stuff
		var textboxScaleW = textboxInfo.width / textboxInfo.font_scale;
		var textboxScaleH = textboxInfo.height / textboxInfo.font_scale;
		bitsySetTextboxSize(textboxScaleW, textboxScaleH);
	}

	function textScale() {
		return scale * textboxInfo.font_scale;
	}

	function relativeFontWidth() {
		return Math.ceil( font.getWidth() * textboxInfo.font_scale );
	}

	function relativeFontHeight() {
		return Math.ceil( font.getHeight() * textboxInfo.font_scale );
	}

	this.ClearTextbox = function() {
		bitsyDrawBegin(1);
		bitsyClear(textBackgroundIndex);
		bitsyDrawEnd();
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	this.DrawTextbox = function() {
		bitsyDrawBegin(0);

		if (isCentered) {
			// todo : will the height calculations always work?
			bitsyDrawTextbox(textboxInfo.left, ((height / 2) - (textboxInfo.height / 2)));
		}
		else if (player().y < (mapsize / 2)) {
			// bottom
			bitsyDrawTextbox(textboxInfo.left, (height - textboxInfo.bottom - textboxInfo.height));
		}
		else {
			// top
			bitsyDrawTextbox(textboxInfo.left, textboxInfo.top);
		}

		bitsyDrawEnd();
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];

	this.DrawNextArrow = function() {
		// bitsyLog("draw arrow!");
		bitsyDrawBegin(1);

		var top = (textboxInfo.height - 5) * text_scale;
		var left = (textboxInfo.width - (5 + 4)) * text_scale;
		if (textDirection === TextDirection.RightToLeft) { // RTL hack
			left = 4 * text_scale;
		}

		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (arrowdata[i] == 1) {
					//scaling nonsense
					for (var sy = 0; sy < text_scale; sy++) {
						for (var sx = 0; sx < text_scale; sx++) {
							bitsyDrawPixel(textArrowIndex, left + (x * text_scale) + sx, top + (y * text_scale) + sy);
						}
					}
				}
			}
		}

		bitsyDrawEnd();
	};

	var text_scale = 2; //using a different scaling factor for text feels like cheating... but it looks better
	this.DrawChar = function(char, row, col, leftPos) {
		bitsyDrawBegin(1);

		char.offset = {
			x: char.base_offset.x,
			y: char.base_offset.y
		}; // compute render offset *every* frame

		char.SetPosition(row,col);
		char.ApplyEffects(effectTime);

		var charData = char.bitmap;

		var top = (4 * text_scale) + (row * 2 * text_scale) + (row * font.getHeight()) + Math.floor(char.offset.y);
		var left = (4 * text_scale) + leftPos + Math.floor(char.offset.x);

		for (var y = 0; y < char.height; y++) {
			for (var x = 0; x < char.width; x++) {
				var i = (y * char.width) + x;
				if (charData[i] == 1) {
					// todo : other colors
					bitsySetPixelAtIndex(char.color, ((top + y) * (textboxInfo.width * text_scale)) + (left + x));
				}
			}
		}

		bitsyDrawEnd();

		// call printHandler for character
		char.OnPrint();
	};

	var effectTime = 0; // TODO this variable should live somewhere better
	this.Draw = function(buffer, dt) {
		effectTime += dt;

		this.ClearTextbox();

		buffer.ForEachActiveChar(this.DrawChar);

		if (buffer.CanContinue()) {
			this.DrawNextArrow();
		}

		this.DrawTextbox();

		if (buffer.DidPageFinishThisFrame() && onPageFinish != null) {
			onPageFinish();
		}
	};

	/* this is a hook for GIF rendering */
	var onPageFinish = null;
	this.SetPageFinishHandler = function(handler) {
		onPageFinish = handler;
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?
	}

	// this.CharsPerRow = function() {
	// 	return textboxInfo.charsPerRow;
	// }
}


var DialogBuffer = function() {
	var buffer = [[[]]]; // holds dialog in an array buffer
	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;
	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds
	var isDialogReadyToContinue = false;
	var activeTextEffects = [];
	var font = null;
	var arabicHandler = new ArabicHandler();
	var onDialogEndCallbacks = [];

	this.SetFont = function(f) {
		font = f;
	}

	this.CurPage = function() { return buffer[ pageIndex ]; };
	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
	this.CurChar = function() { return this.CurRow()[ charIndex ]; };
	this.CurPageCount = function() { return buffer.length; };
	this.CurRowCount = function() { return this.CurPage().length; };
	this.CurCharCount = function() { return this.CurRow().length; };

	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
		var rowCount = rowIndex + 1;
		for (var i = 0; i < rowCount; i++) {
			var row = this.CurPage()[i];
			var charCount = (i == rowIndex) ? charIndex+1 : row.length;
			// bitsyLog(charCount);

			var leftPos = 0;
			if (textDirection === TextDirection.RightToLeft) {
				leftPos = 24 * 8; // hack -- I think this is correct?
			}

			for(var j = 0; j < charCount; j++) {
				var char = row[j];
				if(char) {
					if (textDirection === TextDirection.RightToLeft) {
						leftPos -= char.spacing;
					}
					// bitsyLog(j + " " + leftPos);

					// handler( char, i /*rowIndex*/, j /*colIndex*/ );
					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)

					if (textDirection === TextDirection.LeftToRight) {
						leftPos += char.spacing;
					}
				}
			}
		}
	}

	this.Reset = function() {
		buffer = [[[]]];
		pageIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		isDialogReadyToContinue = false;

		afterManualPagebreak = false;

		activeTextEffects = [];

		onDialogEndCallbacks = [];

		isActive = false;
	};

	this.DoNextChar = function() {
		nextCharTimer = 0; //reset timer

		//time to update characters
		if (charIndex + 1 < this.CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex + 1 < this.CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
		else {
			//the page is full!
			isDialogReadyToContinue = true;
			didPageFinishThisFrame = true;
		}

		if (this.CurChar() != null) {
			if (this.CurChar().isPageBreak) {
				// special case for page break marker character!
				isDialogReadyToContinue = true;
				didPageFinishThisFrame = true;
			}
			
			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text
		}
	};

	this.Update = function(dt) {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// this.Draw(dt); // TODO move into a renderer object
		if (isDialogReadyToContinue) {
			return; //waiting for dialog to be advanced by player
		}

		nextCharTimer += dt; //tick timer

		if (nextCharTimer > nextCharMaxTime) {
			this.DoNextChar();
		}
	};

	this.Skip = function() {
		bitsyLog("SKIPPP");
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < this.CurRowCount()) {
			this.DoNextChar();

			if(isDialogReadyToContinue) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}
		rowIndex = this.CurRowCount()-1;
		charIndex = this.CurCharCount()-1;
	};

	this.FlipPage = function() {
		didFlipPageThisFrame = true;
		isDialogReadyToContinue = false;
		pageIndex++;
		rowIndex = 0;
		charIndex = 0;
	}

	this.EndDialog = function() {
		isActive = false; // no more text to show... this should be a sign to stop rendering dialog

		for (var i = 0; i < onDialogEndCallbacks.length; i++) {
			onDialogEndCallbacks[i]();
		}
	}

	var afterManualPagebreak = false; // is it bad to track this state like this?

	this.Continue = function() {
		bitsyLog("CONTINUE");

		// if we used a page break character to continue we need
		// to run whatever is in the script afterwards! // TODO : make this comment better
		if (this.CurChar().isPageBreak) {
			// hacky: always treat a page break as the end of dialog
			// if there's more dialog later we re-activate the dialog buffer
			this.EndDialog();
			afterManualPagebreak = true;
			this.CurChar().OnContinue();
			return false;
		}
		if (pageIndex + 1 < this.CurPageCount()) {
			bitsyLog("FLIP PAGE!");
			//start next page
			this.FlipPage();
			return true; /* hasMoreDialog */
		}
		else {
			bitsyLog("END DIALOG!");
			//end dialog mode
			this.EndDialog();
			return false; /* hasMoreDialog */
		}
	};

	var isActive = false;
	this.IsActive = function() { return isActive; };

	this.OnDialogEnd = function(callback) {
		if (!isActive) {
			callback();
		}
		else {
			onDialogEndCallbacks.push(callback);
		}
	}

	this.CanContinue = function() { return isDialogReadyToContinue; };

	function DialogChar(effectList) {
		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)

		this.color = textColorIndex; // white
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)

		this.col = 0;
		this.row = 0;

		this.SetPosition = function(row,col) {
			// bitsyLog("SET POS");
			// bitsyLog(this);
			this.row = row;
			this.col = col;
		}

		this.ApplyEffects = function(time) {
			// bitsyLog("APPLY EFFECTS! " + time);
			for(var i = 0; i < this.effectList.length; i++) {
				var effectName = this.effectList[i];
				// bitsyLog("FX " + effectName);
				TextEffects[ effectName ].DoEffect( this, time );
			}
		}

		var printHandler = null; // optional function to be called once on printing character
		this.SetPrintHandler = function(handler) {
			printHandler = handler;
		}
		this.OnPrint = function() {
			if (printHandler != null) {
				// bitsyLog("PRINT HANDLER ---- DIALOG BUFFER");
				printHandler();
				printHandler = null; // only call handler once (hacky)
			}
		}

		this.bitmap = [];
		this.width = 0;
		this.height = 0;
		this.base_offset = { // hacky name
 			x: 0,
			y: 0
		};
		this.spacing = 0;
	}

	function DialogFontChar(font, char, effectList) {
		Object.assign(this, new DialogChar(effectList));

		var charData = font.getChar(char);
		this.bitmap = charData.data;
		this.width = charData.width;
		this.height = charData.height;
		this.base_offset.x = charData.offset.x;
		this.base_offset.y = charData.offset.y;
		this.spacing = charData.spacing;
	}

	function DialogDrawingChar(drawingId, effectList) {
		Object.assign(this, new DialogChar(effectList));

		// get the first frame of the drawing and flatten it
		var drawingData = renderer.GetDrawingSource(drawingId)[0];
		var drawingDataFlat = [];
		for (var i = 0; i < drawingData.length; i++) {
			drawingDataFlat = drawingDataFlat.concat(drawingData[i]);
		}

		this.bitmap = drawingDataFlat;
		this.width = 8;
		this.height = 8;
		this.spacing = 8;
	}

	function DialogScriptControlChar() {
		Object.assign(this, new DialogChar([]));

		this.width = 0;
		this.height = 0;
		this.spacing = 0;
	}

	// is a control character really the best way to handle page breaks?
	function DialogPageBreakChar() {
		Object.assign(this, new DialogChar([]));

		this.width = 0;
		this.height = 0;
		this.spacing = 0;

		this.isPageBreak = true;

		var continueHandler = null;

		this.SetContinueHandler = function(handler) {
			continueHandler = handler;
		}

		this.OnContinue = function() {
			if (continueHandler) {
				continueHandler();
			}
		}
	}

	function AddWordToCharArray(charArray,word,effectList) {
		for(var i = 0; i < word.length; i++) {
			charArray.push( new DialogFontChar( font, word[i], effectList ) );
		}
		return charArray;
	}

	function GetCharArrayWidth(charArray) {
		var width = 0;
		for(var i = 0; i < charArray.length; i++) {
			width += charArray[i].spacing;
		}
		return width;
	}

	function GetStringWidth(str) {
		var width = 0;
		for (var i = 0; i < str.length; i++) {
			var charData = font.getChar(str[i]);
			width += charData.spacing;
		}
		return width;
	}

	var pixelsPerRow = 192; // hard-coded fun times!!!

	this.AddScriptReturn = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var controlChar = new DialogScriptControlChar();
		controlChar.SetPrintHandler(onReturnHandler);

		curRowArr.push(controlChar);

		isActive = true;
	}

	this.AddDrawing = function(drawingId) {
		// bitsyLog("DRAWING ID " + drawingId);

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects);

		var rowLength = GetCharArrayWidth(curRowArr);

		// TODO : clean up copy-pasted code here :/
		if (afterManualPagebreak) {
			this.FlipPage(); // hacky

			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);

			afterManualPagebreak = false;
		}
		else if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength <= 0) {
			//stay on same row
			curRowArr.push(drawingChar);
		}
		else if (curRowIndex == 0) {
			//start next row
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer[curPageIndex].push([]);
			curRowIndex++;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}
		else {
			//start next page
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}

		isActive = true; // this feels like a bad way to do this???
	}

	// TODO : convert this into something that takes DialogChar arrays
	this.AddText = function(textStr) {
		bitsyLog("ADD TEXT " + textStr);

		//process dialog so it's easier to display
		var words = textStr.split(" ");

		// var curPageIndex = this.CurPageCount() - 1;
		// var curRowIndex = this.CurRowCount() - 1;
		// var curRowArr = this.CurRow();

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		for (var i = 0; i < words.length; i++) {
			var word = words[i];
			if (arabicHandler.ContainsArabicCharacters(word)) {
				word = arabicHandler.ShapeArabicCharacters(word);
			}

			var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
			var wordLength = GetStringWidth(wordWithPrecedingSpace);

			var rowLength = GetCharArrayWidth(curRowArr);

			if (afterManualPagebreak) {
				this.FlipPage();

				// hacky copied bit for page breaks
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects);

				afterManualPagebreak = false;
			}
			else if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {
				//stay on same row
				curRowArr = AddWordToCharArray(curRowArr, wordWithPrecedingSpace, activeTextEffects);
			}
			else if (curRowIndex == 0) {
				//start next row
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer[curPageIndex].push([]);
				curRowIndex++;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects);
			}
			else {
				//start next page
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects);
			}
		}

		//destroy any empty stuff
		var lastPage = buffer[buffer.length-1];
		var lastRow = lastPage[lastPage.length-1];
		if (lastRow.length == 0) {
			lastPage.splice(lastPage.length-1, 1);
		}
		if (lastPage.length == 0) {
			buffer.splice(buffer.length-1, 1);
		}

		//finish up 
		lastPage = buffer[buffer.length-1];
		lastRow = lastPage[lastPage.length-1];
		if (lastRow.length > 0) {
			var lastChar = lastRow[lastRow.length-1];
		}

		// bitsyLog(buffer);

		isActive = true;
	};

	this.AddLinebreak = function() {
		var lastPage = buffer[buffer.length-1];
		if (lastPage.length <= 1) {
			// bitsyLog("LINEBREAK - NEW ROW ");
			// add new row
			lastPage.push([]);
		}
		else {
			// add new page
			buffer.push([[]]);
		}
		// bitsyLog(buffer);

		isActive = true;
	}

	this.AddPagebreak = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		// need to actually create a whole new page if following another pagebreak character
		if (this.CurChar() && this.CurChar().isPageBreak) {
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
		}

		var pagebreakChar = new DialogPageBreakChar();
		pagebreakChar.SetContinueHandler(onReturnHandler);

		curRowArr.push(pagebreakChar);

		isActive = true;		
	}

	/* new text effects */
	this.HasTextEffect = function(name) {
		return activeTextEffects.indexOf( name ) > -1;
	}
	this.AddTextEffect = function(name) {
		activeTextEffects.push( name );
	}
	this.RemoveTextEffect = function(name) {
		activeTextEffects.splice( activeTextEffects.indexOf( name ), 1 );
	}

	/* this is a hook for GIF rendering */
	var didPageFinishThisFrame = false;
	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

	var didFlipPageThisFrame = false;
	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };

	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky
};

/* ARABIC */
var ArabicHandler = function() {

	var arabicCharStart = 0x0621;
	var arabicCharEnd = 0x064E;

	var CharacterForm = {
		Isolated : 0,
		Final : 1,
		Initial : 2,
		Middle : 3
	};

	// map glyphs to their character forms
	var glyphForms = {
		/*		 Isolated, Final, Initial, Middle Forms	*/
		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ 
		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ 
		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ 
		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ 
		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ 
		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ 
		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ 
		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ 
		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ 
		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ 
		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ 
		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ 
		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ 
		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ 
		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ 
		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ 
		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ 
		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ 
		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ 
		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ 
		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ 
		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ 
		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ 
		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ 
		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ 
		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ 
		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ 
		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ 
		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ 
		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ 
		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ 
		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ 
		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ 
		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ 
		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ 
		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ 
		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ 
		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/
		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/
		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/
		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */
	};

	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];

	function IsArabicCharacter(char) {
		var code = char.charCodeAt(0);
		return (code >= arabicCharStart && code <= arabicCharEnd);
	}

	function ContainsArabicCharacters(word) {
		for (var i = 0; i < word.length; i++) {
			if (IsArabicCharacter(word[i])) {
				return true;
			}
		}
		return false;
	}

	function IsDisconnectedCharacter(char) {
		var code = char.charCodeAt(0);
		return disconnectedCharacters.indexOf(code) != -1;
	}

	function ShapeArabicCharacters(word) {
		var shapedWord = "";

		for (var i = 0; i < word.length; i++) {
			if (!IsArabicCharacter(word[i])) {
				shapedWord += word[i];
				continue;
			}

			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);

			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);

			var form;
			if (!connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Isolated;
			}
			else if (connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Final;
			}
			else if (!connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Initial;
			}
			else if (connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Middle;
			}

			var code = word[i].charCodeAt(0);

			// handle lam alef special case
			if (code == 0x0644 && connectedToNextChar) {
				var nextCode = word[i+1].charCodeAt(0);
				var specialCode = null;
				if (nextCode == 0x0622) {
					// alef madd
					specialCode = glyphForms[0x064b][form];
				}
				else if (nextCode == 0x0623) {
					// hamza above
					specialCode = glyphForms[0x064c][form];
				}
				else if (nextCode == 0x0625) {
					// hamza below
					specialCode = glyphForms[0x064d][form];
				}
				else if (nextCode == 0x0627) {
					// alef
					specialCode = glyphForms[0x064e][form];
				}

				if (specialCode != null) {
					shapedWord += String.fromCharCode(specialCode);
					i++; // skip a step
					continue;
				}
			}

			// hacky?
			if (form === CharacterForm.Isolated) {
				shapedWord += word[i];
				continue;
			}

			var shapedCode = glyphForms[code][form];
			shapedWord += String.fromCharCode(shapedCode);
		}

		return shapedWord;
	}

	this.ContainsArabicCharacters = ContainsArabicCharacters;
	this.ShapeArabicCharacters = ShapeArabicCharacters;
}

/* NEW TEXT EFFECTS */
var TextEffects = {};

var RainbowEffect = function() {
	this.DoEffect = function(char, time) {
		char.color = rainbowColorStartIndex + Math.floor(((time / 100) - char.col * 0.5) % rainbowColorCount);
	}
};
TextEffects["rbw"] = new RainbowEffect();

var ColorEffect = function(index) {
	this.DoEffect = function(char) {
		char.color = tileColorStartIndex + index;
	}
};
TextEffects["clr1"] = new ColorEffect(0);
TextEffects["clr2"] = new ColorEffect(1); // TODO : should I use parameters instead of special names?
TextEffects["clr3"] = new ColorEffect(2);

var WavyEffect = function() {
	this.DoEffect = function(char,time) {
		char.offset.y += Math.sin((time / 250) - (char.col / 2)) * 2;
	}
};
TextEffects["wvy"] = new WavyEffect();

var ShakyEffect = function() {
	function disturb(func, time, offset, mult1, mult2) {
		return func((time * mult1) - (offset * mult2));
	}

	this.DoEffect = function(char,time) {
		char.offset.y += 1.5
						* disturb(Math.sin, time, char.col, 0.1, 0.5)
						* disturb(Math.cos, time, char.col, 0.3, 0.2)
						* disturb(Math.sin, time, char.row, 2.0, 1.0);
		char.offset.x += 1.5
						* disturb(Math.cos, time, char.row, 0.1, 1.0)
						* disturb(Math.sin, time, char.col, 3.0, 0.7)
						* disturb(Math.cos, time, char.col, 0.2, 0.3);
	}
};
TextEffects["shk"] = new ShakyEffect();

var DebugHighlightEffect = function() {
	this.DoEffect = function(char) {
		char.color = tileColorStartIndex;
	}
}
TextEffects["_debug_highlight"] = new DebugHighlightEffect();

} // Dialog()
</script>

<script>
function TileRenderer(tilesize) {
// todo : do I need to pass in tilesize? or can I use the global value?

bitsyLog("!!!!! NEW TILE RENDERER");

var drawingCache = {
	source: {},
	render: {},
};

// var debugRenderCount = 0;

function createRenderCacheId(drawingId, colorIndex) {
	return drawingId + "_" + colorIndex;
}

function renderDrawing(drawing) {
	// debugRenderCount++;
	// bitsyLog("RENDER COUNT " + debugRenderCount);

	var col = drawing.col;
	var drwId = drawing.drw;
	var drawingFrames = drawingCache.source[drwId];

	// initialize render cache entry
	var cacheId = createRenderCacheId(drwId, col);
	if (drawingCache.render[cacheId] === undefined) {
		// initialize array of frames for drawing
		drawingCache.render[cacheId] = [];
	}

	for (var i = 0; i < drawingFrames.length; i++) {
		var frameData = drawingFrames[i];
		var frameTileId = renderTileFromDrawingData(frameData, col);
		drawingCache.render[cacheId].push(frameTileId);
	}
}

function renderTileFromDrawingData(drawingData, col) {
	var tileId = bitsyAddTile();

	var backgroundColor = tileColorStartIndex + 0;
	var foregroundColor = tileColorStartIndex + col;

	bitsyDrawBegin(tileId);

	for (var y = 0; y < tilesize; y++) {
		for (var x = 0; x < tilesize; x++) {
			var px = drawingData[y][x];

			if (px === 1) {
				bitsyDrawPixel(foregroundColor, x, y);
			}
			else {
				bitsyDrawPixel(backgroundColor, x, y);
			}
		}
	}

	bitsyDrawEnd();

	return tileId;
}

// TODO : move into core
function undefinedOrNull(x) {
	return x === undefined || x === null;
}

function isDrawingRendered(drawing) {
	var cacheId = createRenderCacheId(drawing.drw, drawing.col);
	return drawingCache.render[cacheId] != undefined;
}

function getRenderedDrawingFrames(drawing) {
	var cacheId = createRenderCacheId(drawing.drw, drawing.col);
	return drawingCache.render[cacheId];
}

function getDrawingFrameTileId(drawing, frameOverride) {
	var frameIndex = 0;

	if (drawing != null && drawing.animation.isAnimated) {
		if (frameOverride != undefined && frameOverride != null) {
			frameIndex = frameOverride;
		}
		else {
			frameIndex = drawing.animation.frameIndex;
		}
	}

	return getRenderedDrawingFrames(drawing)[frameIndex];
}

function getOrRenderDrawingFrame(drawing, frameOverride) {
	// bitsyLog("frame render: " + drawing.type + " " + drawing.id + " f:" + frameOverride);

	if (!isDrawingRendered(drawing)) {
		// bitsyLog("frame render: doesn't exist");
		renderDrawing(drawing);
	}

	return getDrawingFrameTileId(drawing, frameOverride);
}

/* PUBLIC INTERFACE */
this.GetDrawingFrame = getOrRenderDrawingFrame;

this.SetDrawingSource = function(drawingId, drawingData) {
	drawingCache.source[drawingId] = drawingData;
	// TODO : reset render cache for this image
}

this.GetDrawingSource = function(drawingId) {
	return drawingCache.source[drawingId];
}

this.GetFrameCount = function(drawingId) {
	return drawingCache.source[drawingId].length;
}

this.ClearCache = function() {
	bitsyResetTiles();
	drawingCache.render = {};
}

} // Renderer()
</script>

<script>
var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)
var playerId = "A";

var titleDialogId = "title";
function getTitle() {
	return dialog[titleDialogId].src;
}
function setTitle(titleSrc) {
	dialog[titleDialogId] = { src:titleSrc, name:null };
}

var defaultFontName = "ascii_small";
var fontName = defaultFontName;
var TextDirection = {
	LeftToRight : "LTR",
	RightToLeft : "RTL"
};
var textDirection = TextDirection.LeftToRight;

/* NAME-TO-ID MAPS */
var names = {
	room : {},
	tile : {},
	sprite : {},
	item : {},
	dialog : {},
};

function updateNamesFromCurData() {

	function createNameMap(objectStore) {
		var map = {};

		for (id in objectStore) {
			if (objectStore[id].name != undefined && objectStore[id].name != null) {
				map[objectStore[id].name] = id;
			}
		}

		return map;
	}

	names.room = createNameMap(room);
	names.tile = createNameMap(tile);
	names.sprite = createNameMap(sprite);
	names.item = createNameMap(item);
	names.dialog = createNameMap(dialog);
}

var spriteStartLocations = {};

/* VERSION */
var version = {
	major: 7, // major changes
	minor: 11, // smaller changes
	devBuildPhase: "RELEASE",
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* FLAGS */
var flags;
function resetFlags() {
	flags = {
		ROOM_FORMAT : 0 // 0 = non-comma separated, 1 = comma separated
	};
}
resetFlags(); //init flags on load script

// SUPER hacky location... :/
var editorDevFlags = {
	// NONE right now!
};

function clearGameData() {
	room = {};
	tile = {};
	sprite = {};
	item = {};
	dialog = {};
	palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
	isEnding = false; //todo - correct place for this?
	variable = {};

	// TODO RENDERER : clear data?

	spriteStartLocations = {};

	updateNamesFromCurData();

	fontName = defaultFontName; // TODO : reset font manager too?
	textDirection = TextDirection.LeftToRight;
}

var width = 128;
var height = 128;
var scale = 4; //this is stupid but necessary
var tilesize = 8;
var mapsize = 16;

var curRoom = "0";

var prevTime = 0;
var deltaTime = 0;

// engine event hooks for the editor
var onInventoryChanged = null;
var onVariableChanged = null;
var onGameReset = null;
var onInitRoom = null;

var isPlayerEmbeddedInEditor = false;

var renderer = new TileRenderer(tilesize);

var curGameData = null;
var curDefaultFontData = null;

function load_game(gameData, defaultFontData, startWithTitle) {
	curGameData = gameData; //remember the current game (used to reset the game)

	dialogBuffer.Reset();
	scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?

	parseWorld(gameData);

	if (!isPlayerEmbeddedInEditor && defaultFontData) {
		curDefaultFontData = defaultFontData; // store for resetting game

		// todo : consider replacing this with a more general system for requesting resources from the system?
		// hack to ensure default font is available
		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), defaultFontData);
	}

	var font = fontManager.Get( fontName );
	dialogBuffer.SetFont(font);
	dialogRenderer.SetFont(font);

	setInitialVariables();

	onready(startWithTitle);
}

function reset_cur_game() {
	if (curGameData == null) {
		return; //can't reset if we don't have the game data
	}

	stopGame();
	clearGameData();
	load_game(curGameData, curDefaultFontData);

	if (isPlayerEmbeddedInEditor && onGameReset != null) {
		onGameReset();
	}
}

function onready(startWithTitle) {
	if (startWithTitle === undefined || startWithTitle === null) {
		startWithTitle = true;
	}

	if (startWithTitle) { // used by editor 
		startNarrating(getTitle());
	}
}

function setInitialVariables() {
	for(id in variable) {
		var value = variable[id]; // default to string
		if(value === "true") {
			value = true;
		}
		else if(value === "false") {
			value = false;
		}
		else if(!isNaN(parseFloat(value))) {
			value = parseFloat(value);
		}
		scriptInterpreter.SetVariable(id,value);
	}
	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	bitsyLog("stop GAME!");
}

function update() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	if (curRoom == null) {
		// in the special case where there is no valid room, end the game
		startNarrating( "", true /*isEnding*/ );
	}

	if (!transition.IsTransitionActive()) {
		updateInput();
	}

	if (transition.IsTransitionActive()) {
		// transition animation takes over everything!
		transition.UpdateTransition(deltaTime);
	}
	else {
		bitsySetGraphicsMode(1);

		if (!isNarrating && !isEnding) {
			updateAnimation();
			drawRoom(room[curRoom]); // draw world if game has begun
		}
		else {
			clearRoom();
		}

		// if (isDialogMode) { // dialog mode
		if(dialogBuffer.IsActive()) {
			dialogRenderer.Draw( dialogBuffer, deltaTime );
			dialogBuffer.Update( deltaTime );
		}

		// keep moving avatar if player holds down button
		if( !dialogBuffer.IsActive() && !isEnding )
		{
			if( curPlayerDirection != Direction.None ) {
				playerHoldToMoveTimer -= deltaTime;

				if( playerHoldToMoveTimer <= 0 )
				{
					movePlayer( curPlayerDirection );
					playerHoldToMoveTimer = 150;
				}
			}
		}
	}

	prevTime = curTime;
}

var isAnyButtonHeld = false;
var isIgnoringInput = false;

function isAnyButtonDown() {
	return bitsyGetButton(0) || bitsyGetButton(1) || bitsyGetButton(2) || bitsyGetButton(3) || bitsyGetButton(4);
}

function updateInput() {
	if (dialogBuffer.IsActive()) {
		if (!isAnyButtonHeld && isAnyButtonDown()) {
			/* CONTINUE DIALOG */
			if (dialogBuffer.CanContinue()) {
				var hasMoreDialog = dialogBuffer.Continue();
				if (!hasMoreDialog) {
					// ignore currently held keys UNTIL they are released (stops player from insta-moving)
					isIgnoringInput = true;
					curPlayerDirection = Direction.None;
				}
			}
			else {
				dialogBuffer.Skip();
			}
		}
	}
	else if (isEnding) {
		if (!isAnyButtonHeld && isAnyButtonDown()) {
			/* RESTART GAME */
			reset_cur_game();
		}
	}
	else if (!isIgnoringInput) {
		/* WALK */
		var prevPlayerDirection = curPlayerDirection;

		if (bitsyGetButton(0)) {
			curPlayerDirection = Direction.Up;
		}
		else if (bitsyGetButton(1)) {
			curPlayerDirection = Direction.Down;
		}
		else if (bitsyGetButton(2)) {
			curPlayerDirection = Direction.Left;
		}
		else if (bitsyGetButton(3)) {
			curPlayerDirection = Direction.Right;
		}
		else {
			curPlayerDirection = Direction.None;
		}

		if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {
			movePlayer(curPlayerDirection);
			playerHoldToMoveTimer = 500;
		}
	}

	if (!isAnyButtonDown()) {
		isIgnoringInput = false;
	}

	isAnyButtonHeld = isAnyButtonDown();
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation() {
	animationCounter += deltaTime;

	if ( animationCounter >= animationTime ) {

		// animate sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.animation.isAnimated) {
				spr.animation.frameIndex = ( spr.animation.frameIndex + 1 ) % spr.animation.frameCount;
			}
		}

		// animate tiles
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = ( til.animation.frameIndex + 1 ) % til.animation.frameCount;
			}
		}

		// animate items
		for (id in item) {
			var itm = item[id];
			if (itm.animation.isAnimated) {
				itm.animation.frameIndex = ( itm.animation.frameIndex + 1 ) % itm.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;

	}
}

function resetAllAnimations() {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.animation.isAnimated) {
			spr.animation.frameIndex = 0;
		}
	}

	for (id in tile) {
		var til = tile[id];
		if (til.animation.isAnimated) {
			til.animation.frameIndex = 0;
		}
	}

	for (id in item) {
		var itm = item[id];
		if (itm.animation.isAnimated) {
			itm.animation.frameIndex = 0;
		}
	}
}

function getSpriteAt(x,y) {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === curRoom) {
			if (spr.x == x && spr.y == y) {
				return id;
			}
		}
	}
	return null;
}

var Direction = {
	None : -1,
	Up : 0,
	Down : 1,
	Left : 2,
	Right : 3
};

var curPlayerDirection = Direction.None;
var playerHoldToMoveTimer = 0;

function movePlayer(direction) {
	var roomIds = Object.keys(room);

	if (player().room == null || roomIds.indexOf(player().room) < 0) {
		return; // player room is missing or invalid.. can't move them!
	}

	var spr = null;

	if ( curPlayerDirection == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {
		player().x -= 1;
	}
	else if ( curPlayerDirection == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {
		player().x += 1;
	}
	else if ( curPlayerDirection == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {
		player().y -= 1;
	}
	else if ( curPlayerDirection == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {
		player().y += 1;
	}
	
	var ext = getExit( player().room, player().x, player().y );
	var end = getEnding( player().room, player().x, player().y );
	var itmIndex = getItemIndex( player().room, player().x, player().y );

	// do items first, because you can pick up an item AND go through a door
	if (itmIndex > -1) {
		var itm = room[player().room].items[itmIndex];
		var itemRoom = player().room;

		startItemDialog(itm.id, function() {
			// remove item from room
			room[itemRoom].items.splice(itmIndex, 1);

			// update player inventory
			if (player().inventory[itm.id]) {
				player().inventory[itm.id] += 1;
			}
			else {
				player().inventory[itm.id] = 1;
			}

			// show inventory change in UI
			if (onInventoryChanged != null) {
				onInventoryChanged(itm.id);
			}
		});
	}

	if (end) {
		startEndingDialog(end);
	}
	else if (ext) {
		movePlayerThroughExit(ext);
	}
	else if (spr) {
		startSpriteDialog(spr /*spriteId*/);
	}
}

var transition = new TransitionManager();

function movePlayerThroughExit(ext) {
	var GoToDest = function() {
		if (ext.transition_effect != null) {
			transition.BeginTransition(
				player().room,
				player().x,
				player().y,
				ext.dest.room,
				ext.dest.x,
				ext.dest.y,
				ext.transition_effect);

			transition.UpdateTransition(0);

			transition.OnTransitionComplete(function() {
				player().room = ext.dest.room;
				player().x = ext.dest.x;
				player().y = ext.dest.y;
				curRoom = ext.dest.room;

				initRoom(curRoom);
			});
		}
		else {
			player().room = ext.dest.room;
			player().x = ext.dest.x;
			player().y = ext.dest.y;
			curRoom = ext.dest.room;

			initRoom(curRoom);
		}
	};

	if (ext.dlg != undefined && ext.dlg != null) {
		// TODO : I need to simplify dialog code,
		// so I don't have to get the ID and the source str
		// every time!
		startDialog(
			dialog[ext.dlg].src,
			ext.dlg,
			function(result) {
				var isLocked = ext.property && ext.property.locked === true;
				if (!isLocked) {
					GoToDest();
				}
			},
			ext);
	}
	else {
		GoToDest();
	}
}

/* PALETTE INDICES */
var textBackgroundIndex = 0;
var textArrowIndex = 1;
var textColorIndex = 2;

// precalculated rainbow colors
var rainbowColorStartIndex = 3;
var rainbowColorCount = 10;
var rainbowColors = [
	[255,0,0],
	[255,217,0],
	[78,255,0],
	[0,255,125],
	[0,192,255],
	[0,18,255],
	[136,0,255],
	[255,0,242],
	[255,0,138],
	[255,0,61],
];

// todo : where should this be stored?
var tileColorStartIndex = 16;

function updatePaletteWithTileColors(tileColors) {
	// clear existing colors
	bitsyResetColors();

	// textbox colors
	bitsySetColor(textBackgroundIndex, 0, 0, 0); // black
	bitsySetColor(textArrowIndex, 255, 255, 255); // white
	bitsySetColor(textColorIndex, 255, 255, 255); // white

	// todo : move this to game init?
	// rainbow colors
	for (var i = 0; i < rainbowColorCount; i++) {
		var color = rainbowColors[i];
		bitsySetColor(rainbowColorStartIndex + i, color[0], color[1], color[2]);
	}

	// tile colors
	for (var i = 0; i < tileColors.length; i++) {
		var color = tileColors[i];
		bitsySetColor(tileColorStartIndex + i, color[0], color[1], color[2]);
	}
}

function updatePalette(palId) {
	var pal = palette[palId];
	bitsyLog(pal.colors.length, "editor");
	updatePaletteWithTileColors(pal.colors);
}

function initRoom(roomId) {
	bitsyLog("init room " + roomId);

	updatePalette(curPal());

	renderer.ClearCache();

	// init exit properties
	for (var i = 0; i < room[roomId].exits.length; i++) {
		room[roomId].exits[i].property = { locked:false };
	}

	// init ending properties
	for (var i = 0; i < room[roomId].endings.length; i++) {
		room[roomId].endings[i].property = { locked:false };
	}

	if (onInitRoom) {
		onInitRoom(roomId);
	}
}

function getItemIndex( roomId, x, y ) {
	for( var i = 0; i < room[roomId].items.length; i++ ) {
		var itm = room[roomId].items[i];
		if ( itm.x == x && itm.y == y)
			return i;
	}
	return -1;
}

function getSpriteLeft() { //repetitive?
	return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
	return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
	return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
	return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
	return (player().x - 1 < 0) || isWall( player().x - 1, player().y );
}

function isWallRight() {
	return (player().x + 1 >= 16) || isWall( player().x + 1, player().y );
}

function isWallUp() {
	return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );
}

function isWallDown() {
	return (player().y + 1 >= 16) || isWall( player().x, player().y + 1 );
}

function isWall(x,y,roomId) {
	if(roomId == undefined || roomId == null)
		roomId = curRoom;

	var tileId = getTile( x, y );

	if( tileId === '0' )
		return false; // Blank spaces aren't walls, ya doofus

	if( tile[tileId].isWall === undefined || tile[tileId].isWall === null ) {
		// No wall-state defined: check room-specific walls
		var i = room[roomId].walls.indexOf( getTile(x,y) );
		return i > -1;
	}

	// Otherwise, use the tile's own wall-state
	return tile[tileId].isWall;
}

function getItem(roomId,x,y) {
	for (i in room[roomId].items) {
		var item = room[roomId].items[i];
		if (x == item.x && y == item.y) {
			return item;
		}
	}
	return null;
}

function getExit(roomId,x,y) {
	for (i in room[roomId].exits) {
		var e = room[roomId].exits[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getEnding(roomId,x,y) {
	for (i in room[roomId].endings) {
		var e = room[roomId].endings[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getTile(x,y) {
	// bitsyLog(x + " " + y);
	var t = getRoom().tilemap[y][x];
	return t;
}

function player() {
	return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	if (palette[id] === undefined) {
		id = "default";
	}

	return palette[ id ].colors;
}

function getRoom() {
	return room[curRoom];
}

function isSpriteOffstage(id) {
	return sprite[id].room == null;
}

function parseWorld(file) {
	spriteStartLocations = {};

	resetFlags();

	var versionNumber = 0;

	// flags to keep track of which compatibility conversions
	// need to be applied to this game data
	var compatibilityFlags = {
		convertSayToPrint : false,
		combineEndingsWithDialog : false,
		convertImplicitSpriteDialogIds : false,
	};

	var lines = file.split("\n");
	var i = 0;
	while (i < lines.length) {
		var curLine = lines[i];

		// bitsyLog(lines[i]);

		if (i == 0) {
			i = parseTitle(lines, i);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
			// collect version number (from a comment.. hacky I know)
			if (curLine.indexOf("# BITSY VERSION ") != -1) {
				versionNumber = parseFloat(curLine.replace("# BITSY VERSION ", ""));

				if (versionNumber < 5.0) {
					compatibilityFlags.convertSayToPrint = true;
				}

				if (versionNumber < 7.0) {
					compatibilityFlags.combineEndingsWithDialog = true;
					compatibilityFlags.convertImplicitSpriteDialogIds = true;
				}
			}

			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) == "PAL") {
			i = parsePalette(lines, i);
		}
		else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { //SET for back compat
			i = parseRoom(lines, i, compatibilityFlags);
		}
		else if (getType(curLine) === "TIL") {
			i = parseTile(lines, i);
		}
		else if (getType(curLine) === "SPR") {
			i = parseSprite(lines, i);
		}
		else if (getType(curLine) === "ITM") {
			i = parseItem(lines, i);
		}
		else if (getType(curLine) === "DRW") {
			i = parseDrawing(lines, i);
		}
		else if (getType(curLine) === "DLG") {
			i = parseDialog(lines, i, compatibilityFlags);
		}
		else if (getType(curLine) === "END" && compatibilityFlags.combineEndingsWithDialog) {
			// parse endings for back compat
			i = parseEnding(lines, i, compatibilityFlags);
		}
		else if (getType(curLine) === "VAR") {
			i = parseVariable(lines, i);
		}
		else if (getType(curLine) === "DEFAULT_FONT") {
			i = parseFontName(lines, i);
		}
		else if (getType(curLine) === "TEXT_DIRECTION") {
			i = parseTextDirection(lines, i);
		}
		else if (getType(curLine) === "FONT") {
			i = parseFontData(lines, i);
		}
		else if (getType(curLine) === "!") {
			i = parseFlag(lines, i);
		}
		else {
			i++;
		}
	}

	placeSprites();

	var roomIds = Object.keys(room);

	if (player() != undefined && player().room != null && roomIds.indexOf(player().room) != -1) {
		// player has valid room
		curRoom = player().room;
	}
	else if (roomIds.length > 0) {
		// player not in any room! what the heck
		curRoom = roomIds[0];
	}
	else {
		// uh oh there are no rooms I guess???
		curRoom = null;
	}

	if (curRoom != null) {
		initRoom(curRoom);
	}

	scriptCompatibility(compatibilityFlags);

	return versionNumber;
}

function scriptCompatibility(compatibilityFlags) {
	if (compatibilityFlags.convertSayToPrint) {
		bitsyLog("CONVERT SAY TO PRINT!");

		var PrintFunctionVisitor = function() {
			var didChange = false;
			this.DidChange = function() { return didChange; };

			this.Visit = function(node) {
				if (node.type != "function") {
					return;
				}

				if (node.name === "say") {
					node.name = "print";
					didChange = true;
				}
			};
		};

		for (dlgId in dialog) {
			var dialogScript = scriptInterpreter.Parse(dialog[dlgId].src);
			var visitor = new PrintFunctionVisitor();
			dialogScript.VisitAll(visitor);
			if (visitor.DidChange()) {
				var newDialog = dialogScript.Serialize();
				if (newDialog.indexOf("\n") > -1) {
					newDialog = '"""\n' + newDialog + '\n"""';
				}
				dialog[dlgId].src = newDialog;
			}
		}
	}
}

//TODO this is in progress and doesn't support all features
function serializeWorld(skipFonts) {
	if (skipFonts === undefined || skipFonts === null)
		skipFonts = false;

	var worldStr = "";
	/* TITLE */
	worldStr += getTitle() + "\n";
	worldStr += "\n";
	/* VERSION */
	worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	if (version.devBuildPhase != "RELEASE") {
		worldStr += "# DEVELOPMENT BUILD -- " + version.devBuildPhase;
	}
	worldStr += "\n";
	/* FLAGS */
	for (f in flags) {
		worldStr += "! " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n"
	/* FONT */
	if (fontName != defaultFontName) {
		worldStr += "DEFAULT_FONT " + fontName + "\n";
		worldStr += "\n"
	}
	if (textDirection != TextDirection.LeftToRight) {
		worldStr += "TEXT_DIRECTION " + textDirection + "\n";
		worldStr += "\n"
	}
	/* PALETTE */
	for (id in palette) {
		if (id != "default") {
			worldStr += "PAL " + id + "\n";
			if( palette[id].name != null )
				worldStr += "NAME " + palette[id].name + "\n";
			for (i in getPal(id)) {
				for (j in getPal(id)[i]) {
					worldStr += getPal(id)[i][j];
					if (j < 2) worldStr += ",";
				}
				worldStr += "\n";
			}
			worldStr += "\n";
		}
	}
	/* ROOM */
	for (id in room) {
		worldStr += "ROOM " + id + "\n";
		if ( flags.ROOM_FORMAT == 0 ) {
			// old non-comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];	
				}
				worldStr += "\n";
			}
		}
		else if ( flags.ROOM_FORMAT == 1 ) {
			// new comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
					if (j < room[id].tilemap[i].length-1) worldStr += ","
				}
				worldStr += "\n";
			}
		}
		if (room[id].name != null) {
			/* NAME */
			worldStr += "NAME " + room[id].name + "\n";
		}
		if (room[id].walls.length > 0) {
			/* WALLS */
			worldStr += "WAL ";
			for (j in room[id].walls) {
				worldStr += room[id].walls[j];
				if (j < room[id].walls.length-1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		if (room[id].items.length > 0) {
			/* ITEMS */
			for (j in room[id].items) {
				var itm = room[id].items[j];
				worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
				worldStr += "\n";
			}
		}
		if (room[id].exits.length > 0) {
			/* EXITS */
			for (j in room[id].exits) {
				var e = room[id].exits[j];
				if ( isExitValid(e) ) {
					worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
					if (e.transition_effect != undefined && e.transition_effect != null) {
						worldStr += " FX " + e.transition_effect;
					}
					if (e.dlg != undefined && e.dlg != null) {
						worldStr += " DLG " + e.dlg;
					}
					worldStr += "\n";
				}
			}
		}
		if (room[id].endings.length > 0) {
			/* ENDINGS */
			for (j in room[id].endings) {
				var e = room[id].endings[j];
				// todo isEndingValid
				worldStr += "END " + e.id + " " + e.x + "," + e.y;
				worldStr += "\n";
			}
		}
		if (room[id].pal != null && room[id].pal != "default") {
			/* PALETTE */
			worldStr += "PAL " + room[id].pal + "\n";
		}
		worldStr += "\n";
	}
	/* TILES */
	for (id in tile) {
		worldStr += "TIL " + id + "\n";
		worldStr += serializeDrawing( "TIL_" + id );
		if (tile[id].name != null && tile[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + tile[id].name + "\n";
		}
		if (tile[id].isWall != null && tile[id].isWall != undefined) {
			/* WALL */
			worldStr += "WAL " + tile[id].isWall + "\n";
		}
		if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + tile[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* SPRITES */
	for (id in sprite) {
		worldStr += "SPR " + id + "\n";
		worldStr += serializeDrawing( "SPR_" + id );
		if (sprite[id].name != null && sprite[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + sprite[id].name + "\n";
		}
		if (sprite[id].dlg != null) {
			worldStr += "DLG " + sprite[id].dlg + "\n";
		}
		if (sprite[id].room != null) {
			/* SPRITE POSITION */
			worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
		}
		if (sprite[id].inventory != null) {
			for(itemId in sprite[id].inventory) {
				worldStr += "ITM " + itemId + " " + sprite[id].inventory[itemId] + "\n";
			}
		}
		if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + sprite[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* ITEMS */
	for (id in item) {
		worldStr += "ITM " + id + "\n";
		worldStr += serializeDrawing( "ITM_" + id );
		if (item[id].name != null && item[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + item[id].name + "\n";
		}
		if (item[id].dlg != null) {
			worldStr += "DLG " + item[id].dlg + "\n";
		}
		if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + item[id].col + "\n";
		}
		worldStr += "\n";
	}
	/* DIALOG */
	for (id in dialog) {
		if (id != titleDialogId) {
			worldStr += "DLG " + id + "\n";
			worldStr += dialog[id].src + "\n";
			if (dialog[id].name != null) {
				worldStr += "NAME " + dialog[id].name + "\n";
			}
			worldStr += "\n";
		}
	}
	/* VARIABLES */
	for (id in variable) {
		worldStr += "VAR " + id + "\n";
		worldStr += variable[id] + "\n";
		worldStr += "\n";
	}
	/* FONT */
	// TODO : support multiple fonts
	if (fontName != defaultFontName && !skipFonts) {
		worldStr += fontManager.GetData(fontName);
	}

	return worldStr;
}

function serializeDrawing(drwId) {
	var drawingData = renderer.GetDrawingSource(drwId);
	var drwStr = "";
	for (f in drawingData) {
		for (y in drawingData[f]) {
			var rowStr = "";
			for (x in drawingData[f][y]) {
				rowStr += drawingData[f][y][x];
			}
			drwStr += rowStr + "\n";
		}
		if (f < (drawingData.length-1)) drwStr += ">\n";
	}
	return drwStr;
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < 16 && e.y >= 0 && e.y < 16;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < 16 && e.dest.y >= 0 && e.dest.y < 16);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function placeSprites() {
	for (id in spriteStartLocations) {
		//bitsyLog(id);
		//bitsyLog( spriteStartLocations[id] );
		//bitsyLog(sprite[id]);
		sprite[id].room = spriteStartLocations[id].room;
		sprite[id].x = spriteStartLocations[id].x;
		sprite[id].y = spriteStartLocations[id].y;
		//bitsyLog(sprite[id]);
	}
}

/* ARGUMENT GETTERS */
function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getArg(line,arg) {
	return line.split(" ")[arg];
}

function getCoord(line,arg) {
	return getArg(line,arg).split(",");
}

function parseTitle(lines, i) {
	var results = scriptUtils.ReadDialogScript(lines,i);
	setTitle(results.script);
	i = results.index;

	i++;

	return i;
}

function parseRoom(lines, i, compatibilityFlags) {
	var id = getId(lines[i]);
	room[id] = {
		id : id,
		tilemap : [],
		walls : [],
		exits : [],
		endings : [],
		items : [],
		pal : null,
		name : null
	};
	i++;

	// create tile map
	if ( flags.ROOM_FORMAT == 0 ) {
		// old way: no commas, single char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lines[i].charAt(x) );
			}
			y++;
		}
	}
	else if ( flags.ROOM_FORMAT == 1 ) {
		// new way: comma separated, multiple char tile ids
		var end = i + mapsize;
		var y = 0;
		for (; i<end; i++) {
			room[id].tilemap.push( [] );
			var lineSep = lines[i].split(",");
			for (x = 0; x<mapsize; x++) {
				room[id].tilemap[y].push( lineSep[x] );
			}
			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		// bitsyLog(getType(lines[i]));
		if (getType(lines[i]) === "SPR") {
			/* NOTE SPRITE START LOCATIONS */
			var sprId = getId(lines[i]);
			if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
				/* PLACE A SINGLE SPRITE */
				var sprCoord = lines[i].split(" ")[2].split(",");
				spriteStartLocations[sprId] = {
					room : id,
					x : parseInt(sprCoord[0]),
					y : parseInt(sprCoord[1])
				};
			}
			else if ( flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
				/* PLACE MULTIPLE SPRITES*/ 
				//Does find and replace in the tilemap (may be hacky, but its convenient)
				var sprList = sprId.split(",");
				for (row in room[id].tilemap) {
					for (s in sprList) {
						var col = room[id].tilemap[row].indexOf( sprList[s] );
						//if the sprite is in this row, replace it with the "null tile" and set its starting position
						if (col != -1) {
							room[id].tilemap[row][col] = "0";
							spriteStartLocations[ sprList[s] ] = {
								room : id,
								x : parseInt(col),
								y : parseInt(row)
							};
						}
					}
				}
			}
		}
		else if (getType(lines[i]) === "ITM") {
			var itmId = getId(lines[i]);
			var itmCoord = lines[i].split(" ")[2].split(",");
			var itm = {
				id: itmId,
				x : parseInt(itmCoord[0]),
				y : parseInt(itmCoord[1])
			};
			room[id].items.push( itm );
		}
		else if (getType(lines[i]) === "WAL") {
			/* DEFINE COLLISIONS (WALLS) */
			room[id].walls = getId(lines[i]).split(",");
		}
		else if (getType(lines[i]) === "EXT") {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
			var exitCoords = exitArgs[1].split(",");
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(",");
			var ext = {
				x : parseInt(exitCoords[0]),
				y : parseInt(exitCoords[1]),
				dest : {
					room : destName,
					x : parseInt(destCoords[0]),
					y : parseInt(destCoords[1])
				},
				transition_effect : null,
				dlg: null,
			};

			// optional arguments
			var exitArgIndex = 4;
			while (exitArgIndex < exitArgs.length) {
				if (exitArgs[exitArgIndex] == "FX") {
					ext.transition_effect = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else if (exitArgs[exitArgIndex] == "DLG") {
					ext.dlg = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else {
					exitArgIndex += 1;
				}
			}

			room[id].exits.push(ext);
		}
		else if (getType(lines[i]) === "END") {
			/* ADD ENDING */
			var endId = getId(lines[i]);

			// compatibility with when endings were stored separate from other dialog
			if (compatibilityFlags.combineEndingsWithDialog) {
				endId = "end_" + endId;
			}

			var endCoords = getCoord(lines[i], 2);
			var end = {
				id : endId,
				x : parseInt(endCoords[0]),
				y : parseInt(endCoords[1])
			};

			room[id].endings.push(end);
		}
		else if (getType(lines[i]) === "PAL") {
			/* CHOOSE PALETTE (that's not default) */
			room[id].pal = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			room[id].name = name;
			names.room[name] = id;
		}

		i++;
	}

	return i;
}

function parsePalette(lines,i) { //todo this has to go first right now :(
	var id = getId(lines[i]);
	i++;
	var colors = [];
	var name = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");
		if (args[0] === "NAME") {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else {
			var col = [];
			lines[i].split(",").forEach(function(i) {
				col.push(parseInt(i));
			});
			colors.push(col);
		}
		i++;
	}
	palette[id] = {
		id : id,
		name : name,
		colors : colors
	};
	return i;
}

function parseTile(lines, i) {
	var id = getId(lines[i]);
	var tileData = createDrawingData("TIL", id);

	i++;

	// read & store tile image source
	i = parseDrawingCore(lines, i, tileData.drw);

	// update animation info
	tileData.animation.frameCount = renderer.GetFrameCount(tileData.drw);
	tileData.animation.isAnimated = tileData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			tileData.col = parseInt(getId(lines[i]));
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			tileData.name = lines[i].split(/\s(.+)/)[1];
			names.tile[tileData.name] = id;
		}
		else if (getType(lines[i]) === "WAL") {
			var wallArg = getArg(lines[i], 1);
			if (wallArg === "true") {
				tileData.isWall = true;
			}
			else if (wallArg === "false") {
				tileData.isWall = false;
			}
		}

		i++;
	}

	// store tile data
	tile[id] = tileData;

	return i;
}

function parseSprite(lines, i) {
	var id = getId(lines[i]);
	var type = (id === "A") ? "AVA" : "SPR";
	var spriteData = createDrawingData(type, id);

	bitsyLog(spriteData);

	i++;

	// read & store sprite image source
	i = parseDrawingCore(lines, i, spriteData.drw);

	// update animation info
	spriteData.animation.frameCount = renderer.GetFrameCount(spriteData.drw);
	spriteData.animation.isAnimated = spriteData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			spriteData.col = parseInt(getId(lines[i]));
		}
		else if (getType(lines[i]) === "POS") {
			/* STARTING POSITION */
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(",");
			spriteStartLocations[id] = {
				room : roomId,
				x : parseInt(coordArgs[0]),
				y : parseInt(coordArgs[1])
			};
		}
		else if(getType(lines[i]) === "DLG") {
			spriteData.dlg = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			spriteData.name = lines[i].split(/\s(.+)/)[1];
			names.sprite[spriteData.name] = id;
		}
		else if (getType(lines[i]) === "ITM") {
			/* ITEM STARTING INVENTORY */
			var itemId = getId(lines[i]);
			var itemCount = parseFloat(getArg(lines[i], 2));
			spriteData.inventory[itemId] = itemCount;
		}

		i++;
	}

	// store sprite data
	sprite[id] = spriteData;

	return i;
}

function parseItem(lines, i) {
	var id = getId(lines[i]);
	var itemData = createDrawingData("ITM", id);

	i++;

	// read & store item image source
	i = parseDrawingCore(lines, i, itemData.drw);

	// update animation info
	itemData.animation.frameCount = renderer.GetFrameCount(itemData.drw);
	itemData.animation.isAnimated = itemData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			itemData.col = parseInt(getArg(lines[i], 1));
		}
		else if (getType(lines[i]) === "DLG") {
			itemData.dlg = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			itemData.name = lines[i].split(/\s(.+)/)[1];
			names.item[itemData.name] = id;
		}

		i++;
	}

	// store item data
	item[id] = itemData;

	return i;
}

function parseDrawing(lines, i) {
	// store drawing source
	var drwId = getId( lines[i] );
	return parseDrawingCore( lines, i, drwId );
}

function parseDrawingCore(lines, i, drwId) {
	var frameList = []; //init list of frames
	frameList.push( [] ); //init first frame
	var frameIndex = 0;
	var y = 0;
	while ( y < tilesize ) {
		var l = lines[i+y];
		var row = [];
		for (x = 0; x < tilesize; x++) {
			row.push( parseInt( l.charAt(x) ) );
		}
		frameList[frameIndex].push( row );
		y++;

		if (y === tilesize) {
			i = i + y;
			if ( lines[i] != undefined && lines[i].charAt(0) === ">" ) {
				// start next frame!
				frameList.push( [] );
				frameIndex++;
				//start the count over again for the next frame
				i++;
				y = 0;
			}
		}
	}

	renderer.SetDrawingSource(drwId, frameList);

	return i;
}

// creates a drawing data structure with default property values for the type
function createDrawingData(type, id) {
	// the avatar's drawing id still uses the sprite prefix (for back compat)
	var drwId = (type === "AVA" ? "SPR" : type) + "_" + id;

	var drawingData = {
		type : type,
		id : id,
		name : null,
		drw : drwId,
		col : (type === "TIL") ? 1 : 2,
		animation : {
			isAnimated : false,
			frameIndex : 0,
			frameCount : 1,
		},
	};

	// add type specific properties
	if (type === "TIL") {
		// default null value indicates it can vary from room to room (original version)
		drawingData.isWall = null;
	}

	if (type === "AVA" || type === "SPR") {
		// default sprite location is "offstage"
		drawingData.room = null;
		drawingData.x = -1;
		drawingData.y = -1;
		drawingData.inventory = {};
	}

	if (type === "AVA" || type === "SPR" || type === "ITM") {
		drawingData.dlg = null;
	}

	return drawingData;
}

function parseScript(lines, i, backCompatPrefix, compatibilityFlags) {
	var id = getId(lines[i]);
	id = backCompatPrefix + id;
	i++;

	var results = scriptUtils.ReadDialogScript(lines,i);

	dialog[id] = { src: results.script, name: null, id: id, };

	if (compatibilityFlags.convertImplicitSpriteDialogIds) {
		// explicitly hook up dialog that used to be implicitly
		// connected by sharing sprite and dialog IDs in old versions
		if (sprite[id]) {
			if (sprite[id].dlg === undefined || sprite[id].dlg === null) {
				sprite[id].dlg = id;
			}
		}
	}

	i = results.index;

	return i;
}

function parseDialog(lines, i, compatibilityFlags) {
	// hacky but I need to store this so I can set the name below
	var id = getId(lines[i]);

	i = parseScript(lines, i, "", compatibilityFlags);

	if (lines[i].length > 0 && getType(lines[i]) === "NAME") {
		dialog[id].name = lines[i].split(/\s(.+)/)[1]; // TODO : hacky to keep copying this regex around...
		names.dialog[dialog[id].name] = id;
		i++;
	}

	return i;
}

// keeping this around to parse old files where endings were separate from dialogs
function parseEnding(lines, i, compatibilityFlags) {
	return parseScript(lines, i, "end_", compatibilityFlags);
}

function parseVariable(lines, i) {
	var id = getId(lines[i]);
	i++;
	var value = lines[i];
	i++;
	variable[id] = value;
	return i;
}

function parseFontName(lines, i) {
	fontName = getArg(lines[i], 1);
	i++;
	return i;
}

function parseTextDirection(lines, i) {
	textDirection = getArg(lines[i], 1);
	i++;
	return i;
}

function parseFontData(lines, i) {
	// NOTE : we're not doing the actual parsing here --
	// just grabbing the block of text that represents the font
	// and giving it to the font manager to use later

	var localFontName = getId(lines[i]);
	var localFontData = lines[i];
	i++;

	while (i < lines.length && lines[i] != "") {
		localFontData += "\n" + lines[i];
		i++;
	}

	var localFontFilename = localFontName + fontManager.GetExtension();
	fontManager.AddResource( localFontFilename, localFontData );

	return i;
}

function parseFlag(lines, i) {
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	flags[id] = parseInt( valStr );
	i++;
	return i;
}

function drawTile(tileId, x, y) {
	bitsyDrawBegin(0);
	bitsyDrawTile(tileId, x, y);
	bitsyDrawEnd();
}

function drawSprite(tileId, x, y) {
	drawTile(tileId, x, y);
}

function drawItem(tileId, x, y) {
	drawTile(tileId, x, y);
}

// var debugLastRoomDrawn = "0";

function clearRoom() {
	var paletteId = "default";

	if (room === undefined) {
		// protect against invalid rooms
		return;
	}

	if (room.pal != null && palette[paletteId] != undefined) {
		paletteId = room.pal;
	}

	bitsyDrawBegin(0);
	bitsyClear(tileColorStartIndex);
	bitsyDrawEnd();
}

function drawRoom(room, frameIndex) { // frameIndex is optional
	// if (room.id != debugLastRoomDrawn) {
	// 	debugLastRoomDrawn = room.id;
	// 	bitsyLog("DRAW ROOM " + debugLastRoomDrawn);
	// }

	if (room === undefined) {
		// protect against invalid rooms
		return;
	}

	// clear the screen buffer
	bitsyDrawBegin(0);
	bitsyClear(tileColorStartIndex);
	bitsyDrawEnd();

	//draw tiles
	for (i in room.tilemap) {
		for (j in room.tilemap[i]) {
			var id = room.tilemap[i][j];
			var x = parseInt(j);
			var y = parseInt(i);

			if (id != "0") {
				//bitsyLog(id);
				if (tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
					id = "0";
					room.tilemap[i][j] = id;
				}
				else {
					// bitsyLog(id);
					drawTile(getTileFrame(tile[id], frameIndex), x, y);
				}
			}
		}
	}

	//draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		drawItem(getItemFrame(item[itm.id], frameIndex), itm.x, itm.y);
	}

	//draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === room.id) {
			drawSprite(getSpriteFrame(spr, frameIndex), spr.x, spr.y);
		}
	}
}

// TODO : remove these get*Image methods
function getTileFrame(t, frameIndex) {
	return renderer.GetDrawingFrame(t, frameIndex);
}

function getSpriteFrame(s, frameIndex) {
	return renderer.GetDrawingFrame(s, frameIndex);
}

function getItemFrame(itm, frameIndex) {
	return renderer.GetDrawingFrame(itm, frameIndex);
}

function curPal() {
	return getRoomPal(curRoom);
}

function getRoomPal(roomId) {
	var defaultId = "default";

	if (roomId == null) {
		return defaultId;
	}
	else if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return defaultId;
		}
	}
	return defaultId;
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;
var dialogModule = new Dialog();
var dialogRenderer = dialogModule.CreateRenderer();
var dialogBuffer = dialogModule.CreateBuffer();
var fontManager = new FontManager();

// TODO : is this scriptResult thing being used anywhere???
function onExitDialog(scriptResult, dialogCallback) {
	bitsyLog("EXIT DIALOG!");

	isDialogMode = false;

	if (isNarrating) {
		isNarrating = false;
	}

	if (isDialogPreview) {
		isDialogPreview = false;

		if (onDialogPreviewEnd != null) {
			onDialogPreviewEnd();
		}
	}

	if (dialogCallback != undefined && dialogCallback != null) {
		dialogCallback(scriptResult);
	}
}

/*
TODO
- titles and endings should also take advantage of the script pre-compilation if possible??
- could there be a namespace collision?
- what about dialog NAMEs vs IDs?
- what about a special script block separate from DLG?
*/
function startNarrating(dialogStr,end) {
	bitsyLog("NARRATE " + dialogStr);

	if(end === undefined) {
		end = false;
	}

	isNarrating = true;
	isEnding = end;

	startDialog(dialogStr);
}

function startEndingDialog(ending) {
	isNarrating = true;
	isEnding = true;

	startDialog(
		dialog[ending.id].src,
		ending.id,
		function() {
			var isLocked = ending.property && ending.property.locked === true;
			if (isLocked) {
				isEnding = false;
			}
		},
		ending);
}

function startItemDialog(itemId, dialogCallback) {
	var dialogId = item[itemId].dlg;
	// bitsyLog("START ITEM DIALOG " + dialogId);
	if (dialog[dialogId]) {
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr, dialogId, dialogCallback);
	}
	else {
		dialogCallback();
	}
}

function startSpriteDialog(spriteId) {
	var spr = sprite[spriteId];
	var dialogId = spr.dlg;
	// bitsyLog("START SPRITE DIALOG " + dialogId);
	if (dialog[dialogId]){
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr,dialogId);
	}
}

function startDialog(dialogStr, scriptId, dialogCallback, objectContext) {
	// bitsyLog("START DIALOG ");
	if (dialogStr.length <= 0) {
		// bitsyLog("ON EXIT DIALOG -- startDialog 1");
		onExitDialog(null, dialogCallback);
		return;
	}

	isDialogMode = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(isNarrating /*centered*/);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	var onScriptEnd = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, dialogCallback);
		});
	};

	if (scriptId === undefined) { // TODO : what's this for again?
		scriptInterpreter.Interpret(dialogStr, onScriptEnd);
	}
	else {
		if (!scriptInterpreter.HasScript(scriptId)) {
			scriptInterpreter.Compile(scriptId, dialogStr);
		}
		// scriptInterpreter.DebugVisualizeScript(scriptId);
		scriptInterpreter.Run(scriptId, onScriptEnd, objectContext);
	}

}

var isDialogPreview = false;
function startPreviewDialog(script, dialogCallback) {
	isNarrating = true;

	isDialogMode = true;

	isDialogPreview = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(true);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	// TODO : do I really need a seperate callback for this debug mode??
	onDialogPreviewEnd = dialogCallback;

	var onScriptEndCallback = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, null);
		});
	};

	scriptInterpreter.Eval(script, onScriptEndCallback);
}

/* NEW SCRIPT STUFF */
var scriptModule = new Script();
var scriptInterpreter = scriptModule.CreateInterpreter();
var scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?
// scriptInterpreter.SetDialogBuffer( dialogBuffer );

/* EVENTS */
bitsyOnUpdate(update);
bitsyOnQuit(stopGame);
bitsyOnLoad(load_game);
</script>

<!-- store default font in separate script tag for back compat-->
<!-- Borksy modification: uses better encoded default font. -->
<script type="text/bitsyFontData" id="ascii_small">
FONT ascii_small
SIZE 6 8
CHAR 0
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000100
001110
001110
000100
000100
000000
000100
000000
CHAR 34
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 35
000000
001010
011111
001010
001010
011111
001010
000000
CHAR 36
001000
001110
010000
001100
000010
011100
000100
000000
CHAR 37
011001
011001
000010
000100
001000
010011
010011
000000
CHAR 38
001000
010100
010100
001000
010101
010010
001101
000000
CHAR 39
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 40
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
001010
001110
011111
001110
001010
000000
000000
CHAR 43
000000
000100
000100
011111
000100
000100
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
001100
001000
CHAR 45
000000
000000
000000
011111
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
CHAR 47
000000
000001
000010
000100
001000
010000
000000
000000
CHAR 48
001110
010001
010011
010101
011001
010001
001110
000000
CHAR 49
000100
001100
000100
000100
000100
000100
001110
000000
CHAR 50
001110
010001
000001
000110
001000
010000
011111
000000
CHAR 51
001110
010001
000001
001110
000001
010001
001110
000000
CHAR 52
000010
000110
001010
010010
011111
000010
000010
000000
CHAR 53
011111
010000
010000
011110
000001
010001
001110
000000
CHAR 54
000110
001000
010000
011110
010001
010001
001110
000000
CHAR 55
011111
000001
000010
000100
001000
001000
001000
000000
CHAR 56
001110
010001
010001
001110
010001
010001
001110
000000
CHAR 57
001110
010001
010001
001111
000001
000010
001100
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
CHAR 59
000000
000000
001100
001100
000000
001100
001100
001000
CHAR 60
000010
000100
001000
010000
001000
000100
000010
000000
CHAR 61
000000
000000
011111
000000
000000
011111
000000
000000
CHAR 62
001000
000100
000010
000001
000010
000100
001000
000000
CHAR 63
001110
010001
000001
000110
000100
000000
000100
000000
CHAR 64
001110
010001
010111
010101
010111
010000
001110
000000
CHAR 65
001110
010001
010001
010001
011111
010001
010001
000000
CHAR 66
011110
010001
010001
011110
010001
010001
011110
000000
CHAR 67
001110
010001
010000
010000
010000
010001
001110
000000
CHAR 68
011110
010001
010001
010001
010001
010001
011110
000000
CHAR 69
011111
010000
010000
011110
010000
010000
011111
000000
CHAR 70
011111
010000
010000
011110
010000
010000
010000
000000
CHAR 71
001110
010001
010000
010111
010001
010001
001111
000000
CHAR 72
010001
010001
010001
011111
010001
010001
010001
000000
CHAR 73
001110
000100
000100
000100
000100
000100
001110
000000
CHAR 74
000001
000001
000001
000001
010001
010001
001110
000000
CHAR 75
010001
010010
010100
011000
010100
010010
010001
000000
CHAR 76
010000
010000
010000
010000
010000
010000
011111
000000
CHAR 77
010001
011011
010101
010001
010001
010001
010001
000000
CHAR 78
010001
011001
010101
010011
010001
010001
010001
000000
CHAR 79
001110
010001
010001
010001
010001
010001
001110
000000
CHAR 80
011110
010001
010001
011110
010000
010000
010000
000000
CHAR 81
001110
010001
010001
010001
010101
010010
001101
000000
CHAR 82
011110
010001
010001
011110
010010
010001
010001
000000
CHAR 83
001110
010001
010000
001110
000001
010001
001110
000000
CHAR 84
011111
000100
000100
000100
000100
000100
000100
000000
CHAR 85
010001
010001
010001
010001
010001
010001
001110
000000
CHAR 86
010001
010001
010001
010001
010001
001010
000100
000000
CHAR 87
010001
010001
010101
010101
010101
010101
001010
000000
CHAR 88
010001
010001
001010
000100
001010
010001
010001
000000
CHAR 89
010001
010001
010001
001010
000100
000100
000100
000000
CHAR 90
011110
000010
000100
001000
010000
010000
011110
000000
CHAR 91
001110
001000
001000
001000
001000
001000
001110
000000
CHAR 92
000000
010000
001000
000100
000010
000001
000000
000000
CHAR 93
001110
000010
000010
000010
000010
000010
001110
000000
CHAR 94
000100
001010
010001
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 96
001100
001100
000100
000000
000000
000000
000000
000000
CHAR 97
000000
000000
001110
000001
001111
010001
001111
000000
CHAR 98
010000
010000
011110
010001
010001
010001
011110
000000
CHAR 99
000000
000000
001110
010001
010000
010001
001110
000000
CHAR 100
000001
000001
001111
010001
010001
010001
001111
000000
CHAR 101
000000
000000
001110
010001
011110
010000
001110
000000
CHAR 102
000110
001000
001000
011110
001000
001000
001000
000000
CHAR 103
000000
000000
001111
010001
010001
001111
000001
001110
CHAR 104
010000
010000
011100
010010
010010
010010
010010
000000
CHAR 105
000100
000000
000100
000100
000100
000100
000110
000000
CHAR 106
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 107
010000
010000
010010
010100
011000
010100
010010
000000
CHAR 108
000100
000100
000100
000100
000100
000100
000110
000000
CHAR 109
000000
000000
011010
010101
010101
010001
010001
000000
CHAR 110
000000
000000
011100
010010
010010
010010
010010
000000
CHAR 111
000000
000000
001110
010001
010001
010001
001110
000000
CHAR 112
000000
000000
011110
010001
010001
010001
011110
010000
CHAR 113
000000
000000
001111
010001
010001
010001
001111
000001
CHAR 114
000000
000000
010110
001001
001000
001000
011100
000000
CHAR 115
000000
000000
001110
010000
001110
000001
001110
000000
CHAR 116
000000
001000
011110
001000
001000
001010
000100
000000
CHAR 117
000000
000000
010010
010010
010010
010110
001010
000000
CHAR 118
000000
000000
010001
010001
010001
001010
000100
000000
CHAR 119
000000
000000
010001
010001
010101
011111
001010
000000
CHAR 120
000000
000000
010010
010010
001100
010010
010010
000000
CHAR 121
000000
000000
010010
010010
010010
001110
000100
011000
CHAR 122
000000
000000
011110
000010
001100
010000
011110
000000
CHAR 123
000110
001000
001000
011000
001000
001000
000110
000000
CHAR 124
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 125
001100
000010
000010
000011
000010
000010
001100
000000
CHAR 126
000000
000000
000000
001010
010100
000000
000000
000000
CHAR 160
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 161
000100
000000
000100
000100
001110
001110
000100
000000
CHAR 162
000000
000100
001110
010000
010000
001110
000100
000000
CHAR 163
000110
001001
001000
011110
001000
001001
010111
000000
CHAR 165
010001
001010
000100
011111
000100
011111
000100
000000
CHAR 167
001110
010001
001100
001010
000110
010001
001110
000000
CHAR 171
000000
000000
001001
010010
001001
000000
000000
000000
CHAR 172
000000
000000
111111
000001
000001
000000
000000
000000
CHAR 177
000000
000100
001110
000100
000000
001110
000000
000000
CHAR 178
011000
000100
001000
011100
000000
000000
000000
000000
CHAR 181
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 182
001111
010101
010101
001101
000101
000101
000101
000000
CHAR 187
000000
000000
010010
001001
010010
000000
000000
000000
CHAR 188
010000
010010
010100
001011
010101
000111
000001
000000
CHAR 189
010000
010010
010100
001110
010001
000010
000111
000000
CHAR 191
000100
000000
000100
001100
010000
010001
001110
000000
CHAR 196
001010
000000
000100
001010
010001
011111
010001
000000
CHAR 197
001110
001010
001110
011011
010001
011111
010001
000000
CHAR 198
001111
010100
010100
011111
010100
010100
010111
000000
CHAR 199
001110
010001
010000
010000
010001
001110
000100
001100
CHAR 201
000011
000000
011111
010000
011110
010000
011111
000000
CHAR 209
001010
010100
000000
010010
011010
010110
010010
000000
CHAR 214
010010
001100
010010
010010
010010
010010
001100
000000
CHAR 220
001010
000000
010010
010010
010010
010010
001100
000000
CHAR 223
000000
011100
010010
011100
010010
010010
011100
010000
CHAR 224
001100
000000
001110
000001
001111
010001
001111
000000
CHAR 225
000110
000000
001110
000001
001111
010001
001111
000000
CHAR 226
001110
000000
001110
000001
001111
010001
001111
000000
CHAR 228
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 229
001110
001010
001110
000001
001111
010001
001111
000000
CHAR 230
000000
000000
011110
000101
011111
010100
001111
000000
CHAR 231
000000
001110
010001
010000
010001
001110
000100
001100
CHAR 232
001100
000000
001110
010001
011110
010000
001110
000000
CHAR 233
000011
000000
001110
010001
011110
010000
001110
000000
CHAR 234
001110
000000
001110
010001
011110
010000
001110
000000
CHAR 235
001010
000000
001110
010001
011110
010000
001110
000000
CHAR 236
001000
000000
000100
000100
000100
000100
000110
000000
CHAR 237
000110
000000
000100
000100
000100
000100
000110
000000
CHAR 238
000100
001010
000000
000100
000100
000100
000110
000000
CHAR 239
001010
000000
000100
000100
000100
000100
000110
000000
CHAR 241
001010
010100
000000
011100
010010
010010
010010
000000
CHAR 242
011000
000000
001100
010010
010010
010010
001100
000000
CHAR 243
000110
000000
001100
010010
010010
010010
001100
000000
CHAR 244
001110
000000
001100
010010
010010
010010
001100
000000
CHAR 246
001010
000000
001100
010010
010010
010010
001100
000000
CHAR 247
001010
000000
001110
010001
010001
010001
001110
000000
CHAR 249
011000
000000
010010
010010
010010
010110
001010
000000
CHAR 250
000110
000000
010010
010010
010010
010110
001010
000000
CHAR 251
001110
000000
010010
010010
010010
010110
001010
000000
CHAR 252
010010
000000
010010
010010
010010
010110
001010
000000
CHAR 255
001010
000000
010010
010010
010010
001110
000100
011000
CHAR 402
000010
000101
000100
001110
000100
000100
010100
001000
CHAR 915
011110
010010
010000
010000
010000
010000
010000
000000
CHAR 920
001100
010010
010010
011110
010010
010010
001100
000000
CHAR 931
011111
010000
001000
000100
001000
010000
011111
000000
CHAR 934
001110
000100
001110
010001
001110
000100
001110
000000
CHAR 937
000000
001110
010001
010001
001010
001010
011011
000000
CHAR 948
001100
010000
001000
000100
001110
010010
001100
000000
CHAR 949
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 960
000000
011111
001010
001010
001010
001010
001010
000000
CHAR 963
000000
000000
001111
010010
010010
001100
000000
000000
CHAR 964
000000
000000
001010
010100
000100
000100
000100
000000
CHAR 966
000000
000100
001110
010101
010101
001110
000100
000000
CHAR 8226
000000
000000
000000
001100
001100
000000
000000
000000
CHAR 8252
001010
001010
001010
001010
001010
000000
001010
000000
CHAR 8592
000000
000100
001100
011111
001100
000100
000000
000000
CHAR 8593
000100
001110
011111
000100
000100
000100
000100
000000
CHAR 8594
000000
000100
000110
011111
000110
000100
000000
000000
CHAR 8595
000100
000100
000100
000100
011111
001110
000100
000000
CHAR 8734
000000
000000
001010
010101
010101
001010
000000
000000
CHAR 8735
000000
000000
000000
010000
010000
010000
011111
000000
CHAR 8801
000000
011110
000000
011110
000000
011110
000000
000000
CHAR 8804
000010
001100
010000
001100
000010
000000
011110
000000
CHAR 8805
010000
001100
000010
001100
010000
000000
011110
000000
CHAR 8962
000100
001110
011011
010001
010001
011111
000000
000000
CHAR 8976
000000
000000
011111
010000
010000
010000
000000
000000
CHAR 9472
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 9474
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 9488
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 9492
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 9500
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 9508
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 9516
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 9524
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 9532
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 9552
000000
111111
000000
111111
000000
000000
000000
000000
CHAR 9553
010100
010100
010100
010100
010100
010100
010100
010100
CHAR 9556
000000
011111
010000
010111
010100
010100
010100
010100
CHAR 9557
000000
111100
000100
111100
000100
000100
000100
000100
CHAR 9558
000000
000000
000000
111100
010100
010100
010100
010100
CHAR 9559
000000
111100
000100
110100
010100
010100
010100
010100
CHAR 9561
010100
010100
010100
011111
000000
000000
000000
000000
CHAR 9562
010100
010111
010000
011111
000000
000000
000000
000000
CHAR 9563
000100
111100
000100
111100
000000
000000
000000
000000
CHAR 9564
010100
010100
010100
111100
000000
000000
000000
000000
CHAR 9565
010100
110100
000100
111100
000000
000000
000000
000000
CHAR 9566
000100
000111
000100
000111
000100
000100
000100
000100
CHAR 9567
010100
010100
010100
010111
010100
010100
010100
010100
CHAR 9568
010100
010111
010000
010111
010100
010100
010100
010100
CHAR 9569
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 9570
010100
010100
010100
110100
010100
010100
010100
010100
CHAR 9571
010100
110100
000100
110100
010100
010100
010100
010100
CHAR 9572
000000
111111
000000
111111
000100
000100
000100
000100
CHAR 9573
000000
000000
000000
111111
010100
010100
010100
010100
CHAR 9574
000000
111111
000000
110111
010100
010100
010100
010100
CHAR 9575
000100
111111
000000
111111
000000
000000
000000
000000
CHAR 9576
010100
010100
010100
111111
000000
000000
000000
000000
CHAR 9577
010100
110111
000000
111111
000000
000000
000000
000000
CHAR 9580
010100
110111
000000
110111
010100
010100
010100
010100
CHAR 9601
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 9602
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 9603
000000
000000
000000
000000
000000
111111
111111
111111
CHAR 9604
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 9605
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 9606
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 9607
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 9608
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 9609
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9610
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9611
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 9613
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 9615
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 9617
010101
000000
101010
000000
010101
000000
101010
000000
CHAR 9618
010101
101010
010101
101010
010101
101010
010101
101010
CHAR 9619
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 9644
000000
000000
000000
000000
000000
011110
011110
000000
CHAR 9650
000100
000100
001110
001110
011111
011111
000000
000000
CHAR 9658
001000
001100
001110
001111
001110
001100
001000
000000
CHAR 9660
011111
011111
001110
001110
000100
000100
000000
000000
CHAR 9668
000010
000110
001110
011110
001110
000110
000010
000000
CHAR 9675
000000
000000
011110
010010
010010
011110
000000
000000
CHAR 9688
111111
111111
111111
110011
110011
111111
111111
111111
CHAR 9689
111111
111111
100001
101101
101101
100001
111111
111111
CHAR 9786
001110
010001
011011
010001
010101
010001
001110
000000
CHAR 9787
001110
011111
010101
011111
010001
011111
001110
000000
CHAR 9788
000000
010101
001110
011011
001110
010101
000000
000000
CHAR 9792
001110
010001
010001
001110
000100
001110
000100
000000
CHAR 9794
000000
000111
000011
001101
010010
010010
001100
000000
CHAR 9824
000000
000100
001110
011111
011111
000100
001110
000000
CHAR 9827
000100
001110
001110
000100
011111
011111
000100
000000
CHAR 9829
000000
001010
011111
011111
011111
001110
000100
000000
CHAR 9830
000000
000100
001110
011111
011111
001110
000100
000000
CHAR 9834
000100
000110
000101
000100
001100
011100
011000
000000
CHAR 9835
000011
001101
001011
001101
001011
011011
011000
000000
</script>

<!-- BORKSY HACKS -->
<script type="text/javascript" id="borksyHacks">
/**

@file dialog choices
@summary dialog choices
@license MIT
@author Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11


@description
Adds a dialog tag which allows you to present the player with dialog choices.
Uses as an arrow cursor by default, but this can be changed in the hackOptions to use a custom bitsy sprite instead.

Usage:
{choice
  - option one
    result of picking option
  - option two
    result of picking option
}

Recommended uses:
DLG_simple_response
"""
Greeting text{choice
  - Response one
    answer to response one
  - Response two
    answer to response two
}
"""

DLG_complex_response
"""
Greeting text{choice
  - Response one
    {a = 1}
  - Response two
    {a = 2}
}
constant part of answer{
  - a == 1 ?
    custom part based on response one
  - a == 2 ?
    custom part based on response two
}
"""

This hack includes the "long dialog" hack so that the textbox
automatically expands to allow for more than 2 choices.

Note: it's recommended you combine this hack
with the dialog jump hack for complex cases.

Limitations:
Each option must fit on a single line, or the cursor
may not line up with the selected option.

Checking the value of a variable set in an option
*immediately after the choice* will not work,
as it will evaluate before the player has selected
an option if there is no text in-between the two.
e.g.
"""
{a = 1}
{choice
  - Response one
    {a = 2}
  - Response two
    {a = 3}
}
{
  - a == 1 ?
    this will print
  - a == 2 ?
    these will not
  - a == 3 ?
    these will not
}
"""

HOW TO USE:
1. Copy-paste into a script tag after the bitsy source
2. Edit hackOptions below as needed
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions =  {
	// if defined, the cursor is drawn as the sprite with the given id
	// e.g. replace with `getCursorSprite('A')` to use the player's avatar as a cursor
	// if not defined, uses an arrow graphic similar to the continue arrow
	cursor: getCursorSprite(),
	// modifies the position of the cursor
	transform: {
		y: 1,
		x: 0,
	},
	// long dialog options
	minRows: 2,
	maxRows: 2,
};

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
 * Helper used to replace code in a script tag based on a search regex.
 * To inject code without erasing original string, using capturing groups; e.g.
 * ```js
 * inject(/(some string)/,'injected before $1 injected after');
 * ```
 * @param searcher Regex to search and replace
 * @param replacer Replacer string/fn
 */
function inject$1(searcher, replacer) {
    // find the relevant script tag
    var scriptTags = document.getElementsByTagName('script');
    var scriptTag;
    var code = '';
    for (var i = 0; i < scriptTags.length; ++i) {
        scriptTag = scriptTags[i];
        if (!scriptTag.textContent)
            continue;
        var matchesSearch = scriptTag.textContent.search(searcher) !== -1;
        var isCurrentScript = scriptTag === document.currentScript;
        if (matchesSearch && !isCurrentScript) {
            code = scriptTag.textContent;
            break;
        }
    }
    // error-handling
    if (!code || !scriptTag) {
        throw new Error('Couldn\'t find "' + searcher + '" in script tags');
    }
    // modify the content
    code = code.replace(searcher, replacer);
    // replace the old script tag with a new one using our modified code
    var newScriptTag = document.createElement('script');
    newScriptTag.textContent = code;
    scriptTag.insertAdjacentElement('afterend', newScriptTag);
    scriptTag.remove();
}
/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
    return array.filter(function (item, idx) {
        return array.indexOf(item) === idx;
    });
}
// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
/** test */
function kitsyInject(searcher, replacer) {
    if (!kitsy.queuedInjectScripts.some(function (script) {
        return searcher.toString() === script.searcher.toString() && replacer === script.replacer;
    })) {
        kitsy.queuedInjectScripts.push({
            searcher: searcher,
            replacer: replacer,
        });
    }
    else {
        console.warn('Ignored duplicate inject');
    }
}
// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before$1(targetFuncName, beforeFn) {
    kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
    kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}
// Ex: after('load_game', function run() { alert('Loaded!'); });
function after$1(targetFuncName, afterFn) {
    kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
    kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}
function applyInjects() {
    kitsy.queuedInjectScripts.forEach(function (injectScript) {
        inject$1(injectScript.searcher, injectScript.replacer);
    });
}
function applyHooks(root) {
    var allHooks = unique(Object.keys(kitsy.queuedBeforeScripts).concat(Object.keys(kitsy.queuedAfterScripts)));
    allHooks.forEach(applyHook.bind(this, root || window));
}
function applyHook(root, functionName) {
    var functionNameSegments = functionName.split('.');
    var obj = root;
    while (functionNameSegments.length > 1) {
        obj = obj[functionNameSegments.shift()];
    }
    var lastSegment = functionNameSegments[0];
    var superFn = obj[lastSegment];
    var superFnLength = superFn ? superFn.length : 0;
    var functions = [];
    // start with befores
    functions = functions.concat(kitsy.queuedBeforeScripts[functionName] || []);
    // then original
    if (superFn) {
        functions.push(superFn);
    }
    // then afters
    functions = functions.concat(kitsy.queuedAfterScripts[functionName] || []);
    // overwrite original with one which will call each in order
    obj[lastSegment] = function () {
        var returnVal;
        var args = [].slice.call(arguments);
        var i = 0;
        function runBefore() {
            // All outta functions? Finish
            if (i === functions.length) {
                return returnVal;
            }
            // Update args if provided.
            if (arguments.length > 0) {
                args = [].slice.call(arguments);
            }
            if (functions[i].length > superFnLength) {
                // Assume funcs that accept more args than the original are
                // async and accept a callback as an additional argument.
                return functions[i++].apply(this, args.concat(runBefore.bind(this)));
            }
            // run synchronously
            returnVal = functions[i++].apply(this, args);
            if (returnVal && returnVal.length) {
                args = returnVal;
            }
            return runBefore.apply(this, args);
        }
        return runBefore.apply(this, arguments);
    };
}
/**
@file kitsy-script-toolkit
@summary Monkey-patching toolkit to make it easier and cleaner to run code before and after functions or to inject new code into script tags
@license WTFPL (do WTF you want)
@author Original by mildmojo; modified by Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11

*/
var kitsy = (window.kitsy = window.kitsy || {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {},
    inject: kitsyInject,
    before: before$1,
    after: after$1,
    /**
     * Applies all queued `inject` calls.
     *
     * An object that instantiates an class modified via injection will still refer to the original class,
     * so make sure to reinitialize globals that refer to injected scripts before calling `applyHooks`.
     */
    applyInjects,
    /** Apples all queued `before`/`after` calls. */
    applyHooks,
});

var hooked = kitsy.hooked;
if (!hooked) {
	kitsy.hooked = true;
	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts
		kitsy.applyInjects();

		// recreate the script and dialog objects so that they'll be
		// referencing the code with injections instead of the original
		bitsy.scriptModule = new bitsy.Script();
		bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

		bitsy.dialogModule = new bitsy.Dialog();
		bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
		bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
		bitsy.renderer = new bitsy.TileRenderer(bitsy.tilesize);

		// Hook everything
		kitsy.applyHooks();

		// reset callbacks using hacked functions
		bitsy.bitsyOnUpdate(bitsy.update);
		bitsy.bitsyOnQuit(bitsy.stopGame);
		bitsy.bitsyOnLoad(bitsy.load_game);

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};
}

/** @see kitsy.inject */
var inject = kitsy.inject;
/** @see kitsy.before */
var before = kitsy.before;
/** @see kitsy.after */
var after = kitsy.after;

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".*?"|.+?))?)\\\\?\\)', 'g'), function (match, group) {
		if (match.substr(0, 1) === '\\') {
			return '(' + group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
		}
		return '{' + group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
	});
}

function addDialogFunction(tag, fn) {
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		console.warn('The dialog function "' + tag + '" already exists.');
		return;
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (gameData) {
		return [convertDialogTags(gameData, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

function injectDialogTag(tag, code) {
	inject(/(var functionMap = \{\};[^]*?)(this.HasFunction)/m, '$1\nfunctionMap["' + tag + '"] = ' + code + ';\n$2');
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	injectDialogTag(tag, 'kitsy.dialogFunctions["' + tag + '"]');
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
	var deferred = (bitsy.kitsy.deferredDialogFunctions[tag] = []);
	injectDialogTag(tag, 'function(e, p, o){ kitsy.deferredDialogFunctions["' + tag + '"].push({e:e,p:p}); o(null); }');
	// Hook into the dialog finish event and execute the actual function
	after('onExitDialog', function () {
		while (deferred.length) {
			var args = deferred.shift();
			bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
		}
	});
	// Hook into the game reset and make sure data gets cleared
	after('clearGameData', function () {
		deferred.length = 0;
	});
}

/**
 * Adds two custom dialog tags which execute the provided function,
 * one with the provided tagname executed after the dialog box,
 * and one suffixed with 'Now' executed immediately when the tag is reached.
 *
 * i.e. helper for the (exit)/(exitNow) pattern.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDualDialogTag(tag, fn) {
	addDialogTag(tag + 'Now', function (environment, parameters, onReturn) {
		fn(environment, parameters);
		onReturn(null);
	});
	addDeferredDialogTag(tag, fn);
}

/**
 * Helper for printing a paragraph break inside of a dialog function.
 * Adds the function `AddParagraphBreak` to `DialogBuffer`
 */

inject(/(this\.AddLinebreak = )/, 'this.AddParagraphBreak = function() { buffer.push( [[]] ); isActive = true; };\n$1');

/**

@file paragraph-break
@summary Adds paragraph breaks to the dialogue parser
@license WTFPL (do WTF you want)
@author Sean S. LeBlanc, David Mowatt
@version 19.2.7
@requires Bitsy 7.11


@description
Adds a (p) tag to the dialogue parser that forces the following text to
start on a fresh dialogue screen, eliminating the need to spend hours testing
line lengths or adding multiple line breaks that then have to be reviewed
when you make edits or change the font size.

Note: Bitsy has a built-in implementation of paragraph-break as of 7.0;
before using this, you may want to check if it fulfills your needs.

Usage: (p)

Example: I am a cat(p)and my dialogue contains multitudes

HOW TO USE:
  1. Copy-paste this script into a new script tag after the Bitsy source code.
     It should appear *before* any other mods that handle loading your game
     data so it executes *after* them (last-in first-out).

NOTE: This uses parentheses "()" instead of curly braces "{}" around function
      calls because the Bitsy editor's fancy dialog window strips unrecognized
      curly-brace functions from dialog text. To keep from losing data, write
      these function calls with parentheses like the examples above.

      For full editor integration, you'd *probably* also need to paste this
      code at the end of the editor's `bitsy.js` file. Untested.
*/

// Adds the actual dialogue tag. No deferred version is required.
addDialogTag('p', function (environment, parameters, onReturn) {
	environment.GetDialogBuffer().AddParagraphBreak();
	onReturn(null);
});
// End of (p) paragraph break mod

/**

@file long dialog
@summary put more words onscreen
@license MIT
@author Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11


@description
Makes the dialog box variable in height, allowing it to expand as needed.

Minimum and maximum size are configurable.
Cheat sheet:
	2: bitsy default
	8: reaches just below the halfway mark
	16: roughly the max of the original bitsy margins
	19: max before cutting off text

Note: this hack also includes the paragraph break hack
A common pattern in bitsy is using intentional whitespace to force new dialog pages,
but the long dialog hack makes that look awkward since the text box expands.
The paragraph break hack lets you get around this by using a (p) tag to immediately end the current page.

There is also a dialog tag that lets you change the size ingame.

Usage:
	(textboxsize "<min>,<max>")
	(textboxsizeNow "<min>,<max>")

Examples:
	(textboxsize "2,6")
	(textboxsizeNow "2,2")

HOW TO USE:
	1. Copy-paste this script into a new script tag after the Bitsy source code.
	2. edit hackOptions below as needed
*/

var hackOptions$1 = {
	minRows: 2,
	maxRows: 4,
};

kitsy.longDialogOptions = hackOptions$1;

// override textbox height
inject(
	/textboxInfo\.height = .+;/,
	`Object.defineProperty(textboxInfo, 'height', {
	get() { return textboxInfo.padding_vert + (textboxInfo.padding_vert + relativeFontHeight()) * Math.max(window.kitsy.longDialogOptions.minRows, dialogBuffer.CurPage().indexOf(dialogBuffer.CurRow())+Math.sign(dialogBuffer.CurCharCount())) + textboxInfo.arrow_height; }
})`
);
// export textbox info
inject(/(var font = null;)/, 'this.textboxInfo = textboxInfo;$1');
before('renderDrawingBuffer', function (bufferId, buffer) {
	if (bufferId !== bitsy.textboxBufferId) return;
	buffer.height = bitsy.dialogRenderer.textboxInfo.height / bitsy.dialogRenderer.textboxInfo.font_scale;
});
// rewrite hard-coded row limit
inject(/(else if \(curRowIndex )== 0/g, '$1 < window.kitsy.longDialogOptions.maxRows - 1');
inject(/(if \(lastPage\.length) <= 1/, '$1 < window.kitsy.longDialogOptions.maxRows');

addDualDialogTag('textboxsize', function (environment, parameters) {
	if (!parameters[0]) {
		throw new Error('{textboxsize} was missing parameters! Usage: {textboxsize "minrows, maxrows"}');
	}
	// parse parameters
	var params = parameters[0].split(/,\s?/);
	var min = parseInt(params[0], 10);
	var max = parseInt(params[1], 10);
	hackOptions$1.minRows = min;
	hackOptions$1.maxRows = max;
});




hackOptions$1.minRows = hackOptions.minRows;
hackOptions$1.maxRows = hackOptions.maxRows;

var dialogChoices = {
	choice: 0,
	choices: [],
	choicesActive: false,
	moved: true,
	handleInput: function (dialogBuffer) {
		if (!this.choicesActive) {
			return false;
		}
		var pmoved = this.moved;
		this.moved = bitsy.input.anyKeyDown() || bitsy.input.swipeUp() || bitsy.input.swipeDown() || bitsy.input.swipeRight();
		var l = Math.max(this.choices.length, 1);
		// navigate
		if (!pmoved && ((bitsy.input.anyKeyDown() && (bitsy.input.isKeyDown(bitsy.key.up) || bitsy.input.isKeyDown(bitsy.key.w))) || bitsy.input.swipeUp())) {
			this.choice -= 1;
			if (this.choice < 0) {
				this.choice += l;
			}
			return false;
		}
		if (!pmoved && ((bitsy.input.anyKeyDown() && (bitsy.input.isKeyDown(bitsy.key.down) || bitsy.input.isKeyDown(bitsy.key.s))) || bitsy.input.swipeDown())) {
			this.choice = (this.choice + 1) % l;
			return false;
		}
		// select
		if (
			!pmoved &&
			((bitsy.input.anyKeyDown() &&
				(bitsy.input.isKeyDown(bitsy.key.right) || bitsy.input.isKeyDown(bitsy.key.d) || bitsy.input.isKeyDown(bitsy.key.enter) || bitsy.input.isKeyDown(bitsy.key.space))) ||
				bitsy.input.swipeRight())
		) {
			// evaluate choice
			this.choices[this.choice]();
			// reset
			this.choice = 0;
			this.choices = [];
			this.choicesActive = false;
			// get back into the regular dialog flow
			if (dialogBuffer.Continue()) {
				dialogBuffer.Update(0);
				// make sure to close dialog if there's nothing to say
				// after the choice has been made
				if (!dialogBuffer.CurCharCount()) {
					dialogBuffer.EndDialog();
				}
			}
			return true;
		}
		return false;
	},
};

bitsy.dialogChoices = dialogChoices;

function getCursorSprite(cursor) {
	return cursor
		? `renderer.GetDrawingSource(sprite['${cursor}'].drw)[sprite['${cursor}'].animation.frameIndex]`
		: `[
		[0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0],
		[0, 1, 0, 0, 0, 0, 0, 0],
		[0, 1, 1, 0, 0, 0, 0, 0],
		[0, 1, 1, 1, 0, 0, 0, 0],
		[0, 1, 1, 0, 0, 0, 0, 0],
		[0, 1, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0]
	]`;
}

// parsing
// (adds a new sequence node type)
inject(/(\|\| str === "shuffle")/, '$1 || str === "choice"');
inject(
	/(state\.curNode\.AddChild\(new ShuffleNode\(options\)\);\n.*})/,
	`$1
else if(sequenceType === "choice") {
	state.curNode.AddChild(new ChoiceNode(options));
}`
);

inject(
	/(var ShuffleNode = )/,
	`
var ChoiceNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "choice";
	this.options = options;
	options.forEach(function(option){
		var br = option.children.find(function(child){ return child.name === 'br'; });
		if (!br) {
			option.onSelect = [];
			return;
		}
		var idx = option.children.indexOf(br);
		option.onSelect = option.children.slice(idx+1);
		option.children = option.children.slice(0, idx);
	});

	this.Eval = function(environment,onReturn) {
		var lastVal = null;
		var i = 0;
		var prevRows = window.kitsy.longDialogOptions.maxRows;
		window.kitsy.longDialogOptions.maxRows = Infinity;
		function evalChildren(children,done) {
			if(i < children.length) {
				children[i].Eval(environment, function(val) {
					if (i === children.length - 1) {
						environment.GetDialogBuffer().AddParagraphBreak();
					} else {
						environment.GetDialogBuffer().AddLinebreak();
					}
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
				setTimeout(() => {
					window.dialogChoices.choicesActive = true;
				});
			}
		}
		window.dialogChoices.choices = this.options.map(function(option){
			return function(){
				window.kitsy.longDialogOptions.maxRows = prevRows;
				option.onSelect.forEach(function(child){
					child.Eval(environment, function(){});
				});
			};
		});
		if (environment.GetDialogBuffer().CurCharCount() > 0) {
			environment.GetDialogBuffer().AddParagraphBreak();
		}
		evalChildren(this.options, function () {
			onReturn(lastVal);
		});
	}
}
$1`
);

// rendering
// (re-uses existing arrow image data,
// but draws rotated to point at text)
inject(
	/(this\.DrawNextArrow = )/,
	`
this.DrawChoiceArrow = function() {
	bitsyDrawBegin(1);
	var rows = ${hackOptions.cursor};
	var top = (${hackOptions.transform.y} + window.dialogChoices.choice * (textboxInfo.padding_vert + relativeFontHeight())) * text_scale;
	var left = ${hackOptions.transform.x}*text_scale;
	for (var y = 0; y < rows.length; y++) {
		var cols = rows[y];
		for (var x = 0; x < cols.length; x++) {
			if (cols[x]) {
				//scaling nonsense
				for (var sy = 0; sy < text_scale; sy++) {
					for (var sx = 0; sx < text_scale; sx++) {
						bitsyDrawPixel(textArrowIndex, left + (x * text_scale) + sx, top + (y * text_scale) + sy);
					}
				}
			}
		}
	}
	bitsyDrawEnd();
};
$1`
);
inject(
	/(this\.DrawTextbox\(\);)/,
	`
if (window.dialogChoices.choicesActive) {
	this.DrawChoiceArrow();
}
$1`
);

// interaction
// (overrides the dialog skip/page flip)
inject(
	/(if\(\s*dialogBuffer\.IsActive\(\)\s*\) {)/,
	`$1
if(window.dialogChoices.handleInput(dialogBuffer)) {
	return;
} else `
);
inject(
	/(this\.CanContinue = function\(\) {)/,
	`$1
if(window.dialogChoices.choicesActive){
	return false;
}
`
);

exports.hackOptions = hackOptions;

Object.defineProperty(exports, '__esModule', { value: true });

})(this.hacks.dialog_choices = this.hacks.dialog_choices || {}, window);

/**

@file dialog jump
@summary jump from one dialog entry to another
@license MIT
@author Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11


@description
This can be used to simplify complex dialog
by moving portions to self-contained dialog entries,
and then jumping to the appropriate id when necessary.

You can also provide raw dialog text instead of an id;
Functionally this isn't much different from writing raw dialog text,
but it has some uses for advanced cases (e.g. when combined with dialog choices)

Usage:
	(jump "dialogId")
	(jumpNow "dialogId")
	(jump "dialog to print")
	(jumpNow "dialog to print")

Note: be careful of infinite loops, e.g.
DLG_infinite_loop
"""
this will print forever(jump "DLG_infinite_loop")
"""

HOW TO USE:
Copy-paste into a script tag after the bitsy source
*/
(function (bitsy) {
'use strict';

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
 * Helper used to replace code in a script tag based on a search regex.
 * To inject code without erasing original string, using capturing groups; e.g.
 * ```js
 * inject(/(some string)/,'injected before $1 injected after');
 * ```
 * @param searcher Regex to search and replace
 * @param replacer Replacer string/fn
 */
function inject$1(searcher, replacer) {
    // find the relevant script tag
    var scriptTags = document.getElementsByTagName('script');
    var scriptTag;
    var code = '';
    for (var i = 0; i < scriptTags.length; ++i) {
        scriptTag = scriptTags[i];
        if (!scriptTag.textContent)
            continue;
        var matchesSearch = scriptTag.textContent.search(searcher) !== -1;
        var isCurrentScript = scriptTag === document.currentScript;
        if (matchesSearch && !isCurrentScript) {
            code = scriptTag.textContent;
            break;
        }
    }
    // error-handling
    if (!code || !scriptTag) {
        throw new Error('Couldn\'t find "' + searcher + '" in script tags');
    }
    // modify the content
    code = code.replace(searcher, replacer);
    // replace the old script tag with a new one using our modified code
    var newScriptTag = document.createElement('script');
    newScriptTag.textContent = code;
    scriptTag.insertAdjacentElement('afterend', newScriptTag);
    scriptTag.remove();
}
/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
    return array.filter(function (item, idx) {
        return array.indexOf(item) === idx;
    });
}
// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
/** test */
function kitsyInject(searcher, replacer) {
    if (!kitsy.queuedInjectScripts.some(function (script) {
        return searcher.toString() === script.searcher.toString() && replacer === script.replacer;
    })) {
        kitsy.queuedInjectScripts.push({
            searcher: searcher,
            replacer: replacer,
        });
    }
    else {
        console.warn('Ignored duplicate inject');
    }
}
// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before$1(targetFuncName, beforeFn) {
    kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
    kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}
// Ex: after('load_game', function run() { alert('Loaded!'); });
function after$1(targetFuncName, afterFn) {
    kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
    kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}
function applyInjects() {
    kitsy.queuedInjectScripts.forEach(function (injectScript) {
        inject$1(injectScript.searcher, injectScript.replacer);
    });
}
function applyHooks(root) {
    var allHooks = unique(Object.keys(kitsy.queuedBeforeScripts).concat(Object.keys(kitsy.queuedAfterScripts)));
    allHooks.forEach(applyHook.bind(this, root || window));
}
function applyHook(root, functionName) {
    var functionNameSegments = functionName.split('.');
    var obj = root;
    while (functionNameSegments.length > 1) {
        obj = obj[functionNameSegments.shift()];
    }
    var lastSegment = functionNameSegments[0];
    var superFn = obj[lastSegment];
    var superFnLength = superFn ? superFn.length : 0;
    var functions = [];
    // start with befores
    functions = functions.concat(kitsy.queuedBeforeScripts[functionName] || []);
    // then original
    if (superFn) {
        functions.push(superFn);
    }
    // then afters
    functions = functions.concat(kitsy.queuedAfterScripts[functionName] || []);
    // overwrite original with one which will call each in order
    obj[lastSegment] = function () {
        var returnVal;
        var args = [].slice.call(arguments);
        var i = 0;
        function runBefore() {
            // All outta functions? Finish
            if (i === functions.length) {
                return returnVal;
            }
            // Update args if provided.
            if (arguments.length > 0) {
                args = [].slice.call(arguments);
            }
            if (functions[i].length > superFnLength) {
                // Assume funcs that accept more args than the original are
                // async and accept a callback as an additional argument.
                return functions[i++].apply(this, args.concat(runBefore.bind(this)));
            }
            // run synchronously
            returnVal = functions[i++].apply(this, args);
            if (returnVal && returnVal.length) {
                args = returnVal;
            }
            return runBefore.apply(this, args);
        }
        return runBefore.apply(this, arguments);
    };
}
/**
@file kitsy-script-toolkit
@summary Monkey-patching toolkit to make it easier and cleaner to run code before and after functions or to inject new code into script tags
@license WTFPL (do WTF you want)
@author Original by mildmojo; modified by Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11

*/
var kitsy = (window.kitsy = window.kitsy || {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {},
    inject: kitsyInject,
    before: before$1,
    after: after$1,
    /**
     * Applies all queued `inject` calls.
     *
     * An object that instantiates an class modified via injection will still refer to the original class,
     * so make sure to reinitialize globals that refer to injected scripts before calling `applyHooks`.
     */
    applyInjects,
    /** Apples all queued `before`/`after` calls. */
    applyHooks,
});

var hooked = kitsy.hooked;
if (!hooked) {
	kitsy.hooked = true;
	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts
		kitsy.applyInjects();

		// recreate the script and dialog objects so that they'll be
		// referencing the code with injections instead of the original
		bitsy.scriptModule = new bitsy.Script();
		bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

		bitsy.dialogModule = new bitsy.Dialog();
		bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
		bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
		bitsy.renderer = new bitsy.TileRenderer(bitsy.tilesize);

		// Hook everything
		kitsy.applyHooks();

		// reset callbacks using hacked functions
		bitsy.bitsyOnUpdate(bitsy.update);
		bitsy.bitsyOnQuit(bitsy.stopGame);
		bitsy.bitsyOnLoad(bitsy.load_game);

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};
}

/** @see kitsy.inject */
var inject = kitsy.inject;
/** @see kitsy.before */
var before = kitsy.before;
/** @see kitsy.after */
var after = kitsy.after;

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".*?"|.+?))?)\\\\?\\)', 'g'), function (match, group) {
		if (match.substr(0, 1) === '\\') {
			return '(' + group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
		}
		return '{' + group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
	});
}

function addDialogFunction(tag, fn) {
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		console.warn('The dialog function "' + tag + '" already exists.');
		return;
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (gameData) {
		return [convertDialogTags(gameData, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

function injectDialogTag(tag, code) {
	inject(/(var functionMap = \{\};[^]*?)(this.HasFunction)/m, '$1\nfunctionMap["' + tag + '"] = ' + code + ';\n$2');
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	injectDialogTag(tag, 'kitsy.dialogFunctions["' + tag + '"]');
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
	var deferred = (bitsy.kitsy.deferredDialogFunctions[tag] = []);
	injectDialogTag(tag, 'function(e, p, o){ kitsy.deferredDialogFunctions["' + tag + '"].push({e:e,p:p}); o(null); }');
	// Hook into the dialog finish event and execute the actual function
	after('onExitDialog', function () {
		while (deferred.length) {
			var args = deferred.shift();
			bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
		}
	});
	// Hook into the game reset and make sure data gets cleared
	after('clearGameData', function () {
		deferred.length = 0;
	});
}

/**
 * Adds two custom dialog tags which execute the provided function,
 * one with the provided tagname executed after the dialog box,
 * and one suffixed with 'Now' executed immediately when the tag is reached.
 *
 * i.e. helper for the (exit)/(exitNow) pattern.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDualDialogTag(tag, fn) {
	addDialogTag(tag + 'Now', function (environment, parameters, onReturn) {
		fn(environment, parameters);
		onReturn(null);
	});
	addDeferredDialogTag(tag, fn);
}



// jump function
function jump(targetDialog) {
	if (!targetDialog) {
		console.warn('Tried to jump to dialog, but no target dialog provided');
		return;
	}
	var dialogStr = bitsy.dialog[targetDialog];
	var dialogId;
	if (!dialogStr) {
		dialogStr = targetDialog;
	} else {
		dialogId = targetDialog;
		dialogStr = dialogStr.src;
	}
	bitsy.startDialog(dialogStr, dialogId);
}

addDualDialogTag('jump', function (environment, parameters) {
	jump(parameters[0]);
});

})(window);

/**

@file direction in dialog
@summary provides a variable with player direction
@license MIT
@author Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11


@description
Provides a variable "playerDirection" that can be accessed in dialog
The value will be one of:
	- "up"
	- "down"
	- "left"
	- "right"
Depending on the last input from the player.

Note that the variable will describe the direction the player moved,
so if they're interacting with a sprite, the opposite will be the direction from which they came
i.e. if the player moves into a sprite from the left, the variable will be "right"

HOW TO USE:
Copy-paste into a script tag after the bitsy source
*/
(function (bitsy) {
'use strict';

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
 * Helper used to replace code in a script tag based on a search regex.
 * To inject code without erasing original string, using capturing groups; e.g.
 * ```js
 * inject(/(some string)/,'injected before $1 injected after');
 * ```
 * @param searcher Regex to search and replace
 * @param replacer Replacer string/fn
 */
function inject(searcher, replacer) {
    // find the relevant script tag
    var scriptTags = document.getElementsByTagName('script');
    var scriptTag;
    var code = '';
    for (var i = 0; i < scriptTags.length; ++i) {
        scriptTag = scriptTags[i];
        if (!scriptTag.textContent)
            continue;
        var matchesSearch = scriptTag.textContent.search(searcher) !== -1;
        var isCurrentScript = scriptTag === document.currentScript;
        if (matchesSearch && !isCurrentScript) {
            code = scriptTag.textContent;
            break;
        }
    }
    // error-handling
    if (!code || !scriptTag) {
        throw new Error('Couldn\'t find "' + searcher + '" in script tags');
    }
    // modify the content
    code = code.replace(searcher, replacer);
    // replace the old script tag with a new one using our modified code
    var newScriptTag = document.createElement('script');
    newScriptTag.textContent = code;
    scriptTag.insertAdjacentElement('afterend', newScriptTag);
    scriptTag.remove();
}
/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
    return array.filter(function (item, idx) {
        return array.indexOf(item) === idx;
    });
}
// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
/** test */
function kitsyInject(searcher, replacer) {
    if (!kitsy.queuedInjectScripts.some(function (script) {
        return searcher.toString() === script.searcher.toString() && replacer === script.replacer;
    })) {
        kitsy.queuedInjectScripts.push({
            searcher: searcher,
            replacer: replacer,
        });
    }
    else {
        console.warn('Ignored duplicate inject');
    }
}
// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before$1(targetFuncName, beforeFn) {
    kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
    kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}
// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
    kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
    kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}
function applyInjects() {
    kitsy.queuedInjectScripts.forEach(function (injectScript) {
        inject(injectScript.searcher, injectScript.replacer);
    });
}
function applyHooks(root) {
    var allHooks = unique(Object.keys(kitsy.queuedBeforeScripts).concat(Object.keys(kitsy.queuedAfterScripts)));
    allHooks.forEach(applyHook.bind(this, root || window));
}
function applyHook(root, functionName) {
    var functionNameSegments = functionName.split('.');
    var obj = root;
    while (functionNameSegments.length > 1) {
        obj = obj[functionNameSegments.shift()];
    }
    var lastSegment = functionNameSegments[0];
    var superFn = obj[lastSegment];
    var superFnLength = superFn ? superFn.length : 0;
    var functions = [];
    // start with befores
    functions = functions.concat(kitsy.queuedBeforeScripts[functionName] || []);
    // then original
    if (superFn) {
        functions.push(superFn);
    }
    // then afters
    functions = functions.concat(kitsy.queuedAfterScripts[functionName] || []);
    // overwrite original with one which will call each in order
    obj[lastSegment] = function () {
        var returnVal;
        var args = [].slice.call(arguments);
        var i = 0;
        function runBefore() {
            // All outta functions? Finish
            if (i === functions.length) {
                return returnVal;
            }
            // Update args if provided.
            if (arguments.length > 0) {
                args = [].slice.call(arguments);
            }
            if (functions[i].length > superFnLength) {
                // Assume funcs that accept more args than the original are
                // async and accept a callback as an additional argument.
                return functions[i++].apply(this, args.concat(runBefore.bind(this)));
            }
            // run synchronously
            returnVal = functions[i++].apply(this, args);
            if (returnVal && returnVal.length) {
                args = returnVal;
            }
            return runBefore.apply(this, args);
        }
        return runBefore.apply(this, arguments);
    };
}
/**
@file kitsy-script-toolkit
@summary Monkey-patching toolkit to make it easier and cleaner to run code before and after functions or to inject new code into script tags
@license WTFPL (do WTF you want)
@author Original by mildmojo; modified by Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11

*/
var kitsy = (window.kitsy = window.kitsy || {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {},
    inject: kitsyInject,
    before: before$1,
    after,
    /**
     * Applies all queued `inject` calls.
     *
     * An object that instantiates an class modified via injection will still refer to the original class,
     * so make sure to reinitialize globals that refer to injected scripts before calling `applyHooks`.
     */
    applyInjects,
    /** Apples all queued `before`/`after` calls. */
    applyHooks,
});

var hooked = kitsy.hooked;
if (!hooked) {
	kitsy.hooked = true;
	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts
		kitsy.applyInjects();

		// recreate the script and dialog objects so that they'll be
		// referencing the code with injections instead of the original
		bitsy.scriptModule = new bitsy.Script();
		bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

		bitsy.dialogModule = new bitsy.Dialog();
		bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
		bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
		bitsy.renderer = new bitsy.TileRenderer(bitsy.tilesize);

		// Hook everything
		kitsy.applyHooks();

		// reset callbacks using hacked functions
		bitsy.bitsyOnUpdate(bitsy.update);
		bitsy.bitsyOnQuit(bitsy.stopGame);
		bitsy.bitsyOnLoad(bitsy.load_game);

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};
}

/** @see kitsy.inject */
kitsy.inject;
/** @see kitsy.before */
var before = kitsy.before;
/** @see kitsy.after */
kitsy.after;



var keys = {};
keys[bitsy.Direction.Up] = 'up';
keys[bitsy.Direction.Down] = 'down';
keys[bitsy.Direction.Left] = 'left';
keys[bitsy.Direction.Right] = 'right';
keys[bitsy.Direction.None] = null;

before('startDialog', function () {
	var direction = keys[bitsy.curPlayerDirection];
	if (direction) {
		bitsy.scriptInterpreter.SetVariable('playerDirection', direction);
	}
});

})(window);

/**

@file directional avatar
@summary flips the player's sprite based on directional movement
@license MIT
@author Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11


@description
Flips the player's sprite based on directional movement.

HOW TO USE:
1. Copy-paste into a script tag after the bitsy source
2. Edit `horizontalFlipAllowed` and `verticalFlipAllowed` below as needed
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions =  {
	allowed: function () {
		return {
			// If `horizontalFlipAllowed` is true:
			// 	pressing left will make the player's sprite face backwards
			// 	pressing right will make the player's sprite face forwards
			horizontalFlipAllowed: true,
			// If `verticalFlipAllowed` is true:
			// 	pressing down will make the player's sprite upside-down
			// 	pressing up will make the player's sprite right-side up
			verticalFlipAllowed: false,
		};
	},
};

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
@file utils
@summary miscellaneous bitsy utilities
@author Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11

*/

/*
Helper used to replace code in a script tag based on a search regex
To inject code without erasing original string, using capturing groups; e.g.
	inject(/(some string)/,'injected before $1 injected after')
*/
function inject$1(searchRegex, replaceString) {
	// find the relevant script tag
	var scriptTags = document.getElementsByTagName('script');
	var scriptTag;
	var code;
	for (var i = 0; i < scriptTags.length; ++i) {
		scriptTag = scriptTags[i];
		var matchesSearch = scriptTag.textContent.search(searchRegex) !== -1;
		var isCurrentScript = scriptTag === document.currentScript;
		if (matchesSearch && !isCurrentScript) {
			code = scriptTag.textContent;
			break;
		}
	}

	// error-handling
	if (!code) {
		throw new Error('Couldn\'t find "' + searchRegex + '" in script tags');
	}

	// modify the content
	code = code.replace(searchRegex, replaceString);

	// replace the old script tag with a new one using our modified code
	var newScriptTag = document.createElement('script');
	newScriptTag.textContent = code;
	scriptTag.insertAdjacentElement('afterend', newScriptTag);
	scriptTag.remove();
}

/*
Helper for getting image by name or id

Args:
	name: id or name of image to return
	 map: map of images (e.g. `sprite`, `tile`, `item`)

Returns: the image in the given map with the given name/id
 */
function getImage(name, map) {
	var id = Object.prototype.hasOwnProperty.call(map, name)
		? name
		: Object.keys(map).find(function (e) {
				return map[e].name === name;
		  });
	return map[id];
}

/**
@file edit image at runtime
@summary API for updating image data at runtime.
@author Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11

@description
Adds API for updating sprite, tile, and item data at runtime.

Individual frames of image data in bitsy are 8x8 1-bit 2D arrays in yx order
e.g. the default player is:
[
	[0,0,0,1,1,0,0,0],
	[0,0,0,1,1,0,0,0],
	[0,0,0,1,1,0,0,0],
	[0,0,1,1,1,1,0,0],
	[0,1,1,1,1,1,1,0],
	[1,0,1,1,1,1,0,1],
	[0,0,1,0,0,1,0,0],
	[0,0,1,0,0,1,0,0]
]
*/

// force cache to clear if edit image fns are used
inject$1(
	/\/\/ TODO : reset render cache for this image/,
	`
Object.keys(drawingCache.render)
	.filter(function (i) { return i.split('_').slice(0, -1).join('_') === drawingId; })
	.forEach(function(i) { drawingCache.render[i] = undefined; })
`
);

/*
Args:
	   id: string id or name
	frame: animation frame (0 or 1)
	  map: map of images (e.g. `sprite`, `tile`, `item`)

Returns: a single frame of a image data
*/
function getImageData(id, frame, map) {
	return bitsy.renderer.GetDrawingSource(getImage(id, map).drw)[frame];
}

function getSpriteData(id, frame) {
	return getImageData(id, frame, bitsy.sprite);
}

/*
Updates a single frame of image data

Args:
	     id: string id or name
	  frame: animation frame (0 or 1)
	    map: map of images (e.g. `sprite`, `tile`, `item`)
	newData: new data to write to the image data
*/
function setImageData(id, frame, map, newData) {
	var drawing = getImage(id, map);
	var drw = drawing.drw;
	var img = bitsy.renderer.GetDrawingSource(drw).slice();
	img[frame] = newData;
	bitsy.renderer.SetDrawingSource(drw, img);
}

function setSpriteData(id, frame, newData) {
	setImageData(id, frame, bitsy.sprite, newData);
}

/**
 * Helper used to replace code in a script tag based on a search regex.
 * To inject code without erasing original string, using capturing groups; e.g.
 * ```js
 * inject(/(some string)/,'injected before $1 injected after');
 * ```
 * @param searcher Regex to search and replace
 * @param replacer Replacer string/fn
 */
function inject(searcher, replacer) {
    // find the relevant script tag
    var scriptTags = document.getElementsByTagName('script');
    var scriptTag;
    var code = '';
    for (var i = 0; i < scriptTags.length; ++i) {
        scriptTag = scriptTags[i];
        if (!scriptTag.textContent)
            continue;
        var matchesSearch = scriptTag.textContent.search(searcher) !== -1;
        var isCurrentScript = scriptTag === document.currentScript;
        if (matchesSearch && !isCurrentScript) {
            code = scriptTag.textContent;
            break;
        }
    }
    // error-handling
    if (!code || !scriptTag) {
        throw new Error('Couldn\'t find "' + searcher + '" in script tags');
    }
    // modify the content
    code = code.replace(searcher, replacer);
    // replace the old script tag with a new one using our modified code
    var newScriptTag = document.createElement('script');
    newScriptTag.textContent = code;
    scriptTag.insertAdjacentElement('afterend', newScriptTag);
    scriptTag.remove();
}
/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
    return array.filter(function (item, idx) {
        return array.indexOf(item) === idx;
    });
}
// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
/** test */
function kitsyInject(searcher, replacer) {
    if (!kitsy.queuedInjectScripts.some(function (script) {
        return searcher.toString() === script.searcher.toString() && replacer === script.replacer;
    })) {
        kitsy.queuedInjectScripts.push({
            searcher: searcher,
            replacer: replacer,
        });
    }
    else {
        console.warn('Ignored duplicate inject');
    }
}
// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
    kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
    kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}
// Ex: after('load_game', function run() { alert('Loaded!'); });
function after$1(targetFuncName, afterFn) {
    kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
    kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}
function applyInjects() {
    kitsy.queuedInjectScripts.forEach(function (injectScript) {
        inject(injectScript.searcher, injectScript.replacer);
    });
}
function applyHooks(root) {
    var allHooks = unique(Object.keys(kitsy.queuedBeforeScripts).concat(Object.keys(kitsy.queuedAfterScripts)));
    allHooks.forEach(applyHook.bind(this, root || window));
}
function applyHook(root, functionName) {
    var functionNameSegments = functionName.split('.');
    var obj = root;
    while (functionNameSegments.length > 1) {
        obj = obj[functionNameSegments.shift()];
    }
    var lastSegment = functionNameSegments[0];
    var superFn = obj[lastSegment];
    var superFnLength = superFn ? superFn.length : 0;
    var functions = [];
    // start with befores
    functions = functions.concat(kitsy.queuedBeforeScripts[functionName] || []);
    // then original
    if (superFn) {
        functions.push(superFn);
    }
    // then afters
    functions = functions.concat(kitsy.queuedAfterScripts[functionName] || []);
    // overwrite original with one which will call each in order
    obj[lastSegment] = function () {
        var returnVal;
        var args = [].slice.call(arguments);
        var i = 0;
        function runBefore() {
            // All outta functions? Finish
            if (i === functions.length) {
                return returnVal;
            }
            // Update args if provided.
            if (arguments.length > 0) {
                args = [].slice.call(arguments);
            }
            if (functions[i].length > superFnLength) {
                // Assume funcs that accept more args than the original are
                // async and accept a callback as an additional argument.
                return functions[i++].apply(this, args.concat(runBefore.bind(this)));
            }
            // run synchronously
            returnVal = functions[i++].apply(this, args);
            if (returnVal && returnVal.length) {
                args = returnVal;
            }
            return runBefore.apply(this, args);
        }
        return runBefore.apply(this, arguments);
    };
}
/**
@file kitsy-script-toolkit
@summary Monkey-patching toolkit to make it easier and cleaner to run code before and after functions or to inject new code into script tags
@license WTFPL (do WTF you want)
@author Original by mildmojo; modified by Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11

*/
var kitsy = (window.kitsy = window.kitsy || {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {},
    inject: kitsyInject,
    before,
    after: after$1,
    /**
     * Applies all queued `inject` calls.
     *
     * An object that instantiates an class modified via injection will still refer to the original class,
     * so make sure to reinitialize globals that refer to injected scripts before calling `applyHooks`.
     */
    applyInjects,
    /** Apples all queued `before`/`after` calls. */
    applyHooks,
});

var hooked = kitsy.hooked;
if (!hooked) {
	kitsy.hooked = true;
	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts
		kitsy.applyInjects();

		// recreate the script and dialog objects so that they'll be
		// referencing the code with injections instead of the original
		bitsy.scriptModule = new bitsy.Script();
		bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

		bitsy.dialogModule = new bitsy.Dialog();
		bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
		bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
		bitsy.renderer = new bitsy.TileRenderer(bitsy.tilesize);

		// Hook everything
		kitsy.applyHooks();

		// reset callbacks using hacked functions
		bitsy.bitsyOnUpdate(bitsy.update);
		bitsy.bitsyOnQuit(bitsy.stopGame);
		bitsy.bitsyOnLoad(bitsy.load_game);

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};
}

/** @see kitsy.inject */
kitsy.inject;
/** @see kitsy.before */
kitsy.before;
/** @see kitsy.after */
var after = kitsy.after;

/**
@file transform sprite data
@summary Helpers for flipping and rotating sprite data
*/

// copied from https://stackoverflow.com/a/46805290
function transpose(matrix) {
	const rows = matrix.length;
	const cols = matrix[0].length;
	const grid = [];
	for (let j = 0; j < cols; j++) {
		grid[j] = Array(rows);
	}
	for (let i = 0; i < rows; i++) {
		for (let j = 0; j < cols; j++) {
			grid[j][i] = matrix[i][j];
		}
	}
	return grid;
}

// helper function to flip sprite data
function transformSpriteData(spriteData, v, h, rot) {
	var x;
	var y;
	var x2;
	var y2;
	var col;
	var tmp;
	var s = spriteData.slice();
	if (v) {
		for (y = 0; y < s.length / 2; ++y) {
			y2 = s.length - y - 1;
			tmp = s[y];
			s[y] = s[y2];
			s[y2] = tmp;
		}
	}
	if (h) {
		for (y = 0; y < s.length; ++y) {
			col = s[y] = s[y].slice();
			for (x = 0; x < col.length / 2; ++x) {
				x2 = col.length - x - 1;
				tmp = col[x];
				col[x] = col[x2];
				col[x2] = tmp;
			}
		}
	}
	if (rot) {
		s = transpose(s);
	}
	return s;
}





var hflip = false;
var vflip = false;
var originalAnimation;

after('updateInput', function () {
	var i;
	// save the original frames
	if (!originalAnimation || originalAnimation.referenceFrame !== getSpriteData(bitsy.playerId, 0)) {
		originalAnimation = {
			frames: [],
		};
		for (i = 0; i < bitsy.player().animation.frameCount; ++i) {
			originalAnimation.frames.push(getSpriteData(bitsy.playerId, i));
		}
	}

	// determine which directions need flipping
	var allowed = hackOptions.allowed();
	switch (bitsy.curPlayerDirection) {
		case bitsy.Direction.Up:
			vflip = false;
			break;
		case bitsy.Direction.Down:
			vflip = allowed.verticalFlipAllowed;
			break;
		case bitsy.Direction.Left:
			hflip = allowed.horizontalFlipAllowed;
			break;
		case bitsy.Direction.Right:
			hflip = false;
			break;
	}

	// update sprite with flipped frames
	for (i = 0; i < originalAnimation.frames.length; ++i) {
		setSpriteData(bitsy.playerId, i, transformSpriteData(originalAnimation.frames[i], vflip, hflip));
	}
	originalAnimation.referenceFrame = getSpriteData(bitsy.playerId, 0);
});

exports.hackOptions = hackOptions;

Object.defineProperty(exports, '__esModule', { value: true });

})(this.hacks.directional_avatar = this.hacks.directional_avatar || {}, window);

/**

@file paragraph-break
@summary Adds paragraph breaks to the dialogue parser
@license WTFPL (do WTF you want)
@author Sean S. LeBlanc, David Mowatt
@version 19.2.7
@requires Bitsy 7.11


@description
Adds a (p) tag to the dialogue parser that forces the following text to
start on a fresh dialogue screen, eliminating the need to spend hours testing
line lengths or adding multiple line breaks that then have to be reviewed
when you make edits or change the font size.

Note: Bitsy has a built-in implementation of paragraph-break as of 7.0;
before using this, you may want to check if it fulfills your needs.

Usage: (p)

Example: I am a cat(p)and my dialogue contains multitudes

HOW TO USE:
  1. Copy-paste this script into a new script tag after the Bitsy source code.
     It should appear *before* any other mods that handle loading your game
     data so it executes *after* them (last-in first-out).

NOTE: This uses parentheses "()" instead of curly braces "{}" around function
      calls because the Bitsy editor's fancy dialog window strips unrecognized
      curly-brace functions from dialog text. To keep from losing data, write
      these function calls with parentheses like the examples above.

      For full editor integration, you'd *probably* also need to paste this
      code at the end of the editor's `bitsy.js` file. Untested.
*/
(function (bitsy) {
'use strict';

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
 * Helper used to replace code in a script tag based on a search regex.
 * To inject code without erasing original string, using capturing groups; e.g.
 * ```js
 * inject(/(some string)/,'injected before $1 injected after');
 * ```
 * @param searcher Regex to search and replace
 * @param replacer Replacer string/fn
 */
function inject$1(searcher, replacer) {
    // find the relevant script tag
    var scriptTags = document.getElementsByTagName('script');
    var scriptTag;
    var code = '';
    for (var i = 0; i < scriptTags.length; ++i) {
        scriptTag = scriptTags[i];
        if (!scriptTag.textContent)
            continue;
        var matchesSearch = scriptTag.textContent.search(searcher) !== -1;
        var isCurrentScript = scriptTag === document.currentScript;
        if (matchesSearch && !isCurrentScript) {
            code = scriptTag.textContent;
            break;
        }
    }
    // error-handling
    if (!code || !scriptTag) {
        throw new Error('Couldn\'t find "' + searcher + '" in script tags');
    }
    // modify the content
    code = code.replace(searcher, replacer);
    // replace the old script tag with a new one using our modified code
    var newScriptTag = document.createElement('script');
    newScriptTag.textContent = code;
    scriptTag.insertAdjacentElement('afterend', newScriptTag);
    scriptTag.remove();
}
/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
    return array.filter(function (item, idx) {
        return array.indexOf(item) === idx;
    });
}
// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
/** test */
function kitsyInject(searcher, replacer) {
    if (!kitsy.queuedInjectScripts.some(function (script) {
        return searcher.toString() === script.searcher.toString() && replacer === script.replacer;
    })) {
        kitsy.queuedInjectScripts.push({
            searcher: searcher,
            replacer: replacer,
        });
    }
    else {
        console.warn('Ignored duplicate inject');
    }
}
// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before$1(targetFuncName, beforeFn) {
    kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
    kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}
// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
    kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
    kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}
function applyInjects() {
    kitsy.queuedInjectScripts.forEach(function (injectScript) {
        inject$1(injectScript.searcher, injectScript.replacer);
    });
}
function applyHooks(root) {
    var allHooks = unique(Object.keys(kitsy.queuedBeforeScripts).concat(Object.keys(kitsy.queuedAfterScripts)));
    allHooks.forEach(applyHook.bind(this, root || window));
}
function applyHook(root, functionName) {
    var functionNameSegments = functionName.split('.');
    var obj = root;
    while (functionNameSegments.length > 1) {
        obj = obj[functionNameSegments.shift()];
    }
    var lastSegment = functionNameSegments[0];
    var superFn = obj[lastSegment];
    var superFnLength = superFn ? superFn.length : 0;
    var functions = [];
    // start with befores
    functions = functions.concat(kitsy.queuedBeforeScripts[functionName] || []);
    // then original
    if (superFn) {
        functions.push(superFn);
    }
    // then afters
    functions = functions.concat(kitsy.queuedAfterScripts[functionName] || []);
    // overwrite original with one which will call each in order
    obj[lastSegment] = function () {
        var returnVal;
        var args = [].slice.call(arguments);
        var i = 0;
        function runBefore() {
            // All outta functions? Finish
            if (i === functions.length) {
                return returnVal;
            }
            // Update args if provided.
            if (arguments.length > 0) {
                args = [].slice.call(arguments);
            }
            if (functions[i].length > superFnLength) {
                // Assume funcs that accept more args than the original are
                // async and accept a callback as an additional argument.
                return functions[i++].apply(this, args.concat(runBefore.bind(this)));
            }
            // run synchronously
            returnVal = functions[i++].apply(this, args);
            if (returnVal && returnVal.length) {
                args = returnVal;
            }
            return runBefore.apply(this, args);
        }
        return runBefore.apply(this, arguments);
    };
}
/**
@file kitsy-script-toolkit
@summary Monkey-patching toolkit to make it easier and cleaner to run code before and after functions or to inject new code into script tags
@license WTFPL (do WTF you want)
@author Original by mildmojo; modified by Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11

*/
var kitsy = (window.kitsy = window.kitsy || {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {},
    inject: kitsyInject,
    before: before$1,
    after,
    /**
     * Applies all queued `inject` calls.
     *
     * An object that instantiates an class modified via injection will still refer to the original class,
     * so make sure to reinitialize globals that refer to injected scripts before calling `applyHooks`.
     */
    applyInjects,
    /** Apples all queued `before`/`after` calls. */
    applyHooks,
});

var hooked = kitsy.hooked;
if (!hooked) {
	kitsy.hooked = true;
	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts
		kitsy.applyInjects();

		// recreate the script and dialog objects so that they'll be
		// referencing the code with injections instead of the original
		bitsy.scriptModule = new bitsy.Script();
		bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

		bitsy.dialogModule = new bitsy.Dialog();
		bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
		bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
		bitsy.renderer = new bitsy.TileRenderer(bitsy.tilesize);

		// Hook everything
		kitsy.applyHooks();

		// reset callbacks using hacked functions
		bitsy.bitsyOnUpdate(bitsy.update);
		bitsy.bitsyOnQuit(bitsy.stopGame);
		bitsy.bitsyOnLoad(bitsy.load_game);

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};
}

/** @see kitsy.inject */
var inject = kitsy.inject;
/** @see kitsy.before */
var before = kitsy.before;
/** @see kitsy.after */
kitsy.after;

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".*?"|.+?))?)\\\\?\\)', 'g'), function (match, group) {
		if (match.substr(0, 1) === '\\') {
			return '(' + group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
		}
		return '{' + group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
	});
}

function addDialogFunction(tag, fn) {
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		console.warn('The dialog function "' + tag + '" already exists.');
		return;
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (gameData) {
		return [convertDialogTags(gameData, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

function injectDialogTag(tag, code) {
	inject(/(var functionMap = \{\};[^]*?)(this.HasFunction)/m, '$1\nfunctionMap["' + tag + '"] = ' + code + ';\n$2');
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	injectDialogTag(tag, 'kitsy.dialogFunctions["' + tag + '"]');
}

/**
 * Helper for printing a paragraph break inside of a dialog function.
 * Adds the function `AddParagraphBreak` to `DialogBuffer`
 */

inject(/(this\.AddLinebreak = )/, 'this.AddParagraphBreak = function() { buffer.push( [[]] ); isActive = true; };\n$1');



// Adds the actual dialogue tag. No deferred version is required.
addDialogTag('p', function (environment, parameters, onReturn) {
	environment.GetDialogBuffer().AddParagraphBreak();
	onReturn(null);
});
// End of (p) paragraph break mod

})(window);

/**

@file transparent sprites
@summary makes all sprites have transparent backgrounds
@license MIT
@author Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11


@description
Makes all sprites have transparent backgrounds.
i.e. tiles can be seen underneath the player, sprites, and items.

HOW TO USE:
1. Copy-paste this script into a script tag after the bitsy source
2. Edit hackOptions below as needed
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions =  {
	isTransparent: function (drawing) {
		// return drawing.name == 'tea'; // specific transparent drawing
		// return ['tea', 'flower', 'hat'].indexOf(drawing.name) !== -1; // specific transparent drawing list
		// return drawing.name && drawing.name.indexOf('TRANSPARENT') !== -1; // transparent drawing flag in name
		return true; // all drawings are transparent
	},
};

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
 * Helper used to replace code in a script tag based on a search regex.
 * To inject code without erasing original string, using capturing groups; e.g.
 * ```js
 * inject(/(some string)/,'injected before $1 injected after');
 * ```
 * @param searcher Regex to search and replace
 * @param replacer Replacer string/fn
 */
function inject$1(searcher, replacer) {
    // find the relevant script tag
    var scriptTags = document.getElementsByTagName('script');
    var scriptTag;
    var code = '';
    for (var i = 0; i < scriptTags.length; ++i) {
        scriptTag = scriptTags[i];
        if (!scriptTag.textContent)
            continue;
        var matchesSearch = scriptTag.textContent.search(searcher) !== -1;
        var isCurrentScript = scriptTag === document.currentScript;
        if (matchesSearch && !isCurrentScript) {
            code = scriptTag.textContent;
            break;
        }
    }
    // error-handling
    if (!code || !scriptTag) {
        throw new Error('Couldn\'t find "' + searcher + '" in script tags');
    }
    // modify the content
    code = code.replace(searcher, replacer);
    // replace the old script tag with a new one using our modified code
    var newScriptTag = document.createElement('script');
    newScriptTag.textContent = code;
    scriptTag.insertAdjacentElement('afterend', newScriptTag);
    scriptTag.remove();
}
/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
    return array.filter(function (item, idx) {
        return array.indexOf(item) === idx;
    });
}
// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
/** test */
function kitsyInject(searcher, replacer) {
    if (!kitsy.queuedInjectScripts.some(function (script) {
        return searcher.toString() === script.searcher.toString() && replacer === script.replacer;
    })) {
        kitsy.queuedInjectScripts.push({
            searcher: searcher,
            replacer: replacer,
        });
    }
    else {
        console.warn('Ignored duplicate inject');
    }
}
// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before$1(targetFuncName, beforeFn) {
    kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
    kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}
// Ex: after('load_game', function run() { alert('Loaded!'); });
function after$1(targetFuncName, afterFn) {
    kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
    kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}
function applyInjects() {
    kitsy.queuedInjectScripts.forEach(function (injectScript) {
        inject$1(injectScript.searcher, injectScript.replacer);
    });
}
function applyHooks(root) {
    var allHooks = unique(Object.keys(kitsy.queuedBeforeScripts).concat(Object.keys(kitsy.queuedAfterScripts)));
    allHooks.forEach(applyHook.bind(this, root || window));
}
function applyHook(root, functionName) {
    var functionNameSegments = functionName.split('.');
    var obj = root;
    while (functionNameSegments.length > 1) {
        obj = obj[functionNameSegments.shift()];
    }
    var lastSegment = functionNameSegments[0];
    var superFn = obj[lastSegment];
    var superFnLength = superFn ? superFn.length : 0;
    var functions = [];
    // start with befores
    functions = functions.concat(kitsy.queuedBeforeScripts[functionName] || []);
    // then original
    if (superFn) {
        functions.push(superFn);
    }
    // then afters
    functions = functions.concat(kitsy.queuedAfterScripts[functionName] || []);
    // overwrite original with one which will call each in order
    obj[lastSegment] = function () {
        var returnVal;
        var args = [].slice.call(arguments);
        var i = 0;
        function runBefore() {
            // All outta functions? Finish
            if (i === functions.length) {
                return returnVal;
            }
            // Update args if provided.
            if (arguments.length > 0) {
                args = [].slice.call(arguments);
            }
            if (functions[i].length > superFnLength) {
                // Assume funcs that accept more args than the original are
                // async and accept a callback as an additional argument.
                return functions[i++].apply(this, args.concat(runBefore.bind(this)));
            }
            // run synchronously
            returnVal = functions[i++].apply(this, args);
            if (returnVal && returnVal.length) {
                args = returnVal;
            }
            return runBefore.apply(this, args);
        }
        return runBefore.apply(this, arguments);
    };
}
/**
@file kitsy-script-toolkit
@summary Monkey-patching toolkit to make it easier and cleaner to run code before and after functions or to inject new code into script tags
@license WTFPL (do WTF you want)
@author Original by mildmojo; modified by Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11

*/
var kitsy = (window.kitsy = window.kitsy || {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {},
    inject: kitsyInject,
    before: before$1,
    after: after$1,
    /**
     * Applies all queued `inject` calls.
     *
     * An object that instantiates an class modified via injection will still refer to the original class,
     * so make sure to reinitialize globals that refer to injected scripts before calling `applyHooks`.
     */
    applyInjects,
    /** Apples all queued `before`/`after` calls. */
    applyHooks,
});

var hooked = kitsy.hooked;
if (!hooked) {
	kitsy.hooked = true;
	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts
		kitsy.applyInjects();

		// recreate the script and dialog objects so that they'll be
		// referencing the code with injections instead of the original
		bitsy.scriptModule = new bitsy.Script();
		bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

		bitsy.dialogModule = new bitsy.Dialog();
		bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
		bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
		bitsy.renderer = new bitsy.TileRenderer(bitsy.tilesize);

		// Hook everything
		kitsy.applyHooks();

		// reset callbacks using hacked functions
		bitsy.bitsyOnUpdate(bitsy.update);
		bitsy.bitsyOnQuit(bitsy.stopGame);
		bitsy.bitsyOnLoad(bitsy.load_game);

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};
}

/** @see kitsy.inject */
var inject = kitsy.inject;
/** @see kitsy.before */
var before = kitsy.before;
/** @see kitsy.after */
var after = kitsy.after;


//----------------------------------------------------
//-----------------Transparent Sprites----------------
//----------------------------------------------------

window.makeTransparent = false;
// flag what should be transparent
before('renderer.GetDrawingFrame', function (drawing, frameIndex) {
	window.makeTransparent = hackOptions.isTransparent(drawing);
});
// send -1 instead of background colour index if transparent
inject(/bitsyDrawPixel\(backgroundColor, x, y\)/, 'bitsyDrawPixel(window.makeTransparent ? -1 : backgroundColor, x, y)');
// overwrite transparent pixel
after('renderPixelInstruction', function (bufferId, buffer, paletteIndex, x, y) {
	if (paletteIndex !== -1) return;

	if (buffer.imageData) {
		for (var sy = 0; sy < buffer.scale; sy++) {
			for (var sx = 0; sx < buffer.scale; sx++) {
				var pixelIndex = (y * buffer.scale + sy) * buffer.width * buffer.scale * 4 + (x * buffer.scale + sx) * 4;
				buffer.imageData.data[pixelIndex + 3] = 0;
			}
		}
	} else {
		var bufferContext = buffer.canvas.getContext('2d');
		bufferContext.clearRect(x * buffer.scale, y * buffer.scale, buffer.scale, buffer.scale);
	}
});

exports.hackOptions = hackOptions;

Object.defineProperty(exports, '__esModule', { value: true });

})(this.hacks.transparent_sprites = this.hacks.transparent_sprites || {}, window);


</script>

<script type="text/javascript" id="borksyAdditionalJS">

</script>

<script>
	
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//-----------------SETH, put all of your new hacks in this script and label them, you dingus----------------
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//CCCCCCCCCCCCCCCCCCCCCCCCCCCCustom Text Effectsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss
/**

@file custom text effect
@summary make {custom}text effects{custom}
@license MIT
@author Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11


@description
Adds support for a custom text effect
e.g. "normal text {my-effect}custom wavy text{my-effect}"

Multiple text effects can be added this way.
Without the hack, the game will still run normally since
bitsy just ignores text tags that aren't supported.

Because the dialog system uses private variables,
this one does some silly things with code injection.

HOW TO USE:
1. Copy-paste this script into a script tag after the bitsy source
2. Update the `hackOptions` object at the top of the script with your custom effects

TEXT EFFECT NOTES:
Each effect looks like:
	key: function() {
		this.DoEffect = function (char, time) {
			// effect code
		}
	}

The key is the text you'll write inside {} in bitsy to trigger the effect

`this.DoEffect` is called every frame for the characters the effect is applied to

The first argument is `char`, an individual character, which has the following properties:
	offset: offset from actual position in pixels. starts at {x:0, y:0}
	color: palette index of rendered text. use `tileColorStartIndex`/`rainbowColorStartIndex`
	       to modify this, e.g. `tileColorStartIndex + 2` is the sprite colour
	bitmap: character bitmap as array of pixels
	row: vertical position in rows (doesn't affect rendering)
	col: horizontal position in characters (doesn't affect rendering)
`row`, `col`, and `offset` are reset every frame
`color` and any custom properties are reset when the dialog page is changed
`bitmap` is not reset! This edits the character in the font data directly

A few helpers are provided under `window.customTextEffects` for more complex effects:
	- `saveOriginalChar`: saves the character string on `char`
	- `setBitmap`: sets bitmap based on a new character
	- `editBitmapCopy`: copies the character bitmap and runs an edit function once

The second argument is `time`, which is the time in milliseconds

A number of example effects are included
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions = {
	'my-effect': function () {
		// a horizontal wavy effect using the blue rbw colour
		this.DoEffect = function (char, time) {
			char.offset.x += 5 * Math.sin(time / 100 + char.col / 3);
			char.color = bitsy.rainbowColorStartIndex + 4;
		};
	},
	droop: function () {
		// causes text to droop down slowly over time
		// note that it's adding a custom property to the character if it doesn't already exist
		this.DoEffect = function (char, time) {
			char.start = char.start || time;
			char.offset.y += ((time - char.start) / 100) * Math.abs(Math.sin(char.col));
		};
	},
	noise: function () {
		// renders noise on top of text
		// note that it's making a copy with `.slice()` since it's a dynamic bitmap change
		this.DoEffect = function (char) {
			char.bitmap = char.bitmap.slice();
			for (var i = 0; i < char.bitmap.length; ++i) {
				char.bitmap[i] = Math.random() < 0.25 ? 1 : 0;
			}
		};
	},
	strike: function () {
		// renders text with a strike-through
		// note that it's using `editBitmapCopy` since it's a static bitmap change
		this.DoEffect = function (char) {
			var font = window.fontManager.Get(window.fontName);
			var w = font.getWidth();
			var h = font.getHeight();
			window.customTextEffects.editBitmapCopy(char, function (bitmap) {
				for (var x = 0; x < w; ++x) {
					bitmap[x + Math.floor(h / 2) * w] = 1;
				}
			});
		};
	},
	scramble: function () {
		// animated text scrambling
		// note that it's saving the original character with `saveOriginalChar` so `char.original` can be used
		// it's also using `setBitmap` to render a different character in the font
		this.DoEffect = function (char, time) {
			window.customTextEffects.saveOriginalChar(char);
			if (char.original.match(/\s|\0/)) {
				return;
			}
			var c = String.fromCharCode(char.original.codePointAt(0) + ((char.col + time / 40) % 10));
			window.customTextEffects.setBitmap(char, c);
		};
	},
	rot13: function () {
		// puts letters through the rot13 cipher (see www.rot13.com)
		this.DoEffect = function (char) {
			window.customTextEffects.saveOriginalChar(char);
			var bitmap = char.original
				.replace(/[a-z]/, function (c) {
					return String.fromCharCode(((c.codePointAt(0) - 97 + 13) % 26) + 97);
				})
				.replace(/[A-Z]/, function (c) {
					return String.fromCharCode(((c.codePointAt(0) - 65 + 13) % 26) + 65);
				});
			window.customTextEffects.setBitmap(char, bitmap);
		};
	},
	sponge: function () {
		// animated alternating letter case
		// note that it's using a locally defined function
		function posmod(a, b) {
			return ((a % b) + b) % b;
		}
		this.DoEffect = function (char, time) {
			window.customTextEffects.saveOriginalChar(char);
			var c = char.original[['toUpperCase', 'toLowerCase'][Math.round(posmod(time / 1000 - (char.col + char.row) / 2, 1))]]();
			window.customTextEffects.setBitmap(char, c);
		};
	},
	flag: function () {
		// applies a wave effect that's more intense towards the ends of words
		// note that it's using function scope variables to track state across
		// multiple letters in order to figure out where words begin
		var lastSpace = 0;
		var lastCol = -Infinity;
		this.DoEffect = function (char, time) {
			window.customTextEffects.saveOriginalChar(char);
			if (char.original.match(/\s|\0/)) {
				return;
			}
			if (Math.abs(char.col - lastCol) > 1) {
				lastSpace = char.col - 1;
			}
			lastCol = char.col;
			char.offset.y -= (char.col - lastSpace) ** 1.5 * Math.sin(time / 120 + char.col / 2);
		};
	},
	// some common formatting effects for general use
	i: function () {
		// renders text with an italic slant
		// note that with higher steps, some characters will be cut off on the edges
		var steps = 2;
		this.DoEffect = function (char) {
			var font = window.fontManager.Get(window.fontName);
			var w = font.getWidth();
			var h = font.getHeight();
			window.customTextEffects.editBitmapCopy(char, function (bitmap) {
				for (var y = 0; y < h; ++y) {
					var o = Math.floor((y / h) * steps - steps / 2) + 1;
					for (var x = 0; x < w; ++x) {
						bitmap[x + y * w] = x + o < 0 || x + 0 >= w ? 0 : char.originalBitmap[x + o + y * w];
					}
				}
			});
		};
	},
	b: function () {
		// renders text with extra thickness
		// note that with higher weight, some characters will be cut off on the edges
		var weight = 2;
		this.DoEffect = function (char) {
			var font = window.fontManager.Get(window.fontName);
			var w = font.getWidth();
			var h = font.getHeight();
			window.customTextEffects.editBitmapCopy(char, function (bitmap) {
				for (var y = 0; y < h; ++y) {
					for (var x = 0; x < w; ++x) {
						for (var x2 = 0; x2 < weight; ++x2) {
							var x3 = x + x2 - Math.floor(weight / 2);
							if (x3 < 0 || x3 >= w) {
								continue;
							}
							bitmap[x3 + y * w] = bitmap[x3 + y * w] || char.originalBitmap[x + y * w];
						}
					}
				}
			});
		};
	},
	u: function () {
		// renders text with an underline
		this.DoEffect = function (char) {
			var font = window.fontManager.Get(window.fontName);
			var w = font.getWidth();
			var h = font.getHeight();
			window.customTextEffects.editBitmapCopy(char, function (bitmap) {
				for (var x = 0; x < w; ++x) {
					bitmap[x + (h - 1) * w] = 1;
				}
			});
		};
	},
};

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
 * Helper used to replace code in a script tag based on a search regex.
 * To inject code without erasing original string, using capturing groups; e.g.
 * ```js
 * inject(/(some string)/,'injected before $1 injected after');
 * ```
 * @param searcher Regex to search and replace
 * @param replacer Replacer string/fn
 */
function inject$1(searcher, replacer) {
    // find the relevant script tag
    var scriptTags = document.getElementsByTagName('script');
    var scriptTag;
    var code = '';
    for (var i = 0; i < scriptTags.length; ++i) {
        scriptTag = scriptTags[i];
        if (!scriptTag.textContent)
            continue;
        var matchesSearch = scriptTag.textContent.search(searcher) !== -1;
        var isCurrentScript = scriptTag === document.currentScript;
        if (matchesSearch && !isCurrentScript) {
            code = scriptTag.textContent;
            break;
        }
    }
    // error-handling
    if (!code || !scriptTag) {
        throw new Error('Couldn\'t find "' + searcher + '" in script tags');
    }
    // modify the content
    code = code.replace(searcher, replacer);
    // replace the old script tag with a new one using our modified code
    var newScriptTag = document.createElement('script');
    newScriptTag.textContent = code;
    scriptTag.insertAdjacentElement('afterend', newScriptTag);
    scriptTag.remove();
}
/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
    return array.filter(function (item, idx) {
        return array.indexOf(item) === idx;
    });
}
// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
/** test */
function kitsyInject(searcher, replacer) {
    if (!kitsy.queuedInjectScripts.some(function (script) {
        return searcher.toString() === script.searcher.toString() && replacer === script.replacer;
    })) {
        kitsy.queuedInjectScripts.push({
            searcher: searcher,
            replacer: replacer,
        });
    }
    else {
        console.warn('Ignored duplicate inject');
    }
}
// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before(targetFuncName, beforeFn) {
    kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
    kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}
// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
    kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
    kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}
function applyInjects() {
    kitsy.queuedInjectScripts.forEach(function (injectScript) {
        inject$1(injectScript.searcher, injectScript.replacer);
    });
}
function applyHooks(root) {
    var allHooks = unique(Object.keys(kitsy.queuedBeforeScripts).concat(Object.keys(kitsy.queuedAfterScripts)));
    allHooks.forEach(applyHook.bind(this, root || window));
}
function applyHook(root, functionName) {
    var functionNameSegments = functionName.split('.');
    var obj = root;
    while (functionNameSegments.length > 1) {
        obj = obj[functionNameSegments.shift()];
    }
    var lastSegment = functionNameSegments[0];
    var superFn = obj[lastSegment];
    var superFnLength = superFn ? superFn.length : 0;
    var functions = [];
    // start with befores
    functions = functions.concat(kitsy.queuedBeforeScripts[functionName] || []);
    // then original
    if (superFn) {
        functions.push(superFn);
    }
    // then afters
    functions = functions.concat(kitsy.queuedAfterScripts[functionName] || []);
    // overwrite original with one which will call each in order
    obj[lastSegment] = function () {
        var returnVal;
        var args = [].slice.call(arguments);
        var i = 0;
        function runBefore() {
            // All outta functions? Finish
            if (i === functions.length) {
                return returnVal;
            }
            // Update args if provided.
            if (arguments.length > 0) {
                args = [].slice.call(arguments);
            }
            if (functions[i].length > superFnLength) {
                // Assume funcs that accept more args than the original are
                // async and accept a callback as an additional argument.
                return functions[i++].apply(this, args.concat(runBefore.bind(this)));
            }
            // run synchronously
            returnVal = functions[i++].apply(this, args);
            if (returnVal && returnVal.length) {
                args = returnVal;
            }
            return runBefore.apply(this, args);
        }
        return runBefore.apply(this, arguments);
    };
}
/**
@file kitsy-script-toolkit
@summary Monkey-patching toolkit to make it easier and cleaner to run code before and after functions or to inject new code into script tags
@license WTFPL (do WTF you want)
@author Original by mildmojo; modified by Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11

*/
var kitsy = (window.kitsy = window.kitsy || {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {},
    inject: kitsyInject,
    before,
    after,
    /**
     * Applies all queued `inject` calls.
     *
     * An object that instantiates an class modified via injection will still refer to the original class,
     * so make sure to reinitialize globals that refer to injected scripts before calling `applyHooks`.
     */
    applyInjects,
    /** Apples all queued `before`/`after` calls. */
    applyHooks,
});

var hooked = kitsy.hooked;
if (!hooked) {
	kitsy.hooked = true;
	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts
		kitsy.applyInjects();

		// recreate the script and dialog objects so that they'll be
		// referencing the code with injections instead of the original
		bitsy.scriptModule = new bitsy.Script();
		bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

		bitsy.dialogModule = new bitsy.Dialog();
		bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
		bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
		bitsy.renderer = new bitsy.TileRenderer(bitsy.tilesize);

		// Hook everything
		kitsy.applyHooks();

		// reset callbacks using hacked functions
		bitsy.bitsyOnUpdate(bitsy.update);
		bitsy.bitsyOnQuit(bitsy.stopGame);
		bitsy.bitsyOnLoad(bitsy.load_game);

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};
}

/** @see kitsy.inject */
var inject = kitsy.inject;
/** @see kitsy.before */
kitsy.before;
/** @see kitsy.after */
kitsy.after;





// custom text effects are injected,
// so need to store helpers somewhere accessible
// from outside of hack scope
window.customTextEffects = {
	// helper for caching original character string on character object
	saveOriginalChar: function (char) {
		if (char.original !== undefined) {
			return;
		}
		var font = window.fontManager.Get(window.fontName);
		var characters = Object.entries(font.getData());
		var character = characters.find(function (keyval) {
			return keyval[1].toString() === char.bitmap.toString();
		});
		char.original = String.fromCharCode(character[0]);
	},
	// helper for setting new character bitmap by string on character object
	setBitmap: function (char, c) {
		char.bitmap = window.fontManager.Get(window.fontName).getChar(c);
	},
	// helper for editing bitmap without affecting other characters
	editBitmapCopy: function (char, editFn) {
		if (char.originalBitmap !== undefined) {
			return;
		}
		char.originalBitmap = char.bitmap;
		char.bitmap = char.bitmap.slice();
		editFn(char.bitmap);
	},
};

// generate code for each text effect
var functionMapCode = '';
var textEffectCode = '';
Object.entries(hackOptions).forEach(function (entry) {
	functionMapCode += 'functionMap["' + entry[0] + '"] = function (environment, parameters, onReturn) {addOrRemoveTextEffect(environment, "' + entry[0] + '");onReturn(null);};';
	textEffectCode += 'TextEffects["' + entry[0] + '"] = new (' + entry[1].toString() + ')();';
});

// inject custom text effect code
inject(/(var functionMap = \{\};)/, '$1' + functionMapCode);
inject(/(var TextEffects = \{\};)/, '$1' + textEffectCode);

exports.hackOptions = hackOptions;

Object.defineProperty(exports, '__esModule', { value: true });

})(this.hacks.custom_text_effect = this.hacks.custom_text_effect || {}, window);

//EEEEEEEEEEEEEEEEEEEEEEEEEEEnd of Custom Text Effectsssssssssssssssssssssssssssssssssssssssssssssssssssssss


//FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFForce Paragraph Breakssssssssssssssssssssssssssssssssssssssssssss

*/
(function (bitsy) {
'use strict';

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
 * Helper used to replace code in a script tag based on a search regex.
 * To inject code without erasing original string, using capturing groups; e.g.
 * ```js
 * inject(/(some string)/,'injected before $1 injected after');
 * ```
 * @param searcher Regex to search and replace
 * @param replacer Replacer string/fn
 */
function inject$1(searcher, replacer) {
    // find the relevant script tag
    var scriptTags = document.getElementsByTagName('script');
    var scriptTag;
    var code = '';
    for (var i = 0; i < scriptTags.length; ++i) {
        scriptTag = scriptTags[i];
        if (!scriptTag.textContent)
            continue;
        var matchesSearch = scriptTag.textContent.search(searcher) !== -1;
        var isCurrentScript = scriptTag === document.currentScript;
        if (matchesSearch && !isCurrentScript) {
            code = scriptTag.textContent;
            break;
        }
    }
    // error-handling
    if (!code || !scriptTag) {
        throw new Error('Couldn\'t find "' + searcher + '" in script tags');
    }
    // modify the content
    code = code.replace(searcher, replacer);
    // replace the old script tag with a new one using our modified code
    var newScriptTag = document.createElement('script');
    newScriptTag.textContent = code;
    scriptTag.insertAdjacentElement('afterend', newScriptTag);
    scriptTag.remove();
}
/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
    return array.filter(function (item, idx) {
        return array.indexOf(item) === idx;
    });
}
// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
/** test */
function kitsyInject(searcher, replacer) {
    if (!kitsy.queuedInjectScripts.some(function (script) {
        return searcher.toString() === script.searcher.toString() && replacer === script.replacer;
    })) {
        kitsy.queuedInjectScripts.push({
            searcher: searcher,
            replacer: replacer,
        });
    }
    else {
        console.warn('Ignored duplicate inject');
    }
}
// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before$1(targetFuncName, beforeFn) {
    kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
    kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}
// Ex: after('load_game', function run() { alert('Loaded!'); });
function after(targetFuncName, afterFn) {
    kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
    kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}
function applyInjects() {
    kitsy.queuedInjectScripts.forEach(function (injectScript) {
        inject$1(injectScript.searcher, injectScript.replacer);
    });
}
function applyHooks(root) {
    var allHooks = unique(Object.keys(kitsy.queuedBeforeScripts).concat(Object.keys(kitsy.queuedAfterScripts)));
    allHooks.forEach(applyHook.bind(this, root || window));
}
function applyHook(root, functionName) {
    var functionNameSegments = functionName.split('.');
    var obj = root;
    while (functionNameSegments.length > 1) {
        obj = obj[functionNameSegments.shift()];
    }
    var lastSegment = functionNameSegments[0];
    var superFn = obj[lastSegment];
    var superFnLength = superFn ? superFn.length : 0;
    var functions = [];
    // start with befores
    functions = functions.concat(kitsy.queuedBeforeScripts[functionName] || []);
    // then original
    if (superFn) {
        functions.push(superFn);
    }
    // then afters
    functions = functions.concat(kitsy.queuedAfterScripts[functionName] || []);
    // overwrite original with one which will call each in order
    obj[lastSegment] = function () {
        var returnVal;
        var args = [].slice.call(arguments);
        var i = 0;
        function runBefore() {
            // All outta functions? Finish
            if (i === functions.length) {
                return returnVal;
            }
            // Update args if provided.
            if (arguments.length > 0) {
                args = [].slice.call(arguments);
            }
            if (functions[i].length > superFnLength) {
                // Assume funcs that accept more args than the original are
                // async and accept a callback as an additional argument.
                return functions[i++].apply(this, args.concat(runBefore.bind(this)));
            }
            // run synchronously
            returnVal = functions[i++].apply(this, args);
            if (returnVal && returnVal.length) {
                args = returnVal;
            }
            return runBefore.apply(this, args);
        }
        return runBefore.apply(this, arguments);
    };
}
/**
@file kitsy-script-toolkit
@summary Monkey-patching toolkit to make it easier and cleaner to run code before and after functions or to inject new code into script tags
@license WTFPL (do WTF you want)
@author Original by mildmojo; modified by Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11

*/
var kitsy = (window.kitsy = window.kitsy || {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {},
    inject: kitsyInject,
    before: before$1,
    after,
    /**
     * Applies all queued `inject` calls.
     *
     * An object that instantiates an class modified via injection will still refer to the original class,
     * so make sure to reinitialize globals that refer to injected scripts before calling `applyHooks`.
     */
    applyInjects,
    /** Apples all queued `before`/`after` calls. */
    applyHooks,
});

var hooked = kitsy.hooked;
if (!hooked) {
	kitsy.hooked = true;
	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts
		kitsy.applyInjects();

		// recreate the script and dialog objects so that they'll be
		// referencing the code with injections instead of the original
		bitsy.scriptModule = new bitsy.Script();
		bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

		bitsy.dialogModule = new bitsy.Dialog();
		bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
		bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
		bitsy.renderer = new bitsy.TileRenderer(bitsy.tilesize);

		// Hook everything
		kitsy.applyHooks();

		// reset callbacks using hacked functions
		bitsy.bitsyOnUpdate(bitsy.update);
		bitsy.bitsyOnQuit(bitsy.stopGame);
		bitsy.bitsyOnLoad(bitsy.load_game);

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};
}

/** @see kitsy.inject */
var inject = kitsy.inject;
/** @see kitsy.before */
var before = kitsy.before;
/** @see kitsy.after */
kitsy.after;

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".*?"|.+?))?)\\\\?\\)', 'g'), function (match, group) {
		if (match.substr(0, 1) === '\\') {
			return '(' + group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
		}
		return '{' + group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
	});
}

function addDialogFunction(tag, fn) {
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		console.warn('The dialog function "' + tag + '" already exists.');
		return;
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (gameData) {
		return [convertDialogTags(gameData, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

function injectDialogTag(tag, code) {
	inject(/(var functionMap = \{\};[^]*?)(this.HasFunction)/m, '$1\nfunctionMap["' + tag + '"] = ' + code + ';\n$2');
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	injectDialogTag(tag, 'kitsy.dialogFunctions["' + tag + '"]');
}

/**
 * Helper for printing a paragraph break inside of a dialog function.
 * Adds the function `AddParagraphBreak` to `DialogBuffer`
 */

inject(/(this\.AddLinebreak = )/, 'this.AddParagraphBreak = function() { buffer.push( [[]] ); isActive = true; };\n$1');



// Adds the actual dialogue tag. No deferred version is required.
addDialogTag('p', function (environment, parameters, onReturn) {
	environment.GetDialogBuffer().AddParagraphBreak();
	onReturn(null);
});
// End of (p) paragraph break mod

//EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEnd of Force Paragraph Breakssssssssssssssssssssssssssssssssssssssssssss

//DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDialog Choicesssssssssssssssssssssssssssssssssssssssssssssssssssssssss

/**

@file dialog choices
@summary dialog choices
@license MIT
@author Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11


@description
Adds a dialog tag which allows you to present the player with dialog choices.
Uses as an arrow cursor by default, but this can be changed in the hackOptions to use a custom bitsy sprite instead.

Usage:
{choice
  - option one
    result of picking option
  - option two
    result of picking option
}

Recommended uses:
DLG_simple_response
"""
Greeting text{choice
  - Response one
    answer to response one
  - Response two
    answer to response two
}
"""

DLG_complex_response
"""
Greeting text{choice
  - Response one
    {a = 1}
  - Response two
    {a = 2}
}
constant part of answer{
  - a == 1 ?
    custom part based on response one
  - a == 2 ?
    custom part based on response two
}
"""

This hack includes the "long dialog" hack so that the textbox
automatically expands to allow for more than 2 choices.

Note: it's recommended you combine this hack
with the dialog jump hack for complex cases.

Limitations:
Each option must fit on a single line, or the cursor
may not line up with the selected option.

Checking the value of a variable set in an option
*immediately after the choice* will not work,
as it will evaluate before the player has selected
an option if there is no text in-between the two.
e.g.
"""
{a = 1}
{choice
  - Response one
    {a = 2}
  - Response two
    {a = 3}
}
{
  - a == 1 ?
    this will print
  - a == 2 ?
    these will not
  - a == 3 ?
    these will not
}
"""

HOW TO USE:
1. Copy-paste into a script tag after the bitsy source
2. Edit hackOptions below as needed
*/
this.hacks = this.hacks || {};
(function (exports, bitsy) {
'use strict';
var hackOptions = {
	// if defined, the cursor is drawn as the sprite with the given id
	// e.g. replace with `getCursorSprite('A')` to use the player's avatar as a cursor
	// if not defined, uses an arrow graphic similar to the continue arrow
	cursor: getCursorSprite(),
	// modifies the position of the cursor
	transform: {
		y: 1,
		x: 0,
	},
	// long dialog options
	minRows: 2,
	maxRows: 2,
};

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

bitsy = bitsy || /*#__PURE__*/_interopDefaultLegacy(bitsy);

/**
 * Helper used to replace code in a script tag based on a search regex.
 * To inject code without erasing original string, using capturing groups; e.g.
 * ```js
 * inject(/(some string)/,'injected before $1 injected after');
 * ```
 * @param searcher Regex to search and replace
 * @param replacer Replacer string/fn
 */
function inject$1(searcher, replacer) {
    // find the relevant script tag
    var scriptTags = document.getElementsByTagName('script');
    var scriptTag;
    var code = '';
    for (var i = 0; i < scriptTags.length; ++i) {
        scriptTag = scriptTags[i];
        if (!scriptTag.textContent)
            continue;
        var matchesSearch = scriptTag.textContent.search(searcher) !== -1;
        var isCurrentScript = scriptTag === document.currentScript;
        if (matchesSearch && !isCurrentScript) {
            code = scriptTag.textContent;
            break;
        }
    }
    // error-handling
    if (!code || !scriptTag) {
        throw new Error('Couldn\'t find "' + searcher + '" in script tags');
    }
    // modify the content
    code = code.replace(searcher, replacer);
    // replace the old script tag with a new one using our modified code
    var newScriptTag = document.createElement('script');
    newScriptTag.textContent = code;
    scriptTag.insertAdjacentElement('afterend', newScriptTag);
    scriptTag.remove();
}
/**
 * Helper for getting an array with unique elements
 * @param  {Array} array Original array
 * @return {Array}       Copy of array, excluding duplicates
 */
function unique(array) {
    return array.filter(function (item, idx) {
        return array.indexOf(item) === idx;
    });
}
// Ex: inject(/(names.sprite.set\( name, id \);)/, '$1console.dir(names)');
/** test */
function kitsyInject(searcher, replacer) {
    if (!kitsy.queuedInjectScripts.some(function (script) {
        return searcher.toString() === script.searcher.toString() && replacer === script.replacer;
    })) {
        kitsy.queuedInjectScripts.push({
            searcher: searcher,
            replacer: replacer,
        });
    }
    else {
        console.warn('Ignored duplicate inject');
    }
}
// Ex: before('load_game', function run() { alert('Loading!'); });
//     before('show_text', function run(text) { return text.toUpperCase(); });
//     before('show_text', function run(text, done) { done(text.toUpperCase()); });
function before$1(targetFuncName, beforeFn) {
    kitsy.queuedBeforeScripts[targetFuncName] = kitsy.queuedBeforeScripts[targetFuncName] || [];
    kitsy.queuedBeforeScripts[targetFuncName].push(beforeFn);
}
// Ex: after('load_game', function run() { alert('Loaded!'); });
function after$1(targetFuncName, afterFn) {
    kitsy.queuedAfterScripts[targetFuncName] = kitsy.queuedAfterScripts[targetFuncName] || [];
    kitsy.queuedAfterScripts[targetFuncName].push(afterFn);
}
function applyInjects() {
    kitsy.queuedInjectScripts.forEach(function (injectScript) {
        inject$1(injectScript.searcher, injectScript.replacer);
    });
}
function applyHooks(root) {
    var allHooks = unique(Object.keys(kitsy.queuedBeforeScripts).concat(Object.keys(kitsy.queuedAfterScripts)));
    allHooks.forEach(applyHook.bind(this, root || window));
}
function applyHook(root, functionName) {
    var functionNameSegments = functionName.split('.');
    var obj = root;
    while (functionNameSegments.length > 1) {
        obj = obj[functionNameSegments.shift()];
    }
    var lastSegment = functionNameSegments[0];
    var superFn = obj[lastSegment];
    var superFnLength = superFn ? superFn.length : 0;
    var functions = [];
    // start with befores
    functions = functions.concat(kitsy.queuedBeforeScripts[functionName] || []);
    // then original
    if (superFn) {
        functions.push(superFn);
    }
    // then afters
    functions = functions.concat(kitsy.queuedAfterScripts[functionName] || []);
    // overwrite original with one which will call each in order
    obj[lastSegment] = function () {
        var returnVal;
        var args = [].slice.call(arguments);
        var i = 0;
        function runBefore() {
            // All outta functions? Finish
            if (i === functions.length) {
                return returnVal;
            }
            // Update args if provided.
            if (arguments.length > 0) {
                args = [].slice.call(arguments);
            }
            if (functions[i].length > superFnLength) {
                // Assume funcs that accept more args than the original are
                // async and accept a callback as an additional argument.
                return functions[i++].apply(this, args.concat(runBefore.bind(this)));
            }
            // run synchronously
            returnVal = functions[i++].apply(this, args);
            if (returnVal && returnVal.length) {
                args = returnVal;
            }
            return runBefore.apply(this, args);
        }
        return runBefore.apply(this, arguments);
    };
}
/**
@file kitsy-script-toolkit
@summary Monkey-patching toolkit to make it easier and cleaner to run code before and after functions or to inject new code into script tags
@license WTFPL (do WTF you want)
@author Original by mildmojo; modified by Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11

*/
var kitsy = (window.kitsy = window.kitsy || {
    queuedInjectScripts: [],
    queuedBeforeScripts: {},
    queuedAfterScripts: {},
    inject: kitsyInject,
    before: before$1,
    after: after$1,
    /**
     * Applies all queued `inject` calls.
     *
     * An object that instantiates an class modified via injection will still refer to the original class,
     * so make sure to reinitialize globals that refer to injected scripts before calling `applyHooks`.
     */
    applyInjects,
    /** Apples all queued `before`/`after` calls. */
    applyHooks,
});

var hooked = kitsy.hooked;
if (!hooked) {
	kitsy.hooked = true;
	var oldStartFunc = bitsy.startExportedGame;
	bitsy.startExportedGame = function doAllInjections() {
		// Only do this once.
		bitsy.startExportedGame = oldStartFunc;

		// Rewrite scripts
		kitsy.applyInjects();

		// recreate the script and dialog objects so that they'll be
		// referencing the code with injections instead of the original
		bitsy.scriptModule = new bitsy.Script();
		bitsy.scriptInterpreter = bitsy.scriptModule.CreateInterpreter();

		bitsy.dialogModule = new bitsy.Dialog();
		bitsy.dialogRenderer = bitsy.dialogModule.CreateRenderer();
		bitsy.dialogBuffer = bitsy.dialogModule.CreateBuffer();
		bitsy.renderer = new bitsy.TileRenderer(bitsy.tilesize);

		// Hook everything
		kitsy.applyHooks();

		// reset callbacks using hacked functions
		bitsy.bitsyOnUpdate(bitsy.update);
		bitsy.bitsyOnQuit(bitsy.stopGame);
		bitsy.bitsyOnLoad(bitsy.load_game);

		// Start the game
		bitsy.startExportedGame.apply(this, arguments);
	};
}

/** @see kitsy.inject */
var inject = kitsy.inject;
/** @see kitsy.before */
var before = kitsy.before;
/** @see kitsy.after */
var after = kitsy.after;

// Rewrite custom functions' parentheses to curly braces for Bitsy's
// interpreter. Unescape escaped parentheticals, too.
function convertDialogTags(input, tag) {
	return input.replace(new RegExp('\\\\?\\((' + tag + '(\\s+(".*?"|.+?))?)\\\\?\\)', 'g'), function (match, group) {
		if (match.substr(0, 1) === '\\') {
			return '(' + group + ')'; // Rewrite \(tag "..."|...\) to (tag "..."|...)
		}
		return '{' + group + '}'; // Rewrite (tag "..."|...) to {tag "..."|...}
	});
}

function addDialogFunction(tag, fn) {
	kitsy.dialogFunctions = kitsy.dialogFunctions || {};
	if (kitsy.dialogFunctions[tag]) {
		console.warn('The dialog function "' + tag + '" already exists.');
		return;
	}

	// Hook into game load and rewrite custom functions in game data to Bitsy format.
	before('parseWorld', function (gameData) {
		return [convertDialogTags(gameData, tag)];
	});

	kitsy.dialogFunctions[tag] = fn;
}

function injectDialogTag(tag, code) {
	inject(/(var functionMap = \{\};[^]*?)(this.HasFunction)/m, '$1\nfunctionMap["' + tag + '"] = ' + code + ';\n$2');
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed immediately when the tag is reached.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters, onReturn){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 *                       onReturn: function to call with return value (just call `onReturn(null);` at the end of your function if your tag doesn't interact with the logic system)
 */
function addDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	injectDialogTag(tag, 'kitsy.dialogFunctions["' + tag + '"]');
}

/**
 * Adds a custom dialog tag which executes the provided function.
 * For ease-of-use with the bitsy editor, tags can be written as
 * (tagname "parameters") in addition to the standard {tagname "parameters"}
 *
 * Function is executed after the dialog box.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDeferredDialogTag(tag, fn) {
	addDialogFunction(tag, fn);
	bitsy.kitsy.deferredDialogFunctions = bitsy.kitsy.deferredDialogFunctions || {};
	var deferred = (bitsy.kitsy.deferredDialogFunctions[tag] = []);
	injectDialogTag(tag, 'function(e, p, o){ kitsy.deferredDialogFunctions["' + tag + '"].push({e:e,p:p}); o(null); }');
	// Hook into the dialog finish event and execute the actual function
	after('onExitDialog', function () {
		while (deferred.length) {
			var args = deferred.shift();
			bitsy.kitsy.dialogFunctions[tag](args.e, args.p, args.o);
		}
	});
	// Hook into the game reset and make sure data gets cleared
	after('clearGameData', function () {
		deferred.length = 0;
	});
}

/**
 * Adds two custom dialog tags which execute the provided function,
 * one with the provided tagname executed after the dialog box,
 * and one suffixed with 'Now' executed immediately when the tag is reached.
 *
 * i.e. helper for the (exit)/(exitNow) pattern.
 *
 * @param {string}   tag Name of tag
 * @param {Function} fn  Function to execute, with signature `function(environment, parameters){}`
 *                       environment: provides access to SetVariable/GetVariable (among other things, see Environment in the bitsy source for more info)
 *                       parameters: array containing parameters as string in first element (i.e. `parameters[0]`)
 */
function addDualDialogTag(tag, fn) {
	addDialogTag(tag + 'Now', function (environment, parameters, onReturn) {
		fn(environment, parameters);
		onReturn(null);
	});
	addDeferredDialogTag(tag, fn);
}

/**
 * Helper for printing a paragraph break inside of a dialog function.
 * Adds the function `AddParagraphBreak` to `DialogBuffer`
 */

inject(/(this\.AddLinebreak = )/, 'this.AddParagraphBreak = function() { buffer.push( [[]] ); isActive = true; };\n$1');

/**

@file paragraph-break
@summary Adds paragraph breaks to the dialogue parser
@license WTFPL (do WTF you want)
@author Sean S. LeBlanc, David Mowatt
@version 19.2.7
@requires Bitsy 7.11


@description
Adds a (p) tag to the dialogue parser that forces the following text to
start on a fresh dialogue screen, eliminating the need to spend hours testing
line lengths or adding multiple line breaks that then have to be reviewed
when you make edits or change the font size.

Note: Bitsy has a built-in implementation of paragraph-break as of 7.0;
before using this, you may want to check if it fulfills your needs.

Usage: (p)

Example: I am a cat(p)and my dialogue contains multitudes

HOW TO USE:
  1. Copy-paste this script into a new script tag after the Bitsy source code.
     It should appear *before* any other mods that handle loading your game
     data so it executes *after* them (last-in first-out).

NOTE: This uses parentheses "()" instead of curly braces "{}" around function
      calls because the Bitsy editor's fancy dialog window strips unrecognized
      curly-brace functions from dialog text. To keep from losing data, write
      these function calls with parentheses like the examples above.

      For full editor integration, you'd *probably* also need to paste this
      code at the end of the editor's `bitsy.js` file. Untested.
*/

// Adds the actual dialogue tag. No deferred version is required.
addDialogTag('p', function (environment, parameters, onReturn) {
	environment.GetDialogBuffer().AddParagraphBreak();
	onReturn(null);
});
// End of (p) paragraph break mod

/**

@file long dialog
@summary put more words onscreen
@license MIT
@author Sean S. LeBlanc
@version 19.2.7
@requires Bitsy 7.11


@description
Makes the dialog box variable in height, allowing it to expand as needed.

Minimum and maximum size are configurable.
Cheat sheet:
	2: bitsy default
	8: reaches just below the halfway mark
	16: roughly the max of the original bitsy margins
	19: max before cutting off text

Note: this hack also includes the paragraph break hack
A common pattern in bitsy is using intentional whitespace to force new dialog pages,
but the long dialog hack makes that look awkward since the text box expands.
The paragraph break hack lets you get around this by using a (p) tag to immediately end the current page.

There is also a dialog tag that lets you change the size ingame.

Usage:
	(textboxsize "<min>,<max>")
	(textboxsizeNow "<min>,<max>")

Examples:
	(textboxsize "2,6")
	(textboxsizeNow "2,2")

HOW TO USE:
	1. Copy-paste this script into a new script tag after the Bitsy source code.
	2. edit hackOptions below as needed
*/

var hackOptions$1 = {
	minRows: 2,
	maxRows: 4,
};

kitsy.longDialogOptions = hackOptions$1;

// override textbox height
inject(
	/textboxInfo\.height = .+;/,
	`Object.defineProperty(textboxInfo, 'height', {
	get() { return textboxInfo.padding_vert + (textboxInfo.padding_vert + relativeFontHeight()) * Math.max(window.kitsy.longDialogOptions.minRows, dialogBuffer.CurPage().indexOf(dialogBuffer.CurRow())+Math.sign(dialogBuffer.CurCharCount())) + textboxInfo.arrow_height; }
})`
);
// export textbox info
inject(/(var font = null;)/, 'this.textboxInfo = textboxInfo;$1');
before('renderDrawingBuffer', function (bufferId, buffer) {
	if (bufferId !== bitsy.textboxBufferId) return;
	buffer.height = bitsy.dialogRenderer.textboxInfo.height / bitsy.dialogRenderer.textboxInfo.font_scale;
});
// rewrite hard-coded row limit
inject(/(else if \(curRowIndex )== 0/g, '$1 < window.kitsy.longDialogOptions.maxRows - 1');
inject(/(if \(lastPage\.length) <= 1/, '$1 < window.kitsy.longDialogOptions.maxRows');

addDualDialogTag('textboxsize', function (environment, parameters) {
	if (!parameters[0]) {
		throw new Error('{textboxsize} was missing parameters! Usage: {textboxsize "minrows, maxrows"}');
	}
	// parse parameters
	var params = parameters[0].split(/,\s?/);
	var min = parseInt(params[0], 10);
	var max = parseInt(params[1], 10);
	hackOptions$1.minRows = min;
	hackOptions$1.maxRows = max;
});




hackOptions$1.minRows = hackOptions.minRows;
hackOptions$1.maxRows = hackOptions.maxRows;

var dialogChoices = {
	choice: 0,
	choices: [],
	choicesActive: false,
	moved: true,
	handleInput: function (dialogBuffer) {
		if (!this.choicesActive) {
			return false;
		}
		var pmoved = this.moved;
		this.moved = bitsy.input.anyKeyDown() || bitsy.input.swipeUp() || bitsy.input.swipeDown() || bitsy.input.swipeRight();
		var l = Math.max(this.choices.length, 1);
		// navigate
		if (!pmoved && ((bitsy.input.anyKeyDown() && (bitsy.input.isKeyDown(bitsy.key.up) || bitsy.input.isKeyDown(bitsy.key.w))) || bitsy.input.swipeUp())) {
			this.choice -= 1;
			if (this.choice < 0) {
				this.choice += l;
			}
			return false;
		}
		if (!pmoved && ((bitsy.input.anyKeyDown() && (bitsy.input.isKeyDown(bitsy.key.down) || bitsy.input.isKeyDown(bitsy.key.s))) || bitsy.input.swipeDown())) {
			this.choice = (this.choice + 1) % l;
			return false;
		}
		// select
		if (
			!pmoved &&
			((bitsy.input.anyKeyDown() &&
				(bitsy.input.isKeyDown(bitsy.key.right) || bitsy.input.isKeyDown(bitsy.key.d) || bitsy.input.isKeyDown(bitsy.key.enter) || bitsy.input.isKeyDown(bitsy.key.space))) ||
				bitsy.input.swipeRight())
		) {
			// evaluate choice
			this.choices[this.choice]();
			// reset
			this.choice = 0;
			this.choices = [];
			this.choicesActive = false;
			// get back into the regular dialog flow
			if (dialogBuffer.Continue()) {
				dialogBuffer.Update(0);
				// make sure to close dialog if there's nothing to say
				// after the choice has been made
				if (!dialogBuffer.CurCharCount()) {
					dialogBuffer.EndDialog();
				}
			}
			return true;
		}
		return false;
	},
};

bitsy.dialogChoices = dialogChoices;

function getCursorSprite(cursor) {
	return cursor
		? `renderer.GetDrawingSource(sprite['${cursor}'].drw)[sprite['${cursor}'].animation.frameIndex]`
		: `[
		[0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0],
		[0, 1, 0, 0, 0, 0, 0, 0],
		[0, 1, 1, 0, 0, 0, 0, 0],
		[0, 1, 1, 1, 0, 0, 0, 0],
		[0, 1, 1, 0, 0, 0, 0, 0],
		[0, 1, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0]
	]`;
}

// parsing
// (adds a new sequence node type)
inject(/(\|\| str === "shuffle")/, '$1 || str === "choice"');
inject(
	/(state\.curNode\.AddChild\(new ShuffleNode\(options\)\);\n.*})/,
	`$1
else if(sequenceType === "choice") {
	state.curNode.AddChild(new ChoiceNode(options));
}`
);

inject(
	/(var ShuffleNode = )/,
	`
var ChoiceNode = function(options) {
	Object.assign( this, new TreeRelationship() );
	Object.assign( this, new SequenceBase() );
	this.type = "choice";
	this.options = options;
	options.forEach(function(option){
		var br = option.children.find(function(child){ return child.name === 'br'; });
		if (!br) {
			option.onSelect = [];
			return;
		}
		var idx = option.children.indexOf(br);
		option.onSelect = option.children.slice(idx+1);
		option.children = option.children.slice(0, idx);
	});

	this.Eval = function(environment,onReturn) {
		var lastVal = null;
		var i = 0;
		var prevRows = window.kitsy.longDialogOptions.maxRows;
		window.kitsy.longDialogOptions.maxRows = Infinity;
		function evalChildren(children,done) {
			if(i < children.length) {
				children[i].Eval(environment, function(val) {
					if (i === children.length - 1) {
						environment.GetDialogBuffer().AddParagraphBreak();
					} else {
						environment.GetDialogBuffer().AddLinebreak();
					}
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
				setTimeout(() => {
					window.dialogChoices.choicesActive = true;
				});
			}
		}
		window.dialogChoices.choices = this.options.map(function(option){
			return function(){
				window.kitsy.longDialogOptions.maxRows = prevRows;
				option.onSelect.forEach(function(child){
					child.Eval(environment, function(){});
				});
			};
		});
		if (environment.GetDialogBuffer().CurCharCount() > 0) {
			environment.GetDialogBuffer().AddParagraphBreak();
		}
		evalChildren(this.options, function () {
			onReturn(lastVal);
		});
	}
}
$1`
);

// rendering
// (re-uses existing arrow image data,
// but draws rotated to point at text)
inject(
	/(this\.DrawNextArrow = )/,
	`
this.DrawChoiceArrow = function() {
	bitsyDrawBegin(1);
	var rows = ${hackOptions.cursor};
	var top = (${hackOptions.transform.y} + window.dialogChoices.choice * (textboxInfo.padding_vert + relativeFontHeight())) * text_scale;
	var left = ${hackOptions.transform.x}*text_scale;
	for (var y = 0; y < rows.length; y++) {
		var cols = rows[y];
		for (var x = 0; x < cols.length; x++) {
			if (cols[x]) {
				//scaling nonsense
				for (var sy = 0; sy < text_scale; sy++) {
					for (var sx = 0; sx < text_scale; sx++) {
						bitsyDrawPixel(textArrowIndex, left + (x * text_scale) + sx, top + (y * text_scale) + sy);
					}
				}
			}
		}
	}
	bitsyDrawEnd();
};
$1`
);
inject(
	/(this\.DrawTextbox\(\);)/,
	`
if (window.dialogChoices.choicesActive) {
	this.DrawChoiceArrow();
}
$1`
);

// interaction
// (overrides the dialog skip/page flip)
inject(
	/(if\(\s*dialogBuffer\.IsActive\(\)\s*\) {)/,
	`$1
if(window.dialogChoices.handleInput(dialogBuffer)) {
	return;
} else `
);
inject(
	/(this\.CanContinue = function\(\) {)/,
	`$1
if(window.dialogChoices.choicesActive){
	return false;
}
`
);

exports.hackOptions = hackOptions;

Object.defineProperty(exports, '__esModule', { value: true });

})(this.hacks.dialog_choices = this.hacks.dialog_choices || {}, window);



//EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEnd of Dialog Choicessssssssssssssssssssssssssssssssssssssssssssssssss



</script>

</head>


<!-- DOCUMENT BODY -->
<body onload='startExportedGame()'>
<!-- GAME CANVAS -->
<canvas id='game'></canvas>
</body>


</html>
